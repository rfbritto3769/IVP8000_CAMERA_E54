
IVP8000_CAMERA_E54.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00005e70  00000000  00000000  00010000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .relocate     000004dc  20000000  00005e70  00020000  2**3
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bkupram      00000000  47000000  47000000  000204dc  2**0
                  CONTENTS
  3 .qspi         00000000  04000000  04000000  000204dc  2**0
                  CONTENTS
  4 .bss          00025ec8  200004e0  00006350  000204dc  2**4
                  ALLOC
  5 .stack        00010000  200263a8  0002c218  000204dc  2**0
                  ALLOC
  6 .ARM.attributes 0000002e  00000000  00000000  000204dc  2**0
                  CONTENTS, READONLY
  7 .comment      00000059  00000000  00000000  0002050a  2**0
                  CONTENTS, READONLY
  8 .debug_info   0002483d  00000000  00000000  00020563  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_abbrev 00003808  00000000  00000000  00044da0  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    0000cd62  00000000  00000000  000485a8  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_aranges 000016d8  00000000  00000000  0005530a  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00001508  00000000  00000000  000569e2  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_macro  0003789d  00000000  00000000  00057eea  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_line   00019ed6  00000000  00000000  0008f787  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_str    00123f9d  00000000  00000000  000a965d  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_frame  00006098  00000000  00000000  001cd5fc  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <exception_table>:
       0:	a8 63 03 20 e1 02 00 00 7d 03 00 00 7d 03 00 00     .c. ....}...}...
      10:	7d 03 00 00 7d 03 00 00 7d 03 00 00 00 00 00 00     }...}...}.......
	...
      2c:	7d 03 00 00 7d 03 00 00 00 00 00 00 7d 03 00 00     }...}.......}...
      3c:	7d 03 00 00 7d 03 00 00 7d 03 00 00 7d 03 00 00     }...}...}...}...
      4c:	7d 03 00 00 7d 03 00 00 7d 03 00 00 7d 03 00 00     }...}...}...}...
      5c:	7d 03 00 00 7d 03 00 00 7d 03 00 00 7d 03 00 00     }...}...}...}...
      6c:	7d 03 00 00 7d 03 00 00 7d 03 00 00 7d 03 00 00     }...}...}...}...
      7c:	7d 03 00 00 7d 03 00 00 7d 03 00 00 7d 03 00 00     }...}...}...}...
      8c:	7d 03 00 00 7d 03 00 00 7d 03 00 00 7d 03 00 00     }...}...}...}...
      9c:	7d 03 00 00 bd 2d 00 00 cd 2d 00 00 7d 03 00 00     }....-...-..}...
      ac:	7d 03 00 00 7d 03 00 00 7d 03 00 00 7d 03 00 00     }...}...}...}...
      bc:	6d 27 00 00 7d 27 00 00 8d 27 00 00 9d 27 00 00     m'..}'...'...'..
      cc:	ad 27 00 00 7d 03 00 00 7d 03 00 00 7d 03 00 00     .'..}...}...}...
      dc:	7d 03 00 00 7d 03 00 00 7d 03 00 00 00 00 00 00     }...}...}.......
	...
      f4:	c1 35 00 00 7d 03 00 00 7d 03 00 00 7d 03 00 00     .5..}...}...}...
     104:	7d 03 00 00 f5 4a 00 00 11 4b 00 00 2d 4b 00 00     }....J...K..-K..
     114:	49 4b 00 00 7d 03 00 00 7d 03 00 00 7d 03 00 00     IK..}...}...}...
     124:	7d 03 00 00 7d 03 00 00 7d 03 00 00 7d 03 00 00     }...}...}...}...
     134:	7d 03 00 00 7d 03 00 00 7d 03 00 00 7d 03 00 00     }...}...}...}...
     144:	7d 03 00 00 7d 03 00 00 7d 03 00 00 7d 03 00 00     }...}...}...}...
     154:	7d 03 00 00 7d 03 00 00 7d 03 00 00 7d 03 00 00     }...}...}...}...
     164:	7d 03 00 00 7d 03 00 00 7d 03 00 00 7d 03 00 00     }...}...}...}...
     174:	7d 03 00 00 7d 03 00 00 7d 03 00 00 7d 03 00 00     }...}...}...}...
     184:	7d 03 00 00 7d 03 00 00 7d 03 00 00 7d 03 00 00     }...}...}...}...
     194:	fd 52 00 00 7d 03 00 00 7d 03 00 00 7d 03 00 00     .R..}...}...}...
     1a4:	7d 03 00 00 7d 03 00 00 7d 03 00 00 7d 03 00 00     }...}...}...}...
     1b4:	7d 03 00 00 7d 03 00 00 7d 03 00 00 7d 03 00 00     }...}...}...}...
     1c4:	7d 03 00 00 7d 03 00 00 7d 03 00 00 7d 03 00 00     }...}...}...}...
     1d4:	7d 03 00 00 7d 03 00 00 7d 03 00 00 7d 03 00 00     }...}...}...}...
     1e4:	7d 03 00 00 7d 03 00 00 7d 03 00 00 7d 03 00 00     }...}...}...}...
     1f4:	7d 03 00 00 7d 03 00 00 7d 03 00 00 7d 03 00 00     }...}...}...}...
     204:	7d 03 00 00 7d 03 00 00 7d 03 00 00 7d 03 00 00     }...}...}...}...
     214:	7d 03 00 00 7d 03 00 00 7d 03 00 00 7d 03 00 00     }...}...}...}...
     224:	7d 03 00 00 7d 03 00 00 7d 03 00 00 7d 03 00 00     }...}...}...}...
     234:	7d 03 00 00 7d 03 00 00 7d 03 00 00 7d 03 00 00     }...}...}...}...
     244:	35 35 00 00 7d 03 00 00 7d 03 00 00 7d 03 00 00     55..}...}...}...
     254:	7d 03 00 00 7d 03 00 00 7d 03 00 00 7d 03 00 00     }...}...}...}...

00000264 <__do_global_dtors_aux>:
     264:	b510      	push	{r4, lr}
     266:	4c05      	ldr	r4, [pc, #20]	; (27c <__do_global_dtors_aux+0x18>)
     268:	7823      	ldrb	r3, [r4, #0]
     26a:	b933      	cbnz	r3, 27a <__do_global_dtors_aux+0x16>
     26c:	4b04      	ldr	r3, [pc, #16]	; (280 <__do_global_dtors_aux+0x1c>)
     26e:	b113      	cbz	r3, 276 <__do_global_dtors_aux+0x12>
     270:	4804      	ldr	r0, [pc, #16]	; (284 <__do_global_dtors_aux+0x20>)
     272:	f3af 8000 	nop.w
     276:	2301      	movs	r3, #1
     278:	7023      	strb	r3, [r4, #0]
     27a:	bd10      	pop	{r4, pc}
     27c:	200004e0 	.word	0x200004e0
     280:	00000000 	.word	0x00000000
     284:	00005e70 	.word	0x00005e70

00000288 <frame_dummy>:
     288:	4b0c      	ldr	r3, [pc, #48]	; (2bc <frame_dummy+0x34>)
     28a:	b143      	cbz	r3, 29e <frame_dummy+0x16>
     28c:	480c      	ldr	r0, [pc, #48]	; (2c0 <frame_dummy+0x38>)
     28e:	490d      	ldr	r1, [pc, #52]	; (2c4 <frame_dummy+0x3c>)
     290:	b510      	push	{r4, lr}
     292:	f3af 8000 	nop.w
     296:	480c      	ldr	r0, [pc, #48]	; (2c8 <frame_dummy+0x40>)
     298:	6803      	ldr	r3, [r0, #0]
     29a:	b923      	cbnz	r3, 2a6 <frame_dummy+0x1e>
     29c:	bd10      	pop	{r4, pc}
     29e:	480a      	ldr	r0, [pc, #40]	; (2c8 <frame_dummy+0x40>)
     2a0:	6803      	ldr	r3, [r0, #0]
     2a2:	b933      	cbnz	r3, 2b2 <frame_dummy+0x2a>
     2a4:	4770      	bx	lr
     2a6:	4b09      	ldr	r3, [pc, #36]	; (2cc <frame_dummy+0x44>)
     2a8:	2b00      	cmp	r3, #0
     2aa:	d0f7      	beq.n	29c <frame_dummy+0x14>
     2ac:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
     2b0:	4718      	bx	r3
     2b2:	4b06      	ldr	r3, [pc, #24]	; (2cc <frame_dummy+0x44>)
     2b4:	2b00      	cmp	r3, #0
     2b6:	d0f5      	beq.n	2a4 <frame_dummy+0x1c>
     2b8:	4718      	bx	r3
     2ba:	bf00      	nop
     2bc:	00000000 	.word	0x00000000
     2c0:	00005e70 	.word	0x00005e70
     2c4:	200004e4 	.word	0x200004e4
     2c8:	00005e70 	.word	0x00005e70
     2cc:	00000000 	.word	0x00000000

000002d0 <atmel_start_init>:

/**
 * Initializes MCU, drivers and middleware in the project
 **/
void atmel_start_init(void)
{
     2d0:	b580      	push	{r7, lr}
     2d2:	af00      	add	r7, sp, #0
	system_init();
     2d4:	4b01      	ldr	r3, [pc, #4]	; (2dc <atmel_start_init+0xc>)
     2d6:	4798      	blx	r3
}
     2d8:	bf00      	nop
     2da:	bd80      	pop	{r7, pc}
     2dc:	00000d31 	.word	0x00000d31

000002e0 <Reset_Handler>:
/**
 * \brief This is the code that gets called on processor reset.
 * To initialize the device, and call the main() routine.
 */
void Reset_Handler(void)
{
     2e0:	b580      	push	{r7, lr}
     2e2:	b082      	sub	sp, #8
     2e4:	af00      	add	r7, sp, #0
        uint32_t *pSrc, *pDest;

        /* Initialize the relocate segment */
        pSrc = &_etext;
     2e6:	4b1c      	ldr	r3, [pc, #112]	; (358 <Reset_Handler+0x78>)
     2e8:	607b      	str	r3, [r7, #4]
        pDest = &_srelocate;
     2ea:	4b1c      	ldr	r3, [pc, #112]	; (35c <Reset_Handler+0x7c>)
     2ec:	603b      	str	r3, [r7, #0]

        if (pSrc != pDest) {
     2ee:	687a      	ldr	r2, [r7, #4]
     2f0:	683b      	ldr	r3, [r7, #0]
     2f2:	429a      	cmp	r2, r3
     2f4:	d00c      	beq.n	310 <Reset_Handler+0x30>
                for (; pDest < &_erelocate;) {
     2f6:	e007      	b.n	308 <Reset_Handler+0x28>
                        *pDest++ = *pSrc++;
     2f8:	683b      	ldr	r3, [r7, #0]
     2fa:	1d1a      	adds	r2, r3, #4
     2fc:	603a      	str	r2, [r7, #0]
     2fe:	687a      	ldr	r2, [r7, #4]
     300:	1d11      	adds	r1, r2, #4
     302:	6079      	str	r1, [r7, #4]
     304:	6812      	ldr	r2, [r2, #0]
     306:	601a      	str	r2, [r3, #0]
                for (; pDest < &_erelocate;) {
     308:	683b      	ldr	r3, [r7, #0]
     30a:	4a15      	ldr	r2, [pc, #84]	; (360 <Reset_Handler+0x80>)
     30c:	4293      	cmp	r3, r2
     30e:	d3f3      	bcc.n	2f8 <Reset_Handler+0x18>
                }
        }

        /* Clear the zero segment */
        for (pDest = &_szero; pDest < &_ezero;) {
     310:	4b14      	ldr	r3, [pc, #80]	; (364 <Reset_Handler+0x84>)
     312:	603b      	str	r3, [r7, #0]
     314:	e004      	b.n	320 <Reset_Handler+0x40>
                *pDest++ = 0;
     316:	683b      	ldr	r3, [r7, #0]
     318:	1d1a      	adds	r2, r3, #4
     31a:	603a      	str	r2, [r7, #0]
     31c:	2200      	movs	r2, #0
     31e:	601a      	str	r2, [r3, #0]
        for (pDest = &_szero; pDest < &_ezero;) {
     320:	683b      	ldr	r3, [r7, #0]
     322:	4a11      	ldr	r2, [pc, #68]	; (368 <Reset_Handler+0x88>)
     324:	4293      	cmp	r3, r2
     326:	d3f6      	bcc.n	316 <Reset_Handler+0x36>
        }

        /* Set the vector table base address */
        pSrc = (uint32_t *) & _sfixed;
     328:	4b10      	ldr	r3, [pc, #64]	; (36c <Reset_Handler+0x8c>)
     32a:	607b      	str	r3, [r7, #4]
        SCB->VTOR = ((uint32_t) pSrc & SCB_VTOR_TBLOFF_Msk);
     32c:	4a10      	ldr	r2, [pc, #64]	; (370 <Reset_Handler+0x90>)
     32e:	687b      	ldr	r3, [r7, #4]
     330:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
     334:	6093      	str	r3, [r2, #8]

#if __FPU_USED
        /* Enable FPU */
        SCB->CPACR |=  (0xFu << 20);
     336:	4a0e      	ldr	r2, [pc, #56]	; (370 <Reset_Handler+0x90>)
     338:	4b0d      	ldr	r3, [pc, #52]	; (370 <Reset_Handler+0x90>)
     33a:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
     33e:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
     342:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
     346:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
     34a:	f3bf 8f6f 	isb	sy
        __DSB();
        __ISB();
#endif

        /* Initialize the C library */
        __libc_init_array();
     34e:	4b09      	ldr	r3, [pc, #36]	; (374 <Reset_Handler+0x94>)
     350:	4798      	blx	r3

        /* Branch to main function */
        main();
     352:	4b09      	ldr	r3, [pc, #36]	; (378 <Reset_Handler+0x98>)
     354:	4798      	blx	r3

        /* Infinite loop */
        while (1);
     356:	e7fe      	b.n	356 <Reset_Handler+0x76>
     358:	00005e70 	.word	0x00005e70
     35c:	20000000 	.word	0x20000000
     360:	200004dc 	.word	0x200004dc
     364:	200004e0 	.word	0x200004e0
     368:	200263a8 	.word	0x200263a8
     36c:	00000000 	.word	0x00000000
     370:	e000ed00 	.word	0xe000ed00
     374:	00005971 	.word	0x00005971
     378:	00005831 	.word	0x00005831

0000037c <Dummy_Handler>:

/**
 * \brief Default interrupt handler for unused IRQs.
 */
void Dummy_Handler(void)
{
     37c:	b480      	push	{r7}
     37e:	af00      	add	r7, sp, #0
        while (1) {
     380:	e7fe      	b.n	380 <Dummy_Handler+0x4>

00000382 <hri_gclk_write_PCHCTRL_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_gclk_write_PCHCTRL_reg(const void *const hw, uint8_t index, hri_gclk_pchctrl_reg_t data)
{
     382:	b480      	push	{r7}
     384:	b085      	sub	sp, #20
     386:	af00      	add	r7, sp, #0
     388:	60f8      	str	r0, [r7, #12]
     38a:	460b      	mov	r3, r1
     38c:	607a      	str	r2, [r7, #4]
     38e:	72fb      	strb	r3, [r7, #11]
	GCLK_CRITICAL_SECTION_ENTER();
	((Gclk *)hw)->PCHCTRL[index].reg = data;
     390:	7afa      	ldrb	r2, [r7, #11]
     392:	68fb      	ldr	r3, [r7, #12]
     394:	3220      	adds	r2, #32
     396:	6879      	ldr	r1, [r7, #4]
     398:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
	GCLK_CRITICAL_SECTION_LEAVE();
}
     39c:	bf00      	nop
     39e:	3714      	adds	r7, #20
     3a0:	46bd      	mov	sp, r7
     3a2:	f85d 7b04 	ldr.w	r7, [sp], #4
     3a6:	4770      	bx	lr

000003a8 <hri_mclk_set_APBAMASK_EIC_bit>:
	((Mclk *)hw)->APBAMASK.reg ^= MCLK_APBAMASK_RTC;
	MCLK_CRITICAL_SECTION_LEAVE();
}

static inline void hri_mclk_set_APBAMASK_EIC_bit(const void *const hw)
{
     3a8:	b480      	push	{r7}
     3aa:	b083      	sub	sp, #12
     3ac:	af00      	add	r7, sp, #0
     3ae:	6078      	str	r0, [r7, #4]
	MCLK_CRITICAL_SECTION_ENTER();
	((Mclk *)hw)->APBAMASK.reg |= MCLK_APBAMASK_EIC;
     3b0:	687b      	ldr	r3, [r7, #4]
     3b2:	695b      	ldr	r3, [r3, #20]
     3b4:	f443 6280 	orr.w	r2, r3, #1024	; 0x400
     3b8:	687b      	ldr	r3, [r7, #4]
     3ba:	615a      	str	r2, [r3, #20]
	MCLK_CRITICAL_SECTION_LEAVE();
}
     3bc:	bf00      	nop
     3be:	370c      	adds	r7, #12
     3c0:	46bd      	mov	sp, r7
     3c2:	f85d 7b04 	ldr.w	r7, [sp], #4
     3c6:	4770      	bx	lr

000003c8 <hri_mclk_set_APBAMASK_SERCOM1_bit>:
	((Mclk *)hw)->APBAMASK.reg ^= MCLK_APBAMASK_SERCOM0;
	MCLK_CRITICAL_SECTION_LEAVE();
}

static inline void hri_mclk_set_APBAMASK_SERCOM1_bit(const void *const hw)
{
     3c8:	b480      	push	{r7}
     3ca:	b083      	sub	sp, #12
     3cc:	af00      	add	r7, sp, #0
     3ce:	6078      	str	r0, [r7, #4]
	MCLK_CRITICAL_SECTION_ENTER();
	((Mclk *)hw)->APBAMASK.reg |= MCLK_APBAMASK_SERCOM1;
     3d0:	687b      	ldr	r3, [r7, #4]
     3d2:	695b      	ldr	r3, [r3, #20]
     3d4:	f443 5200 	orr.w	r2, r3, #8192	; 0x2000
     3d8:	687b      	ldr	r3, [r7, #4]
     3da:	615a      	str	r2, [r3, #20]
	MCLK_CRITICAL_SECTION_LEAVE();
}
     3dc:	bf00      	nop
     3de:	370c      	adds	r7, #12
     3e0:	46bd      	mov	sp, r7
     3e2:	f85d 7b04 	ldr.w	r7, [sp], #4
     3e6:	4770      	bx	lr

000003e8 <hri_mclk_set_APBBMASK_EVSYS_bit>:
	((Mclk *)hw)->APBBMASK.reg ^= MCLK_APBBMASK_HMATRIX;
	MCLK_CRITICAL_SECTION_LEAVE();
}

static inline void hri_mclk_set_APBBMASK_EVSYS_bit(const void *const hw)
{
     3e8:	b480      	push	{r7}
     3ea:	b083      	sub	sp, #12
     3ec:	af00      	add	r7, sp, #0
     3ee:	6078      	str	r0, [r7, #4]
	MCLK_CRITICAL_SECTION_ENTER();
	((Mclk *)hw)->APBBMASK.reg |= MCLK_APBBMASK_EVSYS;
     3f0:	687b      	ldr	r3, [r7, #4]
     3f2:	699b      	ldr	r3, [r3, #24]
     3f4:	f043 0280 	orr.w	r2, r3, #128	; 0x80
     3f8:	687b      	ldr	r3, [r7, #4]
     3fa:	619a      	str	r2, [r3, #24]
	MCLK_CRITICAL_SECTION_LEAVE();
}
     3fc:	bf00      	nop
     3fe:	370c      	adds	r7, #12
     400:	46bd      	mov	sp, r7
     402:	f85d 7b04 	ldr.w	r7, [sp], #4
     406:	4770      	bx	lr

00000408 <hri_mclk_set_APBBMASK_TCC0_bit>:
	((Mclk *)hw)->APBBMASK.reg ^= MCLK_APBBMASK_SERCOM3;
	MCLK_CRITICAL_SECTION_LEAVE();
}

static inline void hri_mclk_set_APBBMASK_TCC0_bit(const void *const hw)
{
     408:	b480      	push	{r7}
     40a:	b083      	sub	sp, #12
     40c:	af00      	add	r7, sp, #0
     40e:	6078      	str	r0, [r7, #4]
	MCLK_CRITICAL_SECTION_ENTER();
	((Mclk *)hw)->APBBMASK.reg |= MCLK_APBBMASK_TCC0;
     410:	687b      	ldr	r3, [r7, #4]
     412:	699b      	ldr	r3, [r3, #24]
     414:	f443 6200 	orr.w	r2, r3, #2048	; 0x800
     418:	687b      	ldr	r3, [r7, #4]
     41a:	619a      	str	r2, [r3, #24]
	MCLK_CRITICAL_SECTION_LEAVE();
}
     41c:	bf00      	nop
     41e:	370c      	adds	r7, #12
     420:	46bd      	mov	sp, r7
     422:	f85d 7b04 	ldr.w	r7, [sp], #4
     426:	4770      	bx	lr

00000428 <hri_mclk_set_APBDMASK_SERCOM7_bit>:
	((Mclk *)hw)->APBDMASK.reg ^= MCLK_APBDMASK_SERCOM6;
	MCLK_CRITICAL_SECTION_LEAVE();
}

static inline void hri_mclk_set_APBDMASK_SERCOM7_bit(const void *const hw)
{
     428:	b480      	push	{r7}
     42a:	b083      	sub	sp, #12
     42c:	af00      	add	r7, sp, #0
     42e:	6078      	str	r0, [r7, #4]
	MCLK_CRITICAL_SECTION_ENTER();
	((Mclk *)hw)->APBDMASK.reg |= MCLK_APBDMASK_SERCOM7;
     430:	687b      	ldr	r3, [r7, #4]
     432:	6a1b      	ldr	r3, [r3, #32]
     434:	f043 0208 	orr.w	r2, r3, #8
     438:	687b      	ldr	r3, [r7, #4]
     43a:	621a      	str	r2, [r3, #32]
	MCLK_CRITICAL_SECTION_LEAVE();
}
     43c:	bf00      	nop
     43e:	370c      	adds	r7, #12
     440:	46bd      	mov	sp, r7
     442:	f85d 7b04 	ldr.w	r7, [sp], #4
     446:	4770      	bx	lr

00000448 <hri_mclk_set_APBDMASK_PCC_bit>:
	((Mclk *)hw)->APBDMASK.reg ^= MCLK_APBDMASK_I2S;
	MCLK_CRITICAL_SECTION_LEAVE();
}

static inline void hri_mclk_set_APBDMASK_PCC_bit(const void *const hw)
{
     448:	b480      	push	{r7}
     44a:	b083      	sub	sp, #12
     44c:	af00      	add	r7, sp, #0
     44e:	6078      	str	r0, [r7, #4]
	MCLK_CRITICAL_SECTION_ENTER();
	((Mclk *)hw)->APBDMASK.reg |= MCLK_APBDMASK_PCC;
     450:	687b      	ldr	r3, [r7, #4]
     452:	6a1b      	ldr	r3, [r3, #32]
     454:	f443 6200 	orr.w	r2, r3, #2048	; 0x800
     458:	687b      	ldr	r3, [r7, #4]
     45a:	621a      	str	r2, [r3, #32]
	MCLK_CRITICAL_SECTION_LEAVE();
}
     45c:	bf00      	nop
     45e:	370c      	adds	r7, #12
     460:	46bd      	mov	sp, r7
     462:	f85d 7b04 	ldr.w	r7, [sp], #4
     466:	4770      	bx	lr

00000468 <hri_port_set_DIR_reg>:
{
	((Port *)hw)->Group[submodule_index].DIRTGL.reg = PORT_DIR_DIR(mask);
}

static inline void hri_port_set_DIR_reg(const void *const hw, uint8_t submodule_index, hri_port_dir_reg_t mask)
{
     468:	b480      	push	{r7}
     46a:	b085      	sub	sp, #20
     46c:	af00      	add	r7, sp, #0
     46e:	60f8      	str	r0, [r7, #12]
     470:	460b      	mov	r3, r1
     472:	607a      	str	r2, [r7, #4]
     474:	72fb      	strb	r3, [r7, #11]
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     476:	7afb      	ldrb	r3, [r7, #11]
     478:	68fa      	ldr	r2, [r7, #12]
     47a:	01db      	lsls	r3, r3, #7
     47c:	4413      	add	r3, r2
     47e:	3308      	adds	r3, #8
     480:	687a      	ldr	r2, [r7, #4]
     482:	601a      	str	r2, [r3, #0]
}
     484:	bf00      	nop
     486:	3714      	adds	r7, #20
     488:	46bd      	mov	sp, r7
     48a:	f85d 7b04 	ldr.w	r7, [sp], #4
     48e:	4770      	bx	lr

00000490 <hri_port_clear_DIR_reg>:
	((Port *)hw)->Group[submodule_index].DIRSET.reg = data;
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = ~data;
}

static inline void hri_port_clear_DIR_reg(const void *const hw, uint8_t submodule_index, hri_port_dir_reg_t mask)
{
     490:	b480      	push	{r7}
     492:	b085      	sub	sp, #20
     494:	af00      	add	r7, sp, #0
     496:	60f8      	str	r0, [r7, #12]
     498:	460b      	mov	r3, r1
     49a:	607a      	str	r2, [r7, #4]
     49c:	72fb      	strb	r3, [r7, #11]
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
     49e:	7afb      	ldrb	r3, [r7, #11]
     4a0:	68fa      	ldr	r2, [r7, #12]
     4a2:	01db      	lsls	r3, r3, #7
     4a4:	4413      	add	r3, r2
     4a6:	3304      	adds	r3, #4
     4a8:	687a      	ldr	r2, [r7, #4]
     4aa:	601a      	str	r2, [r3, #0]
}
     4ac:	bf00      	nop
     4ae:	3714      	adds	r7, #20
     4b0:	46bd      	mov	sp, r7
     4b2:	f85d 7b04 	ldr.w	r7, [sp], #4
     4b6:	4770      	bx	lr

000004b8 <hri_port_set_OUT_reg>:
{
	((Port *)hw)->Group[submodule_index].OUTTGL.reg = PORT_OUT_OUT(mask);
}

static inline void hri_port_set_OUT_reg(const void *const hw, uint8_t submodule_index, hri_port_out_reg_t mask)
{
     4b8:	b480      	push	{r7}
     4ba:	b085      	sub	sp, #20
     4bc:	af00      	add	r7, sp, #0
     4be:	60f8      	str	r0, [r7, #12]
     4c0:	460b      	mov	r3, r1
     4c2:	607a      	str	r2, [r7, #4]
     4c4:	72fb      	strb	r3, [r7, #11]
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
     4c6:	7afb      	ldrb	r3, [r7, #11]
     4c8:	68fa      	ldr	r2, [r7, #12]
     4ca:	01db      	lsls	r3, r3, #7
     4cc:	4413      	add	r3, r2
     4ce:	3318      	adds	r3, #24
     4d0:	687a      	ldr	r2, [r7, #4]
     4d2:	601a      	str	r2, [r3, #0]
}
     4d4:	bf00      	nop
     4d6:	3714      	adds	r7, #20
     4d8:	46bd      	mov	sp, r7
     4da:	f85d 7b04 	ldr.w	r7, [sp], #4
     4de:	4770      	bx	lr

000004e0 <hri_port_clear_OUT_reg>:
	((Port *)hw)->Group[submodule_index].OUTSET.reg = data;
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = ~data;
}

static inline void hri_port_clear_OUT_reg(const void *const hw, uint8_t submodule_index, hri_port_out_reg_t mask)
{
     4e0:	b480      	push	{r7}
     4e2:	b085      	sub	sp, #20
     4e4:	af00      	add	r7, sp, #0
     4e6:	60f8      	str	r0, [r7, #12]
     4e8:	460b      	mov	r3, r1
     4ea:	607a      	str	r2, [r7, #4]
     4ec:	72fb      	strb	r3, [r7, #11]
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
     4ee:	7afb      	ldrb	r3, [r7, #11]
     4f0:	68fa      	ldr	r2, [r7, #12]
     4f2:	01db      	lsls	r3, r3, #7
     4f4:	4413      	add	r3, r2
     4f6:	3314      	adds	r3, #20
     4f8:	687a      	ldr	r2, [r7, #4]
     4fa:	601a      	str	r2, [r3, #0]
}
     4fc:	bf00      	nop
     4fe:	3714      	adds	r7, #20
     500:	46bd      	mov	sp, r7
     502:	f85d 7b04 	ldr.w	r7, [sp], #4
     506:	4770      	bx	lr

00000508 <hri_port_write_PMUX_PMUXE_bf>:
	return tmp;
}

static inline void hri_port_write_PMUX_PMUXE_bf(const void *const hw, uint8_t submodule_index, uint8_t index,
                                                hri_port_pmux_reg_t data)
{
     508:	b480      	push	{r7}
     50a:	b085      	sub	sp, #20
     50c:	af00      	add	r7, sp, #0
     50e:	6078      	str	r0, [r7, #4]
     510:	4608      	mov	r0, r1
     512:	4611      	mov	r1, r2
     514:	461a      	mov	r2, r3
     516:	4603      	mov	r3, r0
     518:	70fb      	strb	r3, [r7, #3]
     51a:	460b      	mov	r3, r1
     51c:	70bb      	strb	r3, [r7, #2]
     51e:	4613      	mov	r3, r2
     520:	707b      	strb	r3, [r7, #1]
	uint8_t tmp;
	PORT_CRITICAL_SECTION_ENTER();
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     522:	78fa      	ldrb	r2, [r7, #3]
     524:	78bb      	ldrb	r3, [r7, #2]
     526:	6879      	ldr	r1, [r7, #4]
     528:	01d2      	lsls	r2, r2, #7
     52a:	440a      	add	r2, r1
     52c:	4413      	add	r3, r2
     52e:	3330      	adds	r3, #48	; 0x30
     530:	781b      	ldrb	r3, [r3, #0]
     532:	73fb      	strb	r3, [r7, #15]
	tmp &= ~PORT_PMUX_PMUXE_Msk;
     534:	7bfb      	ldrb	r3, [r7, #15]
     536:	f023 030f 	bic.w	r3, r3, #15
     53a:	73fb      	strb	r3, [r7, #15]
	tmp |= PORT_PMUX_PMUXE(data);
     53c:	787b      	ldrb	r3, [r7, #1]
     53e:	f003 030f 	and.w	r3, r3, #15
     542:	b2da      	uxtb	r2, r3
     544:	7bfb      	ldrb	r3, [r7, #15]
     546:	4313      	orrs	r3, r2
     548:	73fb      	strb	r3, [r7, #15]
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     54a:	78fa      	ldrb	r2, [r7, #3]
     54c:	78bb      	ldrb	r3, [r7, #2]
     54e:	6879      	ldr	r1, [r7, #4]
     550:	01d2      	lsls	r2, r2, #7
     552:	440a      	add	r2, r1
     554:	4413      	add	r3, r2
     556:	3330      	adds	r3, #48	; 0x30
     558:	7bfa      	ldrb	r2, [r7, #15]
     55a:	701a      	strb	r2, [r3, #0]
	PORT_CRITICAL_SECTION_LEAVE();
}
     55c:	bf00      	nop
     55e:	3714      	adds	r7, #20
     560:	46bd      	mov	sp, r7
     562:	f85d 7b04 	ldr.w	r7, [sp], #4
     566:	4770      	bx	lr

00000568 <hri_port_write_PMUX_PMUXO_bf>:
	return tmp;
}

static inline void hri_port_write_PMUX_PMUXO_bf(const void *const hw, uint8_t submodule_index, uint8_t index,
                                                hri_port_pmux_reg_t data)
{
     568:	b480      	push	{r7}
     56a:	b085      	sub	sp, #20
     56c:	af00      	add	r7, sp, #0
     56e:	6078      	str	r0, [r7, #4]
     570:	4608      	mov	r0, r1
     572:	4611      	mov	r1, r2
     574:	461a      	mov	r2, r3
     576:	4603      	mov	r3, r0
     578:	70fb      	strb	r3, [r7, #3]
     57a:	460b      	mov	r3, r1
     57c:	70bb      	strb	r3, [r7, #2]
     57e:	4613      	mov	r3, r2
     580:	707b      	strb	r3, [r7, #1]
	uint8_t tmp;
	PORT_CRITICAL_SECTION_ENTER();
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     582:	78fa      	ldrb	r2, [r7, #3]
     584:	78bb      	ldrb	r3, [r7, #2]
     586:	6879      	ldr	r1, [r7, #4]
     588:	01d2      	lsls	r2, r2, #7
     58a:	440a      	add	r2, r1
     58c:	4413      	add	r3, r2
     58e:	3330      	adds	r3, #48	; 0x30
     590:	781b      	ldrb	r3, [r3, #0]
     592:	73fb      	strb	r3, [r7, #15]
	tmp &= ~PORT_PMUX_PMUXO_Msk;
     594:	7bfb      	ldrb	r3, [r7, #15]
     596:	f003 030f 	and.w	r3, r3, #15
     59a:	73fb      	strb	r3, [r7, #15]
	tmp |= PORT_PMUX_PMUXO(data);
     59c:	787b      	ldrb	r3, [r7, #1]
     59e:	011b      	lsls	r3, r3, #4
     5a0:	b2da      	uxtb	r2, r3
     5a2:	7bfb      	ldrb	r3, [r7, #15]
     5a4:	4313      	orrs	r3, r2
     5a6:	73fb      	strb	r3, [r7, #15]
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     5a8:	78fa      	ldrb	r2, [r7, #3]
     5aa:	78bb      	ldrb	r3, [r7, #2]
     5ac:	6879      	ldr	r1, [r7, #4]
     5ae:	01d2      	lsls	r2, r2, #7
     5b0:	440a      	add	r2, r1
     5b2:	4413      	add	r3, r2
     5b4:	3330      	adds	r3, #48	; 0x30
     5b6:	7bfa      	ldrb	r2, [r7, #15]
     5b8:	701a      	strb	r2, [r3, #0]
	PORT_CRITICAL_SECTION_LEAVE();
}
     5ba:	bf00      	nop
     5bc:	3714      	adds	r7, #20
     5be:	46bd      	mov	sp, r7
     5c0:	f85d 7b04 	ldr.w	r7, [sp], #4
     5c4:	4770      	bx	lr

000005c6 <hri_port_write_PINCFG_PMUXEN_bit>:
	return (bool)tmp;
}

static inline void hri_port_write_PINCFG_PMUXEN_bit(const void *const hw, uint8_t submodule_index, uint8_t index,
                                                    bool value)
{
     5c6:	b480      	push	{r7}
     5c8:	b085      	sub	sp, #20
     5ca:	af00      	add	r7, sp, #0
     5cc:	6078      	str	r0, [r7, #4]
     5ce:	4608      	mov	r0, r1
     5d0:	4611      	mov	r1, r2
     5d2:	461a      	mov	r2, r3
     5d4:	4603      	mov	r3, r0
     5d6:	70fb      	strb	r3, [r7, #3]
     5d8:	460b      	mov	r3, r1
     5da:	70bb      	strb	r3, [r7, #2]
     5dc:	4613      	mov	r3, r2
     5de:	707b      	strb	r3, [r7, #1]
	uint8_t tmp;
	PORT_CRITICAL_SECTION_ENTER();
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     5e0:	78fa      	ldrb	r2, [r7, #3]
     5e2:	78bb      	ldrb	r3, [r7, #2]
     5e4:	6879      	ldr	r1, [r7, #4]
     5e6:	01d2      	lsls	r2, r2, #7
     5e8:	440a      	add	r2, r1
     5ea:	4413      	add	r3, r2
     5ec:	3340      	adds	r3, #64	; 0x40
     5ee:	781b      	ldrb	r3, [r3, #0]
     5f0:	73fb      	strb	r3, [r7, #15]
	tmp &= ~PORT_PINCFG_PMUXEN;
     5f2:	7bfb      	ldrb	r3, [r7, #15]
     5f4:	f023 0301 	bic.w	r3, r3, #1
     5f8:	73fb      	strb	r3, [r7, #15]
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     5fa:	787a      	ldrb	r2, [r7, #1]
     5fc:	7bfb      	ldrb	r3, [r7, #15]
     5fe:	4313      	orrs	r3, r2
     600:	73fb      	strb	r3, [r7, #15]
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     602:	78fa      	ldrb	r2, [r7, #3]
     604:	78bb      	ldrb	r3, [r7, #2]
     606:	6879      	ldr	r1, [r7, #4]
     608:	01d2      	lsls	r2, r2, #7
     60a:	440a      	add	r2, r1
     60c:	4413      	add	r3, r2
     60e:	3340      	adds	r3, #64	; 0x40
     610:	7bfa      	ldrb	r2, [r7, #15]
     612:	701a      	strb	r2, [r3, #0]
	PORT_CRITICAL_SECTION_LEAVE();
}
     614:	bf00      	nop
     616:	3714      	adds	r7, #20
     618:	46bd      	mov	sp, r7
     61a:	f85d 7b04 	ldr.w	r7, [sp], #4
     61e:	4770      	bx	lr

00000620 <hri_port_set_PINCFG_PULLEN_bit>:
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg ^= PORT_PINCFG_INEN;
	PORT_CRITICAL_SECTION_LEAVE();
}

static inline void hri_port_set_PINCFG_PULLEN_bit(const void *const hw, uint8_t submodule_index, uint8_t index)
{
     620:	b490      	push	{r4, r7}
     622:	b082      	sub	sp, #8
     624:	af00      	add	r7, sp, #0
     626:	6078      	str	r0, [r7, #4]
     628:	460b      	mov	r3, r1
     62a:	70fb      	strb	r3, [r7, #3]
     62c:	4613      	mov	r3, r2
     62e:	70bb      	strb	r3, [r7, #2]
	PORT_CRITICAL_SECTION_ENTER();
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg |= PORT_PINCFG_PULLEN;
     630:	78fa      	ldrb	r2, [r7, #3]
     632:	78bb      	ldrb	r3, [r7, #2]
     634:	78f8      	ldrb	r0, [r7, #3]
     636:	78b9      	ldrb	r1, [r7, #2]
     638:	687c      	ldr	r4, [r7, #4]
     63a:	01c0      	lsls	r0, r0, #7
     63c:	4420      	add	r0, r4
     63e:	4401      	add	r1, r0
     640:	3140      	adds	r1, #64	; 0x40
     642:	7809      	ldrb	r1, [r1, #0]
     644:	b2c9      	uxtb	r1, r1
     646:	f041 0104 	orr.w	r1, r1, #4
     64a:	b2c8      	uxtb	r0, r1
     64c:	6879      	ldr	r1, [r7, #4]
     64e:	01d2      	lsls	r2, r2, #7
     650:	440a      	add	r2, r1
     652:	4413      	add	r3, r2
     654:	3340      	adds	r3, #64	; 0x40
     656:	4602      	mov	r2, r0
     658:	701a      	strb	r2, [r3, #0]
	PORT_CRITICAL_SECTION_LEAVE();
}
     65a:	bf00      	nop
     65c:	3708      	adds	r7, #8
     65e:	46bd      	mov	sp, r7
     660:	bc90      	pop	{r4, r7}
     662:	4770      	bx	lr

00000664 <hri_port_clear_PINCFG_PULLEN_bit>:
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
	PORT_CRITICAL_SECTION_LEAVE();
}

static inline void hri_port_clear_PINCFG_PULLEN_bit(const void *const hw, uint8_t submodule_index, uint8_t index)
{
     664:	b490      	push	{r4, r7}
     666:	b082      	sub	sp, #8
     668:	af00      	add	r7, sp, #0
     66a:	6078      	str	r0, [r7, #4]
     66c:	460b      	mov	r3, r1
     66e:	70fb      	strb	r3, [r7, #3]
     670:	4613      	mov	r3, r2
     672:	70bb      	strb	r3, [r7, #2]
	PORT_CRITICAL_SECTION_ENTER();
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg &= ~PORT_PINCFG_PULLEN;
     674:	78fa      	ldrb	r2, [r7, #3]
     676:	78bb      	ldrb	r3, [r7, #2]
     678:	78f8      	ldrb	r0, [r7, #3]
     67a:	78b9      	ldrb	r1, [r7, #2]
     67c:	687c      	ldr	r4, [r7, #4]
     67e:	01c0      	lsls	r0, r0, #7
     680:	4420      	add	r0, r4
     682:	4401      	add	r1, r0
     684:	3140      	adds	r1, #64	; 0x40
     686:	7809      	ldrb	r1, [r1, #0]
     688:	b2c9      	uxtb	r1, r1
     68a:	f021 0104 	bic.w	r1, r1, #4
     68e:	b2c8      	uxtb	r0, r1
     690:	6879      	ldr	r1, [r7, #4]
     692:	01d2      	lsls	r2, r2, #7
     694:	440a      	add	r2, r1
     696:	4413      	add	r3, r2
     698:	3340      	adds	r3, #64	; 0x40
     69a:	4602      	mov	r2, r0
     69c:	701a      	strb	r2, [r3, #0]
	PORT_CRITICAL_SECTION_LEAVE();
}
     69e:	bf00      	nop
     6a0:	3708      	adds	r7, #8
     6a2:	46bd      	mov	sp, r7
     6a4:	bc90      	pop	{r4, r7}
     6a6:	4770      	bx	lr

000006a8 <hri_port_write_WRCONFIG_reg>:
	return ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
}

static inline void hri_port_write_WRCONFIG_reg(const void *const hw, uint8_t submodule_index,
                                               hri_port_wrconfig_reg_t data)
{
     6a8:	b480      	push	{r7}
     6aa:	b085      	sub	sp, #20
     6ac:	af00      	add	r7, sp, #0
     6ae:	60f8      	str	r0, [r7, #12]
     6b0:	460b      	mov	r3, r1
     6b2:	607a      	str	r2, [r7, #4]
     6b4:	72fb      	strb	r3, [r7, #11]
	PORT_CRITICAL_SECTION_ENTER();
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     6b6:	7afb      	ldrb	r3, [r7, #11]
     6b8:	68fa      	ldr	r2, [r7, #12]
     6ba:	01db      	lsls	r3, r3, #7
     6bc:	4413      	add	r3, r2
     6be:	3328      	adds	r3, #40	; 0x28
     6c0:	687a      	ldr	r2, [r7, #4]
     6c2:	601a      	str	r2, [r3, #0]
	PORT_CRITICAL_SECTION_LEAVE();
}
     6c4:	bf00      	nop
     6c6:	3714      	adds	r7, #20
     6c8:	46bd      	mov	sp, r7
     6ca:	f85d 7b04 	ldr.w	r7, [sp], #4
     6ce:	4770      	bx	lr

000006d0 <_gpio_set_direction>:
/**
 * \brief Set direction on port with mask
 */
static inline void _gpio_set_direction(const enum gpio_port port, const uint32_t mask,
                                       const enum gpio_direction direction)
{
     6d0:	b580      	push	{r7, lr}
     6d2:	b082      	sub	sp, #8
     6d4:	af00      	add	r7, sp, #0
     6d6:	4603      	mov	r3, r0
     6d8:	6039      	str	r1, [r7, #0]
     6da:	71fb      	strb	r3, [r7, #7]
     6dc:	4613      	mov	r3, r2
     6de:	71bb      	strb	r3, [r7, #6]
	switch (direction) {
     6e0:	79bb      	ldrb	r3, [r7, #6]
     6e2:	2b01      	cmp	r3, #1
     6e4:	d01c      	beq.n	720 <_gpio_set_direction+0x50>
     6e6:	2b02      	cmp	r3, #2
     6e8:	d037      	beq.n	75a <_gpio_set_direction+0x8a>
     6ea:	2b00      	cmp	r3, #0
     6ec:	d14e      	bne.n	78c <_gpio_set_direction+0xbc>
	case GPIO_DIRECTION_OFF:
		hri_port_clear_DIR_reg(PORT, port, mask);
     6ee:	79fb      	ldrb	r3, [r7, #7]
     6f0:	683a      	ldr	r2, [r7, #0]
     6f2:	4619      	mov	r1, r3
     6f4:	482a      	ldr	r0, [pc, #168]	; (7a0 <_gpio_set_direction+0xd0>)
     6f6:	4b2b      	ldr	r3, [pc, #172]	; (7a4 <_gpio_set_direction+0xd4>)
     6f8:	4798      	blx	r3
		hri_port_write_WRCONFIG_reg(PORT, port, PORT_WRCONFIG_WRPINCFG | (mask & 0xffff));
     6fa:	683b      	ldr	r3, [r7, #0]
     6fc:	b29b      	uxth	r3, r3
     6fe:	f043 4280 	orr.w	r2, r3, #1073741824	; 0x40000000
     702:	79fb      	ldrb	r3, [r7, #7]
     704:	4619      	mov	r1, r3
     706:	4826      	ldr	r0, [pc, #152]	; (7a0 <_gpio_set_direction+0xd0>)
     708:	4b27      	ldr	r3, [pc, #156]	; (7a8 <_gpio_set_direction+0xd8>)
     70a:	4798      	blx	r3
		hri_port_write_WRCONFIG_reg(
		    PORT, port, PORT_WRCONFIG_HWSEL | PORT_WRCONFIG_WRPINCFG | ((mask & 0xffff0000) >> 16));
     70c:	683b      	ldr	r3, [r7, #0]
     70e:	0c1b      	lsrs	r3, r3, #16
		hri_port_write_WRCONFIG_reg(
     710:	f043 4240 	orr.w	r2, r3, #3221225472	; 0xc0000000
     714:	79fb      	ldrb	r3, [r7, #7]
     716:	4619      	mov	r1, r3
     718:	4821      	ldr	r0, [pc, #132]	; (7a0 <_gpio_set_direction+0xd0>)
     71a:	4b23      	ldr	r3, [pc, #140]	; (7a8 <_gpio_set_direction+0xd8>)
     71c:	4798      	blx	r3
		break;
     71e:	e03a      	b.n	796 <_gpio_set_direction+0xc6>

	case GPIO_DIRECTION_IN:
		hri_port_clear_DIR_reg(PORT, port, mask);
     720:	79fb      	ldrb	r3, [r7, #7]
     722:	683a      	ldr	r2, [r7, #0]
     724:	4619      	mov	r1, r3
     726:	481e      	ldr	r0, [pc, #120]	; (7a0 <_gpio_set_direction+0xd0>)
     728:	4b1e      	ldr	r3, [pc, #120]	; (7a4 <_gpio_set_direction+0xd4>)
     72a:	4798      	blx	r3
		hri_port_write_WRCONFIG_reg(PORT, port, PORT_WRCONFIG_WRPINCFG | PORT_WRCONFIG_INEN | (mask & 0xffff));
     72c:	683b      	ldr	r3, [r7, #0]
     72e:	b29b      	uxth	r3, r3
     730:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
     734:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
     738:	79f9      	ldrb	r1, [r7, #7]
     73a:	461a      	mov	r2, r3
     73c:	4818      	ldr	r0, [pc, #96]	; (7a0 <_gpio_set_direction+0xd0>)
     73e:	4b1a      	ldr	r3, [pc, #104]	; (7a8 <_gpio_set_direction+0xd8>)
     740:	4798      	blx	r3
		hri_port_write_WRCONFIG_reg(PORT,
		                            port,
		                            PORT_WRCONFIG_HWSEL | PORT_WRCONFIG_WRPINCFG | PORT_WRCONFIG_INEN
		                                | ((mask & 0xffff0000) >> 16));
     742:	683b      	ldr	r3, [r7, #0]
     744:	0c1b      	lsrs	r3, r3, #16
		hri_port_write_WRCONFIG_reg(PORT,
     746:	f043 4340 	orr.w	r3, r3, #3221225472	; 0xc0000000
     74a:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
     74e:	79f9      	ldrb	r1, [r7, #7]
     750:	461a      	mov	r2, r3
     752:	4813      	ldr	r0, [pc, #76]	; (7a0 <_gpio_set_direction+0xd0>)
     754:	4b14      	ldr	r3, [pc, #80]	; (7a8 <_gpio_set_direction+0xd8>)
     756:	4798      	blx	r3
		break;
     758:	e01d      	b.n	796 <_gpio_set_direction+0xc6>

	case GPIO_DIRECTION_OUT:
		hri_port_set_DIR_reg(PORT, port, mask);
     75a:	79fb      	ldrb	r3, [r7, #7]
     75c:	683a      	ldr	r2, [r7, #0]
     75e:	4619      	mov	r1, r3
     760:	480f      	ldr	r0, [pc, #60]	; (7a0 <_gpio_set_direction+0xd0>)
     762:	4b12      	ldr	r3, [pc, #72]	; (7ac <_gpio_set_direction+0xdc>)
     764:	4798      	blx	r3
		hri_port_write_WRCONFIG_reg(PORT, port, PORT_WRCONFIG_WRPINCFG | (mask & 0xffff));
     766:	683b      	ldr	r3, [r7, #0]
     768:	b29b      	uxth	r3, r3
     76a:	f043 4280 	orr.w	r2, r3, #1073741824	; 0x40000000
     76e:	79fb      	ldrb	r3, [r7, #7]
     770:	4619      	mov	r1, r3
     772:	480b      	ldr	r0, [pc, #44]	; (7a0 <_gpio_set_direction+0xd0>)
     774:	4b0c      	ldr	r3, [pc, #48]	; (7a8 <_gpio_set_direction+0xd8>)
     776:	4798      	blx	r3
		hri_port_write_WRCONFIG_reg(
		    PORT, port, PORT_WRCONFIG_HWSEL | PORT_WRCONFIG_WRPINCFG | ((mask & 0xffff0000) >> 16));
     778:	683b      	ldr	r3, [r7, #0]
     77a:	0c1b      	lsrs	r3, r3, #16
		hri_port_write_WRCONFIG_reg(
     77c:	f043 4240 	orr.w	r2, r3, #3221225472	; 0xc0000000
     780:	79fb      	ldrb	r3, [r7, #7]
     782:	4619      	mov	r1, r3
     784:	4806      	ldr	r0, [pc, #24]	; (7a0 <_gpio_set_direction+0xd0>)
     786:	4b08      	ldr	r3, [pc, #32]	; (7a8 <_gpio_set_direction+0xd8>)
     788:	4798      	blx	r3
		break;
     78a:	e004      	b.n	796 <_gpio_set_direction+0xc6>

	default:
		ASSERT(false);
     78c:	2246      	movs	r2, #70	; 0x46
     78e:	4908      	ldr	r1, [pc, #32]	; (7b0 <_gpio_set_direction+0xe0>)
     790:	2000      	movs	r0, #0
     792:	4b08      	ldr	r3, [pc, #32]	; (7b4 <_gpio_set_direction+0xe4>)
     794:	4798      	blx	r3
	}
}
     796:	bf00      	nop
     798:	3708      	adds	r7, #8
     79a:	46bd      	mov	sp, r7
     79c:	bd80      	pop	{r7, pc}
     79e:	bf00      	nop
     7a0:	41008000 	.word	0x41008000
     7a4:	00000491 	.word	0x00000491
     7a8:	000006a9 	.word	0x000006a9
     7ac:	00000469 	.word	0x00000469
     7b0:	00005ae0 	.word	0x00005ae0
     7b4:	00001849 	.word	0x00001849

000007b8 <_gpio_set_level>:

/**
 * \brief Set output level on port with mask
 */
static inline void _gpio_set_level(const enum gpio_port port, const uint32_t mask, const bool level)
{
     7b8:	b580      	push	{r7, lr}
     7ba:	b082      	sub	sp, #8
     7bc:	af00      	add	r7, sp, #0
     7be:	4603      	mov	r3, r0
     7c0:	6039      	str	r1, [r7, #0]
     7c2:	71fb      	strb	r3, [r7, #7]
     7c4:	4613      	mov	r3, r2
     7c6:	71bb      	strb	r3, [r7, #6]
	if (level) {
     7c8:	79bb      	ldrb	r3, [r7, #6]
     7ca:	2b00      	cmp	r3, #0
     7cc:	d006      	beq.n	7dc <_gpio_set_level+0x24>
		hri_port_set_OUT_reg(PORT, port, mask);
     7ce:	79fb      	ldrb	r3, [r7, #7]
     7d0:	683a      	ldr	r2, [r7, #0]
     7d2:	4619      	mov	r1, r3
     7d4:	4806      	ldr	r0, [pc, #24]	; (7f0 <_gpio_set_level+0x38>)
     7d6:	4b07      	ldr	r3, [pc, #28]	; (7f4 <_gpio_set_level+0x3c>)
     7d8:	4798      	blx	r3
	} else {
		hri_port_clear_OUT_reg(PORT, port, mask);
	}
}
     7da:	e005      	b.n	7e8 <_gpio_set_level+0x30>
		hri_port_clear_OUT_reg(PORT, port, mask);
     7dc:	79fb      	ldrb	r3, [r7, #7]
     7de:	683a      	ldr	r2, [r7, #0]
     7e0:	4619      	mov	r1, r3
     7e2:	4803      	ldr	r0, [pc, #12]	; (7f0 <_gpio_set_level+0x38>)
     7e4:	4b04      	ldr	r3, [pc, #16]	; (7f8 <_gpio_set_level+0x40>)
     7e6:	4798      	blx	r3
}
     7e8:	bf00      	nop
     7ea:	3708      	adds	r7, #8
     7ec:	46bd      	mov	sp, r7
     7ee:	bd80      	pop	{r7, pc}
     7f0:	41008000 	.word	0x41008000
     7f4:	000004b9 	.word	0x000004b9
     7f8:	000004e1 	.word	0x000004e1

000007fc <_gpio_set_pin_pull_mode>:
/**
 * \brief Set pin pull mode
 */
static inline void _gpio_set_pin_pull_mode(const enum gpio_port port, const uint8_t pin,
                                           const enum gpio_pull_mode pull_mode)
{
     7fc:	b580      	push	{r7, lr}
     7fe:	b082      	sub	sp, #8
     800:	af00      	add	r7, sp, #0
     802:	4603      	mov	r3, r0
     804:	71fb      	strb	r3, [r7, #7]
     806:	460b      	mov	r3, r1
     808:	71bb      	strb	r3, [r7, #6]
     80a:	4613      	mov	r3, r2
     80c:	717b      	strb	r3, [r7, #5]
	switch (pull_mode) {
     80e:	797b      	ldrb	r3, [r7, #5]
     810:	2b01      	cmp	r3, #1
     812:	d00a      	beq.n	82a <_gpio_set_pin_pull_mode+0x2e>
     814:	2b02      	cmp	r3, #2
     816:	d01f      	beq.n	858 <_gpio_set_pin_pull_mode+0x5c>
     818:	2b00      	cmp	r3, #0
     81a:	d134      	bne.n	886 <_gpio_set_pin_pull_mode+0x8a>
	case GPIO_PULL_OFF:
		hri_port_clear_PINCFG_PULLEN_bit(PORT, port, pin);
     81c:	79ba      	ldrb	r2, [r7, #6]
     81e:	79fb      	ldrb	r3, [r7, #7]
     820:	4619      	mov	r1, r3
     822:	481e      	ldr	r0, [pc, #120]	; (89c <_gpio_set_pin_pull_mode+0xa0>)
     824:	4b1e      	ldr	r3, [pc, #120]	; (8a0 <_gpio_set_pin_pull_mode+0xa4>)
     826:	4798      	blx	r3
		break;
     828:	e033      	b.n	892 <_gpio_set_pin_pull_mode+0x96>

	case GPIO_PULL_UP:
		hri_port_clear_DIR_reg(PORT, port, 1U << pin);
     82a:	79bb      	ldrb	r3, [r7, #6]
     82c:	2201      	movs	r2, #1
     82e:	409a      	lsls	r2, r3
     830:	79fb      	ldrb	r3, [r7, #7]
     832:	4619      	mov	r1, r3
     834:	4819      	ldr	r0, [pc, #100]	; (89c <_gpio_set_pin_pull_mode+0xa0>)
     836:	4b1b      	ldr	r3, [pc, #108]	; (8a4 <_gpio_set_pin_pull_mode+0xa8>)
     838:	4798      	blx	r3
		hri_port_set_PINCFG_PULLEN_bit(PORT, port, pin);
     83a:	79ba      	ldrb	r2, [r7, #6]
     83c:	79fb      	ldrb	r3, [r7, #7]
     83e:	4619      	mov	r1, r3
     840:	4816      	ldr	r0, [pc, #88]	; (89c <_gpio_set_pin_pull_mode+0xa0>)
     842:	4b19      	ldr	r3, [pc, #100]	; (8a8 <_gpio_set_pin_pull_mode+0xac>)
     844:	4798      	blx	r3
		hri_port_set_OUT_reg(PORT, port, 1U << pin);
     846:	79bb      	ldrb	r3, [r7, #6]
     848:	2201      	movs	r2, #1
     84a:	409a      	lsls	r2, r3
     84c:	79fb      	ldrb	r3, [r7, #7]
     84e:	4619      	mov	r1, r3
     850:	4812      	ldr	r0, [pc, #72]	; (89c <_gpio_set_pin_pull_mode+0xa0>)
     852:	4b16      	ldr	r3, [pc, #88]	; (8ac <_gpio_set_pin_pull_mode+0xb0>)
     854:	4798      	blx	r3
		break;
     856:	e01c      	b.n	892 <_gpio_set_pin_pull_mode+0x96>

	case GPIO_PULL_DOWN:
		hri_port_clear_DIR_reg(PORT, port, 1U << pin);
     858:	79bb      	ldrb	r3, [r7, #6]
     85a:	2201      	movs	r2, #1
     85c:	409a      	lsls	r2, r3
     85e:	79fb      	ldrb	r3, [r7, #7]
     860:	4619      	mov	r1, r3
     862:	480e      	ldr	r0, [pc, #56]	; (89c <_gpio_set_pin_pull_mode+0xa0>)
     864:	4b0f      	ldr	r3, [pc, #60]	; (8a4 <_gpio_set_pin_pull_mode+0xa8>)
     866:	4798      	blx	r3
		hri_port_set_PINCFG_PULLEN_bit(PORT, port, pin);
     868:	79ba      	ldrb	r2, [r7, #6]
     86a:	79fb      	ldrb	r3, [r7, #7]
     86c:	4619      	mov	r1, r3
     86e:	480b      	ldr	r0, [pc, #44]	; (89c <_gpio_set_pin_pull_mode+0xa0>)
     870:	4b0d      	ldr	r3, [pc, #52]	; (8a8 <_gpio_set_pin_pull_mode+0xac>)
     872:	4798      	blx	r3
		hri_port_clear_OUT_reg(PORT, port, 1U << pin);
     874:	79bb      	ldrb	r3, [r7, #6]
     876:	2201      	movs	r2, #1
     878:	409a      	lsls	r2, r3
     87a:	79fb      	ldrb	r3, [r7, #7]
     87c:	4619      	mov	r1, r3
     87e:	4807      	ldr	r0, [pc, #28]	; (89c <_gpio_set_pin_pull_mode+0xa0>)
     880:	4b0b      	ldr	r3, [pc, #44]	; (8b0 <_gpio_set_pin_pull_mode+0xb4>)
     882:	4798      	blx	r3
		break;
     884:	e005      	b.n	892 <_gpio_set_pin_pull_mode+0x96>

	default:
		ASSERT(false);
     886:	2289      	movs	r2, #137	; 0x89
     888:	490a      	ldr	r1, [pc, #40]	; (8b4 <_gpio_set_pin_pull_mode+0xb8>)
     88a:	2000      	movs	r0, #0
     88c:	4b0a      	ldr	r3, [pc, #40]	; (8b8 <_gpio_set_pin_pull_mode+0xbc>)
     88e:	4798      	blx	r3
		break;
     890:	bf00      	nop
	}
}
     892:	bf00      	nop
     894:	3708      	adds	r7, #8
     896:	46bd      	mov	sp, r7
     898:	bd80      	pop	{r7, pc}
     89a:	bf00      	nop
     89c:	41008000 	.word	0x41008000
     8a0:	00000665 	.word	0x00000665
     8a4:	00000491 	.word	0x00000491
     8a8:	00000621 	.word	0x00000621
     8ac:	000004b9 	.word	0x000004b9
     8b0:	000004e1 	.word	0x000004e1
     8b4:	00005ae0 	.word	0x00005ae0
     8b8:	00001849 	.word	0x00001849

000008bc <_gpio_set_pin_function>:

/**
 * \brief Set gpio pin function
 */
static inline void _gpio_set_pin_function(const uint32_t gpio, const uint32_t function)
{
     8bc:	b590      	push	{r4, r7, lr}
     8be:	b085      	sub	sp, #20
     8c0:	af00      	add	r7, sp, #0
     8c2:	6078      	str	r0, [r7, #4]
     8c4:	6039      	str	r1, [r7, #0]
	uint8_t port = GPIO_PORT(gpio);
     8c6:	687b      	ldr	r3, [r7, #4]
     8c8:	095b      	lsrs	r3, r3, #5
     8ca:	73fb      	strb	r3, [r7, #15]
	uint8_t pin  = GPIO_PIN(gpio);
     8cc:	687b      	ldr	r3, [r7, #4]
     8ce:	b2db      	uxtb	r3, r3
     8d0:	f003 031f 	and.w	r3, r3, #31
     8d4:	73bb      	strb	r3, [r7, #14]

	if (function == GPIO_PIN_FUNCTION_OFF) {
     8d6:	683b      	ldr	r3, [r7, #0]
     8d8:	f1b3 3fff 	cmp.w	r3, #4294967295
     8dc:	d106      	bne.n	8ec <_gpio_set_pin_function+0x30>
		hri_port_write_PINCFG_PMUXEN_bit(PORT, port, pin, false);
     8de:	7bba      	ldrb	r2, [r7, #14]
     8e0:	7bf9      	ldrb	r1, [r7, #15]
     8e2:	2300      	movs	r3, #0
     8e4:	4812      	ldr	r0, [pc, #72]	; (930 <_gpio_set_pin_function+0x74>)
     8e6:	4c13      	ldr	r4, [pc, #76]	; (934 <_gpio_set_pin_function+0x78>)
     8e8:	47a0      	blx	r4
		} else {
			// Even numbered pin
			hri_port_write_PMUX_PMUXE_bf(PORT, port, pin >> 1, function & 0xffff);
		}
	}
}
     8ea:	e01d      	b.n	928 <_gpio_set_pin_function+0x6c>
		hri_port_write_PINCFG_PMUXEN_bit(PORT, port, pin, true);
     8ec:	7bba      	ldrb	r2, [r7, #14]
     8ee:	7bf9      	ldrb	r1, [r7, #15]
     8f0:	2301      	movs	r3, #1
     8f2:	480f      	ldr	r0, [pc, #60]	; (930 <_gpio_set_pin_function+0x74>)
     8f4:	4c0f      	ldr	r4, [pc, #60]	; (934 <_gpio_set_pin_function+0x78>)
     8f6:	47a0      	blx	r4
		if (pin & 1) {
     8f8:	7bbb      	ldrb	r3, [r7, #14]
     8fa:	f003 0301 	and.w	r3, r3, #1
     8fe:	2b00      	cmp	r3, #0
     900:	d009      	beq.n	916 <_gpio_set_pin_function+0x5a>
			hri_port_write_PMUX_PMUXO_bf(PORT, port, pin >> 1, function & 0xffff);
     902:	7bbb      	ldrb	r3, [r7, #14]
     904:	085b      	lsrs	r3, r3, #1
     906:	b2da      	uxtb	r2, r3
     908:	683b      	ldr	r3, [r7, #0]
     90a:	b2db      	uxtb	r3, r3
     90c:	7bf9      	ldrb	r1, [r7, #15]
     90e:	4808      	ldr	r0, [pc, #32]	; (930 <_gpio_set_pin_function+0x74>)
     910:	4c09      	ldr	r4, [pc, #36]	; (938 <_gpio_set_pin_function+0x7c>)
     912:	47a0      	blx	r4
}
     914:	e008      	b.n	928 <_gpio_set_pin_function+0x6c>
			hri_port_write_PMUX_PMUXE_bf(PORT, port, pin >> 1, function & 0xffff);
     916:	7bbb      	ldrb	r3, [r7, #14]
     918:	085b      	lsrs	r3, r3, #1
     91a:	b2da      	uxtb	r2, r3
     91c:	683b      	ldr	r3, [r7, #0]
     91e:	b2db      	uxtb	r3, r3
     920:	7bf9      	ldrb	r1, [r7, #15]
     922:	4803      	ldr	r0, [pc, #12]	; (930 <_gpio_set_pin_function+0x74>)
     924:	4c05      	ldr	r4, [pc, #20]	; (93c <_gpio_set_pin_function+0x80>)
     926:	47a0      	blx	r4
}
     928:	bf00      	nop
     92a:	3714      	adds	r7, #20
     92c:	46bd      	mov	sp, r7
     92e:	bd90      	pop	{r4, r7, pc}
     930:	41008000 	.word	0x41008000
     934:	000005c7 	.word	0x000005c7
     938:	00000569 	.word	0x00000569
     93c:	00000509 	.word	0x00000509

00000940 <gpio_set_pin_pull_mode>:
 * \param[in] pull_mode GPIO_PULL_DOWN = Pull pin low with internal resistor
 *                      GPIO_PULL_UP   = Pull pin high with internal resistor
 *                      GPIO_PULL_OFF  = Disable pin pull mode
 */
static inline void gpio_set_pin_pull_mode(const uint8_t pin, const enum gpio_pull_mode pull_mode)
{
     940:	b580      	push	{r7, lr}
     942:	b082      	sub	sp, #8
     944:	af00      	add	r7, sp, #0
     946:	4603      	mov	r3, r0
     948:	460a      	mov	r2, r1
     94a:	71fb      	strb	r3, [r7, #7]
     94c:	4613      	mov	r3, r2
     94e:	71bb      	strb	r3, [r7, #6]
	_gpio_set_pin_pull_mode((enum gpio_port)GPIO_PORT(pin), pin & 0x1F, pull_mode);
     950:	79fb      	ldrb	r3, [r7, #7]
     952:	095b      	lsrs	r3, r3, #5
     954:	b2d8      	uxtb	r0, r3
     956:	79fb      	ldrb	r3, [r7, #7]
     958:	f003 031f 	and.w	r3, r3, #31
     95c:	b2db      	uxtb	r3, r3
     95e:	79ba      	ldrb	r2, [r7, #6]
     960:	4619      	mov	r1, r3
     962:	4b03      	ldr	r3, [pc, #12]	; (970 <gpio_set_pin_pull_mode+0x30>)
     964:	4798      	blx	r3
}
     966:	bf00      	nop
     968:	3708      	adds	r7, #8
     96a:	46bd      	mov	sp, r7
     96c:	bd80      	pop	{r7, pc}
     96e:	bf00      	nop
     970:	000007fd 	.word	0x000007fd

00000974 <gpio_set_pin_function>:
 * \param[in] function  The pin function is given by a 32-bit wide bitfield
 *                      found in the header files for the device
 *
 */
static inline void gpio_set_pin_function(const uint32_t pin, uint32_t function)
{
     974:	b580      	push	{r7, lr}
     976:	b082      	sub	sp, #8
     978:	af00      	add	r7, sp, #0
     97a:	6078      	str	r0, [r7, #4]
     97c:	6039      	str	r1, [r7, #0]
	_gpio_set_pin_function(pin, function);
     97e:	6839      	ldr	r1, [r7, #0]
     980:	6878      	ldr	r0, [r7, #4]
     982:	4b03      	ldr	r3, [pc, #12]	; (990 <gpio_set_pin_function+0x1c>)
     984:	4798      	blx	r3
}
     986:	bf00      	nop
     988:	3708      	adds	r7, #8
     98a:	46bd      	mov	sp, r7
     98c:	bd80      	pop	{r7, pc}
     98e:	bf00      	nop
     990:	000008bd 	.word	0x000008bd

00000994 <gpio_set_pin_direction>:
 *                      GPIO_DIRECTION_OUT = Data direction out
 *                      GPIO_DIRECTION_OFF = Disables the pin
 *                      (low power state)
 */
static inline void gpio_set_pin_direction(const uint8_t pin, const enum gpio_direction direction)
{
     994:	b580      	push	{r7, lr}
     996:	b082      	sub	sp, #8
     998:	af00      	add	r7, sp, #0
     99a:	4603      	mov	r3, r0
     99c:	460a      	mov	r2, r1
     99e:	71fb      	strb	r3, [r7, #7]
     9a0:	4613      	mov	r3, r2
     9a2:	71bb      	strb	r3, [r7, #6]
	_gpio_set_direction((enum gpio_port)GPIO_PORT(pin), 1U << GPIO_PIN(pin), direction);
     9a4:	79fb      	ldrb	r3, [r7, #7]
     9a6:	095b      	lsrs	r3, r3, #5
     9a8:	b2d8      	uxtb	r0, r3
     9aa:	79fb      	ldrb	r3, [r7, #7]
     9ac:	f003 031f 	and.w	r3, r3, #31
     9b0:	2201      	movs	r2, #1
     9b2:	fa02 f303 	lsl.w	r3, r2, r3
     9b6:	79ba      	ldrb	r2, [r7, #6]
     9b8:	4619      	mov	r1, r3
     9ba:	4b03      	ldr	r3, [pc, #12]	; (9c8 <gpio_set_pin_direction+0x34>)
     9bc:	4798      	blx	r3
}
     9be:	bf00      	nop
     9c0:	3708      	adds	r7, #8
     9c2:	46bd      	mov	sp, r7
     9c4:	bd80      	pop	{r7, pc}
     9c6:	bf00      	nop
     9c8:	000006d1 	.word	0x000006d1

000009cc <gpio_set_pin_level>:
 * \param[in] pin       The pin number for device
 * \param[in] level true  = Pin level set to "high" state
 *                  false = Pin level set to "low" state
 */
static inline void gpio_set_pin_level(const uint8_t pin, const bool level)
{
     9cc:	b580      	push	{r7, lr}
     9ce:	b082      	sub	sp, #8
     9d0:	af00      	add	r7, sp, #0
     9d2:	4603      	mov	r3, r0
     9d4:	460a      	mov	r2, r1
     9d6:	71fb      	strb	r3, [r7, #7]
     9d8:	4613      	mov	r3, r2
     9da:	71bb      	strb	r3, [r7, #6]
	_gpio_set_level((enum gpio_port)GPIO_PORT(pin), 1U << GPIO_PIN(pin), level);
     9dc:	79fb      	ldrb	r3, [r7, #7]
     9de:	095b      	lsrs	r3, r3, #5
     9e0:	b2d8      	uxtb	r0, r3
     9e2:	79fb      	ldrb	r3, [r7, #7]
     9e4:	f003 031f 	and.w	r3, r3, #31
     9e8:	2201      	movs	r2, #1
     9ea:	fa02 f303 	lsl.w	r3, r2, r3
     9ee:	79ba      	ldrb	r2, [r7, #6]
     9f0:	4619      	mov	r1, r3
     9f2:	4b03      	ldr	r3, [pc, #12]	; (a00 <gpio_set_pin_level+0x34>)
     9f4:	4798      	blx	r3
}
     9f6:	bf00      	nop
     9f8:	3708      	adds	r7, #8
     9fa:	46bd      	mov	sp, r7
     9fc:	bd80      	pop	{r7, pc}
     9fe:	bf00      	nop
     a00:	000007b9 	.word	0x000007b9

00000a04 <init_mcu>:
 * This function calls the various initialization functions.
 * Currently the following initialization functions are supported:
 *  - System clock initialization
 */
static inline void init_mcu(void)
{
     a04:	b580      	push	{r7, lr}
     a06:	af00      	add	r7, sp, #0
	_init_chip();
     a08:	4b01      	ldr	r3, [pc, #4]	; (a10 <init_mcu+0xc>)
     a0a:	4798      	blx	r3
}
     a0c:	bf00      	nop
     a0e:	bd80      	pop	{r7, pc}
     a10:	00001ccd 	.word	0x00001ccd

00000a14 <EXTERNAL_IRQ_0_init>:
struct i2c_m_sync_desc PCC_SCCB;

struct pwm_descriptor PWM_0;

void EXTERNAL_IRQ_0_init(void)
{
     a14:	b580      	push	{r7, lr}
     a16:	af00      	add	r7, sp, #0
	hri_gclk_write_PCHCTRL_reg(GCLK, EIC_GCLK_ID, CONF_GCLK_EIC_SRC | (1 << GCLK_PCHCTRL_CHEN_Pos));
     a18:	2240      	movs	r2, #64	; 0x40
     a1a:	2104      	movs	r1, #4
     a1c:	4811      	ldr	r0, [pc, #68]	; (a64 <EXTERNAL_IRQ_0_init+0x50>)
     a1e:	4b12      	ldr	r3, [pc, #72]	; (a68 <EXTERNAL_IRQ_0_init+0x54>)
     a20:	4798      	blx	r3
	hri_mclk_set_APBAMASK_EIC_bit(MCLK);
     a22:	4812      	ldr	r0, [pc, #72]	; (a6c <EXTERNAL_IRQ_0_init+0x58>)
     a24:	4b12      	ldr	r3, [pc, #72]	; (a70 <EXTERNAL_IRQ_0_init+0x5c>)
     a26:	4798      	blx	r3

	// Set pin direction to input
	gpio_set_pin_direction(PCC_VSYNC, GPIO_DIRECTION_IN);
     a28:	2101      	movs	r1, #1
     a2a:	200c      	movs	r0, #12
     a2c:	4b11      	ldr	r3, [pc, #68]	; (a74 <EXTERNAL_IRQ_0_init+0x60>)
     a2e:	4798      	blx	r3

	gpio_set_pin_pull_mode(PCC_VSYNC,
     a30:	2101      	movs	r1, #1
     a32:	200c      	movs	r0, #12
     a34:	4b10      	ldr	r3, [pc, #64]	; (a78 <EXTERNAL_IRQ_0_init+0x64>)
     a36:	4798      	blx	r3
	                       // <GPIO_PULL_OFF"> Off
	                       // <GPIO_PULL_UP"> Pull-up
	                       // <GPIO_PULL_DOWN"> Pull-down
	                       GPIO_PULL_UP);

	gpio_set_pin_function(PCC_VSYNC, PINMUX_PA12A_EIC_EXTINT12);
     a38:	f44f 2140 	mov.w	r1, #786432	; 0xc0000
     a3c:	200c      	movs	r0, #12
     a3e:	4b0f      	ldr	r3, [pc, #60]	; (a7c <EXTERNAL_IRQ_0_init+0x68>)
     a40:	4798      	blx	r3

	// Set pin direction to input
	gpio_set_pin_direction(PCC_HSYNC, GPIO_DIRECTION_IN);
     a42:	2101      	movs	r1, #1
     a44:	200d      	movs	r0, #13
     a46:	4b0b      	ldr	r3, [pc, #44]	; (a74 <EXTERNAL_IRQ_0_init+0x60>)
     a48:	4798      	blx	r3

	gpio_set_pin_pull_mode(PCC_HSYNC,
     a4a:	2100      	movs	r1, #0
     a4c:	200d      	movs	r0, #13
     a4e:	4b0a      	ldr	r3, [pc, #40]	; (a78 <EXTERNAL_IRQ_0_init+0x64>)
     a50:	4798      	blx	r3
	                       // <GPIO_PULL_OFF"> Off
	                       // <GPIO_PULL_UP"> Pull-up
	                       // <GPIO_PULL_DOWN"> Pull-down
	                       GPIO_PULL_OFF);

	gpio_set_pin_function(PCC_HSYNC, PINMUX_PA13A_EIC_EXTINT13);
     a52:	f44f 2150 	mov.w	r1, #851968	; 0xd0000
     a56:	200d      	movs	r0, #13
     a58:	4b08      	ldr	r3, [pc, #32]	; (a7c <EXTERNAL_IRQ_0_init+0x68>)
     a5a:	4798      	blx	r3

	ext_irq_init();
     a5c:	4b08      	ldr	r3, [pc, #32]	; (a80 <EXTERNAL_IRQ_0_init+0x6c>)
     a5e:	4798      	blx	r3
}
     a60:	bf00      	nop
     a62:	bd80      	pop	{r7, pc}
     a64:	40001c00 	.word	0x40001c00
     a68:	00000383 	.word	0x00000383
     a6c:	40000800 	.word	0x40000800
     a70:	000003a9 	.word	0x000003a9
     a74:	00000995 	.word	0x00000995
     a78:	00000941 	.word	0x00000941
     a7c:	00000975 	.word	0x00000975
     a80:	00000f5d 	.word	0x00000f5d

00000a84 <EVENT_SYSTEM_0_init>:

void EVENT_SYSTEM_0_init(void)
{
     a84:	b580      	push	{r7, lr}
     a86:	af00      	add	r7, sp, #0
	hri_gclk_write_PCHCTRL_reg(GCLK, EVSYS_GCLK_ID_1, CONF_GCLK_EVSYS_CHANNEL_1_SRC | (1 << GCLK_PCHCTRL_CHEN_Pos));
     a88:	2240      	movs	r2, #64	; 0x40
     a8a:	210c      	movs	r1, #12
     a8c:	4804      	ldr	r0, [pc, #16]	; (aa0 <EVENT_SYSTEM_0_init+0x1c>)
     a8e:	4b05      	ldr	r3, [pc, #20]	; (aa4 <EVENT_SYSTEM_0_init+0x20>)
     a90:	4798      	blx	r3

	hri_mclk_set_APBBMASK_EVSYS_bit(MCLK);
     a92:	4805      	ldr	r0, [pc, #20]	; (aa8 <EVENT_SYSTEM_0_init+0x24>)
     a94:	4b05      	ldr	r3, [pc, #20]	; (aac <EVENT_SYSTEM_0_init+0x28>)
     a96:	4798      	blx	r3

	event_system_init();
     a98:	4b05      	ldr	r3, [pc, #20]	; (ab0 <EVENT_SYSTEM_0_init+0x2c>)
     a9a:	4798      	blx	r3
}
     a9c:	bf00      	nop
     a9e:	bd80      	pop	{r7, pc}
     aa0:	40001c00 	.word	0x40001c00
     aa4:	00000383 	.word	0x00000383
     aa8:	40000800 	.word	0x40000800
     aac:	000003e9 	.word	0x000003e9
     ab0:	00000f49 	.word	0x00000f49

00000ab4 <CAMERA_OV7670_PORT_init>:

void CAMERA_OV7670_PORT_init(void)
{
     ab4:	b580      	push	{r7, lr}
     ab6:	af00      	add	r7, sp, #0

	gpio_set_pin_function(PCC_PCLK, PINMUX_PA14K_PCC_CLK);
     ab8:	4912      	ldr	r1, [pc, #72]	; (b04 <CAMERA_OV7670_PORT_init+0x50>)
     aba:	200e      	movs	r0, #14
     abc:	4b12      	ldr	r3, [pc, #72]	; (b08 <CAMERA_OV7670_PORT_init+0x54>)
     abe:	4798      	blx	r3

	gpio_set_pin_function(PCC_DATA0, PINMUX_PA16K_PCC_DATA0);
     ac0:	4912      	ldr	r1, [pc, #72]	; (b0c <CAMERA_OV7670_PORT_init+0x58>)
     ac2:	2010      	movs	r0, #16
     ac4:	4b10      	ldr	r3, [pc, #64]	; (b08 <CAMERA_OV7670_PORT_init+0x54>)
     ac6:	4798      	blx	r3

	gpio_set_pin_function(PCC_DATA1, PINMUX_PA17K_PCC_DATA1);
     ac8:	4911      	ldr	r1, [pc, #68]	; (b10 <CAMERA_OV7670_PORT_init+0x5c>)
     aca:	2011      	movs	r0, #17
     acc:	4b0e      	ldr	r3, [pc, #56]	; (b08 <CAMERA_OV7670_PORT_init+0x54>)
     ace:	4798      	blx	r3

	gpio_set_pin_function(PCC_DATA2, PINMUX_PA18K_PCC_DATA2);
     ad0:	4910      	ldr	r1, [pc, #64]	; (b14 <CAMERA_OV7670_PORT_init+0x60>)
     ad2:	2012      	movs	r0, #18
     ad4:	4b0c      	ldr	r3, [pc, #48]	; (b08 <CAMERA_OV7670_PORT_init+0x54>)
     ad6:	4798      	blx	r3

	gpio_set_pin_function(PCC_DATA3, PINMUX_PA19K_PCC_DATA3);
     ad8:	490f      	ldr	r1, [pc, #60]	; (b18 <CAMERA_OV7670_PORT_init+0x64>)
     ada:	2013      	movs	r0, #19
     adc:	4b0a      	ldr	r3, [pc, #40]	; (b08 <CAMERA_OV7670_PORT_init+0x54>)
     ade:	4798      	blx	r3

	gpio_set_pin_function(PCC_DATA4, PINMUX_PA20K_PCC_DATA4);
     ae0:	490e      	ldr	r1, [pc, #56]	; (b1c <CAMERA_OV7670_PORT_init+0x68>)
     ae2:	2014      	movs	r0, #20
     ae4:	4b08      	ldr	r3, [pc, #32]	; (b08 <CAMERA_OV7670_PORT_init+0x54>)
     ae6:	4798      	blx	r3

	gpio_set_pin_function(PCC_DATA5, PINMUX_PA21K_PCC_DATA5);
     ae8:	490d      	ldr	r1, [pc, #52]	; (b20 <CAMERA_OV7670_PORT_init+0x6c>)
     aea:	2015      	movs	r0, #21
     aec:	4b06      	ldr	r3, [pc, #24]	; (b08 <CAMERA_OV7670_PORT_init+0x54>)
     aee:	4798      	blx	r3

	gpio_set_pin_function(PCC_DATA6, PINMUX_PA22K_PCC_DATA6);
     af0:	490c      	ldr	r1, [pc, #48]	; (b24 <CAMERA_OV7670_PORT_init+0x70>)
     af2:	2016      	movs	r0, #22
     af4:	4b04      	ldr	r3, [pc, #16]	; (b08 <CAMERA_OV7670_PORT_init+0x54>)
     af6:	4798      	blx	r3

	gpio_set_pin_function(PCC_DATA7, PINMUX_PA23K_PCC_DATA7);
     af8:	490b      	ldr	r1, [pc, #44]	; (b28 <CAMERA_OV7670_PORT_init+0x74>)
     afa:	2017      	movs	r0, #23
     afc:	4b02      	ldr	r3, [pc, #8]	; (b08 <CAMERA_OV7670_PORT_init+0x54>)
     afe:	4798      	blx	r3
}
     b00:	bf00      	nop
     b02:	bd80      	pop	{r7, pc}
     b04:	000e000a 	.word	0x000e000a
     b08:	00000975 	.word	0x00000975
     b0c:	0010000a 	.word	0x0010000a
     b10:	0011000a 	.word	0x0011000a
     b14:	0012000a 	.word	0x0012000a
     b18:	0013000a 	.word	0x0013000a
     b1c:	0014000a 	.word	0x0014000a
     b20:	0015000a 	.word	0x0015000a
     b24:	0016000a 	.word	0x0016000a
     b28:	0017000a 	.word	0x0017000a

00000b2c <CAMERA_OV7670_CLOCK_init>:

void CAMERA_OV7670_CLOCK_init(void)
{
     b2c:	b580      	push	{r7, lr}
     b2e:	af00      	add	r7, sp, #0
	hri_mclk_set_APBDMASK_PCC_bit(MCLK);
     b30:	4802      	ldr	r0, [pc, #8]	; (b3c <CAMERA_OV7670_CLOCK_init+0x10>)
     b32:	4b03      	ldr	r3, [pc, #12]	; (b40 <CAMERA_OV7670_CLOCK_init+0x14>)
     b34:	4798      	blx	r3
}
     b36:	bf00      	nop
     b38:	bd80      	pop	{r7, pc}
     b3a:	bf00      	nop
     b3c:	40000800 	.word	0x40000800
     b40:	00000449 	.word	0x00000449

00000b44 <CAMERA_OV7670_init>:

void CAMERA_OV7670_init(void)
{
     b44:	b580      	push	{r7, lr}
     b46:	af00      	add	r7, sp, #0
	CAMERA_OV7670_CLOCK_init();
     b48:	4b04      	ldr	r3, [pc, #16]	; (b5c <CAMERA_OV7670_init+0x18>)
     b4a:	4798      	blx	r3
	camera_async_init(&CAMERA_OV7670, PCC);
     b4c:	4904      	ldr	r1, [pc, #16]	; (b60 <CAMERA_OV7670_init+0x1c>)
     b4e:	4805      	ldr	r0, [pc, #20]	; (b64 <CAMERA_OV7670_init+0x20>)
     b50:	4b05      	ldr	r3, [pc, #20]	; (b68 <CAMERA_OV7670_init+0x24>)
     b52:	4798      	blx	r3
	CAMERA_OV7670_PORT_init();
     b54:	4b05      	ldr	r3, [pc, #20]	; (b6c <CAMERA_OV7670_init+0x28>)
     b56:	4798      	blx	r3
}
     b58:	bf00      	nop
     b5a:	bd80      	pop	{r7, pc}
     b5c:	00000b2d 	.word	0x00000b2d
     b60:	43002c00 	.word	0x43002c00
     b64:	20026330 	.word	0x20026330
     b68:	00000e61 	.word	0x00000e61
     b6c:	00000ab5 	.word	0x00000ab5

00000b70 <EDBG_COM_CLOCK_init>:
 * \brief USART Clock initialization function
 *
 * Enables register interface and peripheral clock
 */
void EDBG_COM_CLOCK_init()
{
     b70:	b580      	push	{r7, lr}
     b72:	af00      	add	r7, sp, #0

	hri_gclk_write_PCHCTRL_reg(GCLK, SERCOM1_GCLK_ID_CORE, CONF_GCLK_SERCOM1_CORE_SRC | (1 << GCLK_PCHCTRL_CHEN_Pos));
     b74:	2240      	movs	r2, #64	; 0x40
     b76:	2108      	movs	r1, #8
     b78:	4806      	ldr	r0, [pc, #24]	; (b94 <EDBG_COM_CLOCK_init+0x24>)
     b7a:	4b07      	ldr	r3, [pc, #28]	; (b98 <EDBG_COM_CLOCK_init+0x28>)
     b7c:	4798      	blx	r3
	hri_gclk_write_PCHCTRL_reg(GCLK, SERCOM1_GCLK_ID_SLOW, CONF_GCLK_SERCOM1_SLOW_SRC | (1 << GCLK_PCHCTRL_CHEN_Pos));
     b7e:	2242      	movs	r2, #66	; 0x42
     b80:	2103      	movs	r1, #3
     b82:	4804      	ldr	r0, [pc, #16]	; (b94 <EDBG_COM_CLOCK_init+0x24>)
     b84:	4b04      	ldr	r3, [pc, #16]	; (b98 <EDBG_COM_CLOCK_init+0x28>)
     b86:	4798      	blx	r3

	hri_mclk_set_APBAMASK_SERCOM1_bit(MCLK);
     b88:	4804      	ldr	r0, [pc, #16]	; (b9c <EDBG_COM_CLOCK_init+0x2c>)
     b8a:	4b05      	ldr	r3, [pc, #20]	; (ba0 <EDBG_COM_CLOCK_init+0x30>)
     b8c:	4798      	blx	r3
}
     b8e:	bf00      	nop
     b90:	bd80      	pop	{r7, pc}
     b92:	bf00      	nop
     b94:	40001c00 	.word	0x40001c00
     b98:	00000383 	.word	0x00000383
     b9c:	40000800 	.word	0x40000800
     ba0:	000003c9 	.word	0x000003c9

00000ba4 <EDBG_COM_PORT_init>:
 * \brief USART pinmux initialization function
 *
 * Set each required pin to USART functionality
 */
void EDBG_COM_PORT_init()
{
     ba4:	b580      	push	{r7, lr}
     ba6:	af00      	add	r7, sp, #0

	gpio_set_pin_function(PC27, PINMUX_PC27C_SERCOM1_PAD0);
     ba8:	4904      	ldr	r1, [pc, #16]	; (bbc <EDBG_COM_PORT_init+0x18>)
     baa:	205b      	movs	r0, #91	; 0x5b
     bac:	4b04      	ldr	r3, [pc, #16]	; (bc0 <EDBG_COM_PORT_init+0x1c>)
     bae:	4798      	blx	r3

	gpio_set_pin_function(PC28, PINMUX_PC28C_SERCOM1_PAD1);
     bb0:	4904      	ldr	r1, [pc, #16]	; (bc4 <EDBG_COM_PORT_init+0x20>)
     bb2:	205c      	movs	r0, #92	; 0x5c
     bb4:	4b02      	ldr	r3, [pc, #8]	; (bc0 <EDBG_COM_PORT_init+0x1c>)
     bb6:	4798      	blx	r3
}
     bb8:	bf00      	nop
     bba:	bd80      	pop	{r7, pc}
     bbc:	005b0002 	.word	0x005b0002
     bc0:	00000975 	.word	0x00000975
     bc4:	005c0002 	.word	0x005c0002

00000bc8 <EDBG_COM_init>:
 * \brief USART initialization function
 *
 * Enables USART peripheral, clocks and initializes USART driver
 */
void EDBG_COM_init(void)
{
     bc8:	b590      	push	{r4, r7, lr}
     bca:	b083      	sub	sp, #12
     bcc:	af02      	add	r7, sp, #8
	EDBG_COM_CLOCK_init();
     bce:	4b08      	ldr	r3, [pc, #32]	; (bf0 <EDBG_COM_init+0x28>)
     bd0:	4798      	blx	r3
	usart_async_init(&EDBG_COM, SERCOM1, EDBG_COM_buffer, EDBG_COM_BUFFER_SIZE, (void *)NULL);
     bd2:	2300      	movs	r3, #0
     bd4:	9300      	str	r3, [sp, #0]
     bd6:	2310      	movs	r3, #16
     bd8:	4a06      	ldr	r2, [pc, #24]	; (bf4 <EDBG_COM_init+0x2c>)
     bda:	4907      	ldr	r1, [pc, #28]	; (bf8 <EDBG_COM_init+0x30>)
     bdc:	4807      	ldr	r0, [pc, #28]	; (bfc <EDBG_COM_init+0x34>)
     bde:	4c08      	ldr	r4, [pc, #32]	; (c00 <EDBG_COM_init+0x38>)
     be0:	47a0      	blx	r4
	EDBG_COM_PORT_init();
     be2:	4b08      	ldr	r3, [pc, #32]	; (c04 <EDBG_COM_init+0x3c>)
     be4:	4798      	blx	r3
}
     be6:	bf00      	nop
     be8:	3704      	adds	r7, #4
     bea:	46bd      	mov	sp, r7
     bec:	bd90      	pop	{r4, r7, pc}
     bee:	bf00      	nop
     bf0:	00000b71 	.word	0x00000b71
     bf4:	200004fc 	.word	0x200004fc
     bf8:	40003400 	.word	0x40003400
     bfc:	200262e0 	.word	0x200262e0
     c00:	00001505 	.word	0x00001505
     c04:	00000ba5 	.word	0x00000ba5

00000c08 <PCC_SCCB_PORT_init>:

void PCC_SCCB_PORT_init(void)
{
     c08:	b580      	push	{r7, lr}
     c0a:	af00      	add	r7, sp, #0

	gpio_set_pin_pull_mode(PCC_SCCB_SDA,
     c0c:	2100      	movs	r1, #0
     c0e:	2068      	movs	r0, #104	; 0x68
     c10:	4b07      	ldr	r3, [pc, #28]	; (c30 <PCC_SCCB_PORT_init+0x28>)
     c12:	4798      	blx	r3
	                       // <GPIO_PULL_OFF"> Off
	                       // <GPIO_PULL_UP"> Pull-up
	                       // <GPIO_PULL_DOWN"> Pull-down
	                       GPIO_PULL_OFF);

	gpio_set_pin_function(PCC_SCCB_SDA, PINMUX_PD08C_SERCOM7_PAD0);
     c14:	4907      	ldr	r1, [pc, #28]	; (c34 <PCC_SCCB_PORT_init+0x2c>)
     c16:	2068      	movs	r0, #104	; 0x68
     c18:	4b07      	ldr	r3, [pc, #28]	; (c38 <PCC_SCCB_PORT_init+0x30>)
     c1a:	4798      	blx	r3

	gpio_set_pin_pull_mode(PCC_SCCB_SCL,
     c1c:	2100      	movs	r1, #0
     c1e:	2069      	movs	r0, #105	; 0x69
     c20:	4b03      	ldr	r3, [pc, #12]	; (c30 <PCC_SCCB_PORT_init+0x28>)
     c22:	4798      	blx	r3
	                       // <GPIO_PULL_OFF"> Off
	                       // <GPIO_PULL_UP"> Pull-up
	                       // <GPIO_PULL_DOWN"> Pull-down
	                       GPIO_PULL_OFF);

	gpio_set_pin_function(PCC_SCCB_SCL, PINMUX_PD09C_SERCOM7_PAD1);
     c24:	4905      	ldr	r1, [pc, #20]	; (c3c <PCC_SCCB_PORT_init+0x34>)
     c26:	2069      	movs	r0, #105	; 0x69
     c28:	4b03      	ldr	r3, [pc, #12]	; (c38 <PCC_SCCB_PORT_init+0x30>)
     c2a:	4798      	blx	r3
}
     c2c:	bf00      	nop
     c2e:	bd80      	pop	{r7, pc}
     c30:	00000941 	.word	0x00000941
     c34:	00680002 	.word	0x00680002
     c38:	00000975 	.word	0x00000975
     c3c:	00690002 	.word	0x00690002

00000c40 <PCC_SCCB_CLOCK_init>:

void PCC_SCCB_CLOCK_init(void)
{
     c40:	b580      	push	{r7, lr}
     c42:	af00      	add	r7, sp, #0
	hri_gclk_write_PCHCTRL_reg(GCLK, SERCOM7_GCLK_ID_CORE, CONF_GCLK_SERCOM7_CORE_SRC | (1 << GCLK_PCHCTRL_CHEN_Pos));
     c44:	2243      	movs	r2, #67	; 0x43
     c46:	2125      	movs	r1, #37	; 0x25
     c48:	4806      	ldr	r0, [pc, #24]	; (c64 <PCC_SCCB_CLOCK_init+0x24>)
     c4a:	4b07      	ldr	r3, [pc, #28]	; (c68 <PCC_SCCB_CLOCK_init+0x28>)
     c4c:	4798      	blx	r3
	hri_gclk_write_PCHCTRL_reg(GCLK, SERCOM7_GCLK_ID_SLOW, CONF_GCLK_SERCOM7_SLOW_SRC | (1 << GCLK_PCHCTRL_CHEN_Pos));
     c4e:	2242      	movs	r2, #66	; 0x42
     c50:	2103      	movs	r1, #3
     c52:	4804      	ldr	r0, [pc, #16]	; (c64 <PCC_SCCB_CLOCK_init+0x24>)
     c54:	4b04      	ldr	r3, [pc, #16]	; (c68 <PCC_SCCB_CLOCK_init+0x28>)
     c56:	4798      	blx	r3

	hri_mclk_set_APBDMASK_SERCOM7_bit(MCLK);
     c58:	4804      	ldr	r0, [pc, #16]	; (c6c <PCC_SCCB_CLOCK_init+0x2c>)
     c5a:	4b05      	ldr	r3, [pc, #20]	; (c70 <PCC_SCCB_CLOCK_init+0x30>)
     c5c:	4798      	blx	r3
}
     c5e:	bf00      	nop
     c60:	bd80      	pop	{r7, pc}
     c62:	bf00      	nop
     c64:	40001c00 	.word	0x40001c00
     c68:	00000383 	.word	0x00000383
     c6c:	40000800 	.word	0x40000800
     c70:	00000429 	.word	0x00000429

00000c74 <PCC_SCCB_init>:

void PCC_SCCB_init(void)
{
     c74:	b580      	push	{r7, lr}
     c76:	af00      	add	r7, sp, #0
	PCC_SCCB_CLOCK_init();
     c78:	4b04      	ldr	r3, [pc, #16]	; (c8c <PCC_SCCB_init+0x18>)
     c7a:	4798      	blx	r3
	i2c_m_sync_init(&PCC_SCCB, SERCOM7);
     c7c:	4904      	ldr	r1, [pc, #16]	; (c90 <PCC_SCCB_init+0x1c>)
     c7e:	4805      	ldr	r0, [pc, #20]	; (c94 <PCC_SCCB_init+0x20>)
     c80:	4b05      	ldr	r3, [pc, #20]	; (c98 <PCC_SCCB_init+0x24>)
     c82:	4798      	blx	r3
	PCC_SCCB_PORT_init();
     c84:	4b05      	ldr	r3, [pc, #20]	; (c9c <PCC_SCCB_init+0x28>)
     c86:	4798      	blx	r3
}
     c88:	bf00      	nop
     c8a:	bd80      	pop	{r7, pc}
     c8c:	00000c41 	.word	0x00000c41
     c90:	43000c00 	.word	0x43000c00
     c94:	20026344 	.word	0x20026344
     c98:	00001245 	.word	0x00001245
     c9c:	00000c09 	.word	0x00000c09

00000ca0 <delay_driver_init>:

void delay_driver_init(void)
{
     ca0:	b580      	push	{r7, lr}
     ca2:	af00      	add	r7, sp, #0
	delay_init(SysTick);
     ca4:	4802      	ldr	r0, [pc, #8]	; (cb0 <delay_driver_init+0x10>)
     ca6:	4b03      	ldr	r3, [pc, #12]	; (cb4 <delay_driver_init+0x14>)
     ca8:	4798      	blx	r3
}
     caa:	bf00      	nop
     cac:	bd80      	pop	{r7, pc}
     cae:	bf00      	nop
     cb0:	e000e010 	.word	0xe000e010
     cb4:	00000eb9 	.word	0x00000eb9

00000cb8 <PWM_0_PORT_init>:

void PWM_0_PORT_init(void)
{
     cb8:	b580      	push	{r7, lr}
     cba:	af00      	add	r7, sp, #0

	gpio_set_pin_function(PD11, PINMUX_PD11F_TCC0_WO4);
     cbc:	4902      	ldr	r1, [pc, #8]	; (cc8 <PWM_0_PORT_init+0x10>)
     cbe:	206b      	movs	r0, #107	; 0x6b
     cc0:	4b02      	ldr	r3, [pc, #8]	; (ccc <PWM_0_PORT_init+0x14>)
     cc2:	4798      	blx	r3
}
     cc4:	bf00      	nop
     cc6:	bd80      	pop	{r7, pc}
     cc8:	006b0005 	.word	0x006b0005
     ccc:	00000975 	.word	0x00000975

00000cd0 <PWM_0_CLOCK_init>:

void PWM_0_CLOCK_init(void)
{
     cd0:	b580      	push	{r7, lr}
     cd2:	af00      	add	r7, sp, #0

	hri_mclk_set_APBBMASK_TCC0_bit(MCLK);
     cd4:	4804      	ldr	r0, [pc, #16]	; (ce8 <PWM_0_CLOCK_init+0x18>)
     cd6:	4b05      	ldr	r3, [pc, #20]	; (cec <PWM_0_CLOCK_init+0x1c>)
     cd8:	4798      	blx	r3
	hri_gclk_write_PCHCTRL_reg(GCLK, TCC0_GCLK_ID, CONF_GCLK_TCC0_SRC | (1 << GCLK_PCHCTRL_CHEN_Pos));
     cda:	2240      	movs	r2, #64	; 0x40
     cdc:	2119      	movs	r1, #25
     cde:	4804      	ldr	r0, [pc, #16]	; (cf0 <PWM_0_CLOCK_init+0x20>)
     ce0:	4b04      	ldr	r3, [pc, #16]	; (cf4 <PWM_0_CLOCK_init+0x24>)
     ce2:	4798      	blx	r3
}
     ce4:	bf00      	nop
     ce6:	bd80      	pop	{r7, pc}
     ce8:	40000800 	.word	0x40000800
     cec:	00000409 	.word	0x00000409
     cf0:	40001c00 	.word	0x40001c00
     cf4:	00000383 	.word	0x00000383

00000cf8 <PWM_0_init>:

void PWM_0_init(void)
{
     cf8:	b580      	push	{r7, lr}
     cfa:	af00      	add	r7, sp, #0
	PWM_0_CLOCK_init();
     cfc:	4b06      	ldr	r3, [pc, #24]	; (d18 <PWM_0_init+0x20>)
     cfe:	4798      	blx	r3
	PWM_0_PORT_init();
     d00:	4b06      	ldr	r3, [pc, #24]	; (d1c <PWM_0_init+0x24>)
     d02:	4798      	blx	r3
	pwm_init(&PWM_0, TCC0, _tcc_get_pwm());
     d04:	4b06      	ldr	r3, [pc, #24]	; (d20 <PWM_0_init+0x28>)
     d06:	4798      	blx	r3
     d08:	4603      	mov	r3, r0
     d0a:	461a      	mov	r2, r3
     d0c:	4905      	ldr	r1, [pc, #20]	; (d24 <PWM_0_init+0x2c>)
     d0e:	4806      	ldr	r0, [pc, #24]	; (d28 <PWM_0_init+0x30>)
     d10:	4b06      	ldr	r3, [pc, #24]	; (d2c <PWM_0_init+0x34>)
     d12:	4798      	blx	r3
}
     d14:	bf00      	nop
     d16:	bd80      	pop	{r7, pc}
     d18:	00000cd1 	.word	0x00000cd1
     d1c:	00000cb9 	.word	0x00000cb9
     d20:	00005281 	.word	0x00005281
     d24:	41016000 	.word	0x41016000
     d28:	200262c4 	.word	0x200262c4
     d2c:	000013c1 	.word	0x000013c1

00000d30 <system_init>:

void system_init(void)
{
     d30:	b580      	push	{r7, lr}
     d32:	af00      	add	r7, sp, #0
	init_mcu();
     d34:	4b22      	ldr	r3, [pc, #136]	; (dc0 <system_init+0x90>)
     d36:	4798      	blx	r3

	// GPIO on PC11

	gpio_set_pin_level(PC11,
     d38:	2100      	movs	r1, #0
     d3a:	204b      	movs	r0, #75	; 0x4b
     d3c:	4b21      	ldr	r3, [pc, #132]	; (dc4 <system_init+0x94>)
     d3e:	4798      	blx	r3
	                   // <false"> Low
	                   // <true"> High
	                   false);

	// Set pin direction to output
	gpio_set_pin_direction(PC11, GPIO_DIRECTION_OUT);
     d40:	2102      	movs	r1, #2
     d42:	204b      	movs	r0, #75	; 0x4b
     d44:	4b20      	ldr	r3, [pc, #128]	; (dc8 <system_init+0x98>)
     d46:	4798      	blx	r3

	gpio_set_pin_function(PC11, GPIO_PIN_FUNCTION_OFF);
     d48:	f04f 31ff 	mov.w	r1, #4294967295
     d4c:	204b      	movs	r0, #75	; 0x4b
     d4e:	4b1f      	ldr	r3, [pc, #124]	; (dcc <system_init+0x9c>)
     d50:	4798      	blx	r3

	// GPIO on PC12

	gpio_set_pin_level(PC12,
     d52:	2100      	movs	r1, #0
     d54:	204c      	movs	r0, #76	; 0x4c
     d56:	4b1b      	ldr	r3, [pc, #108]	; (dc4 <system_init+0x94>)
     d58:	4798      	blx	r3
	                   // <false"> Low
	                   // <true"> High
	                   false);

	// Set pin direction to output
	gpio_set_pin_direction(PC12, GPIO_DIRECTION_OUT);
     d5a:	2102      	movs	r1, #2
     d5c:	204c      	movs	r0, #76	; 0x4c
     d5e:	4b1a      	ldr	r3, [pc, #104]	; (dc8 <system_init+0x98>)
     d60:	4798      	blx	r3

	gpio_set_pin_function(PC12, GPIO_PIN_FUNCTION_OFF);
     d62:	f04f 31ff 	mov.w	r1, #4294967295
     d66:	204c      	movs	r0, #76	; 0x4c
     d68:	4b18      	ldr	r3, [pc, #96]	; (dcc <system_init+0x9c>)
     d6a:	4798      	blx	r3

	// GPIO on PC22

	gpio_set_pin_level(PCC_PWDN,
     d6c:	2100      	movs	r1, #0
     d6e:	2056      	movs	r0, #86	; 0x56
     d70:	4b14      	ldr	r3, [pc, #80]	; (dc4 <system_init+0x94>)
     d72:	4798      	blx	r3
	                   // <false"> Low
	                   // <true"> High
	                   false);

	// Set pin direction to output
	gpio_set_pin_direction(PCC_PWDN, GPIO_DIRECTION_OUT);
     d74:	2102      	movs	r1, #2
     d76:	2056      	movs	r0, #86	; 0x56
     d78:	4b13      	ldr	r3, [pc, #76]	; (dc8 <system_init+0x98>)
     d7a:	4798      	blx	r3

	gpio_set_pin_function(PCC_PWDN, GPIO_PIN_FUNCTION_OFF);
     d7c:	f04f 31ff 	mov.w	r1, #4294967295
     d80:	2056      	movs	r0, #86	; 0x56
     d82:	4b12      	ldr	r3, [pc, #72]	; (dcc <system_init+0x9c>)
     d84:	4798      	blx	r3

	// GPIO on PC23

	gpio_set_pin_level(PCC_RESET,
     d86:	2101      	movs	r1, #1
     d88:	2057      	movs	r0, #87	; 0x57
     d8a:	4b0e      	ldr	r3, [pc, #56]	; (dc4 <system_init+0x94>)
     d8c:	4798      	blx	r3
	                   // <false"> Low
	                   // <true"> High
	                   true);

	// Set pin direction to output
	gpio_set_pin_direction(PCC_RESET, GPIO_DIRECTION_OUT);
     d8e:	2102      	movs	r1, #2
     d90:	2057      	movs	r0, #87	; 0x57
     d92:	4b0d      	ldr	r3, [pc, #52]	; (dc8 <system_init+0x98>)
     d94:	4798      	blx	r3

	gpio_set_pin_function(PCC_RESET, GPIO_PIN_FUNCTION_OFF);
     d96:	f04f 31ff 	mov.w	r1, #4294967295
     d9a:	2057      	movs	r0, #87	; 0x57
     d9c:	4b0b      	ldr	r3, [pc, #44]	; (dcc <system_init+0x9c>)
     d9e:	4798      	blx	r3

	EXTERNAL_IRQ_0_init();
     da0:	4b0b      	ldr	r3, [pc, #44]	; (dd0 <system_init+0xa0>)
     da2:	4798      	blx	r3

	EVENT_SYSTEM_0_init();
     da4:	4b0b      	ldr	r3, [pc, #44]	; (dd4 <system_init+0xa4>)
     da6:	4798      	blx	r3

	CAMERA_OV7670_init();
     da8:	4b0b      	ldr	r3, [pc, #44]	; (dd8 <system_init+0xa8>)
     daa:	4798      	blx	r3

	EDBG_COM_init();
     dac:	4b0b      	ldr	r3, [pc, #44]	; (ddc <system_init+0xac>)
     dae:	4798      	blx	r3

	PCC_SCCB_init();
     db0:	4b0b      	ldr	r3, [pc, #44]	; (de0 <system_init+0xb0>)
     db2:	4798      	blx	r3

	delay_driver_init();
     db4:	4b0b      	ldr	r3, [pc, #44]	; (de4 <system_init+0xb4>)
     db6:	4798      	blx	r3

	PWM_0_init();
     db8:	4b0b      	ldr	r3, [pc, #44]	; (de8 <system_init+0xb8>)
     dba:	4798      	blx	r3
}
     dbc:	bf00      	nop
     dbe:	bd80      	pop	{r7, pc}
     dc0:	00000a05 	.word	0x00000a05
     dc4:	000009cd 	.word	0x000009cd
     dc8:	00000995 	.word	0x00000995
     dcc:	00000975 	.word	0x00000975
     dd0:	00000a15 	.word	0x00000a15
     dd4:	00000a85 	.word	0x00000a85
     dd8:	00000b45 	.word	0x00000b45
     ddc:	00000bc9 	.word	0x00000bc9
     de0:	00000c75 	.word	0x00000c75
     de4:	00000ca1 	.word	0x00000ca1
     de8:	00000cf9 	.word	0x00000cf9

00000dec <atomic_enter_critical>:

/**
 * \brief Disable interrupts, enter critical section
 */
void atomic_enter_critical(hal_atomic_t volatile *atomic)
{
     dec:	b480      	push	{r7}
     dee:	b085      	sub	sp, #20
     df0:	af00      	add	r7, sp, #0
     df2:	6078      	str	r0, [r7, #4]
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
     df4:	f3ef 8310 	mrs	r3, PRIMASK
     df8:	60fb      	str	r3, [r7, #12]
  return(result);
     dfa:	68fa      	ldr	r2, [r7, #12]
	*atomic = __get_PRIMASK();
     dfc:	687b      	ldr	r3, [r7, #4]
     dfe:	601a      	str	r2, [r3, #0]
  __ASM volatile ("cpsid i" : : : "memory");
     e00:	b672      	cpsid	i
  \details Ensures the apparent order of the explicit memory operations before
           and after the instruction, without ensuring their completion.
 */
__STATIC_FORCEINLINE void __DMB(void)
{
  __ASM volatile ("dmb 0xF":::"memory");
     e02:	f3bf 8f5f 	dmb	sy
	__disable_irq();
	__DMB();
}
     e06:	bf00      	nop
     e08:	3714      	adds	r7, #20
     e0a:	46bd      	mov	sp, r7
     e0c:	f85d 7b04 	ldr.w	r7, [sp], #4
     e10:	4770      	bx	lr

00000e12 <atomic_leave_critical>:

/**
 * \brief Exit atomic section
 */
void atomic_leave_critical(hal_atomic_t volatile *atomic)
{
     e12:	b480      	push	{r7}
     e14:	b085      	sub	sp, #20
     e16:	af00      	add	r7, sp, #0
     e18:	6078      	str	r0, [r7, #4]
     e1a:	f3bf 8f5f 	dmb	sy
	__DMB();
	__set_PRIMASK(*atomic);
     e1e:	687b      	ldr	r3, [r7, #4]
     e20:	681b      	ldr	r3, [r3, #0]
     e22:	60fb      	str	r3, [r7, #12]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
     e24:	68fb      	ldr	r3, [r7, #12]
     e26:	f383 8810 	msr	PRIMASK, r3
}
     e2a:	bf00      	nop
     e2c:	3714      	adds	r7, #20
     e2e:	46bd      	mov	sp, r7
     e30:	f85d 7b04 	ldr.w	r7, [sp], #4
     e34:	4770      	bx	lr

00000e36 <camera_async_capture_done>:
 */

#include "hal_camera_async.h"

static void camera_async_capture_done(struct _camera_async_device *device, uint32_t ch)
{
     e36:	b580      	push	{r7, lr}
     e38:	b084      	sub	sp, #16
     e3a:	af00      	add	r7, sp, #0
     e3c:	6078      	str	r0, [r7, #4]
     e3e:	6039      	str	r1, [r7, #0]
	struct camera_async_descriptor *const descr = CONTAINER_OF(device, struct camera_async_descriptor, device);
     e40:	687b      	ldr	r3, [r7, #4]
     e42:	60fb      	str	r3, [r7, #12]

	if (descr->capture_done) {
     e44:	68fb      	ldr	r3, [r7, #12]
     e46:	691b      	ldr	r3, [r3, #16]
     e48:	2b00      	cmp	r3, #0
     e4a:	d004      	beq.n	e56 <camera_async_capture_done+0x20>
		descr->capture_done(descr, ch);
     e4c:	68fb      	ldr	r3, [r7, #12]
     e4e:	691b      	ldr	r3, [r3, #16]
     e50:	6839      	ldr	r1, [r7, #0]
     e52:	68f8      	ldr	r0, [r7, #12]
     e54:	4798      	blx	r3
	}
}
     e56:	bf00      	nop
     e58:	3710      	adds	r7, #16
     e5a:	46bd      	mov	sp, r7
     e5c:	bd80      	pop	{r7, pc}
	...

00000e60 <camera_async_init>:

/**
 * \brief Initialize the camera sensor HAL instance and hardware.
 */
int32_t camera_async_init(struct camera_async_descriptor *const descr, void *const hw)
{
     e60:	b580      	push	{r7, lr}
     e62:	b082      	sub	sp, #8
     e64:	af00      	add	r7, sp, #0
     e66:	6078      	str	r0, [r7, #4]
     e68:	6039      	str	r1, [r7, #0]
	ASSERT(descr && hw);
     e6a:	687b      	ldr	r3, [r7, #4]
     e6c:	2b00      	cmp	r3, #0
     e6e:	d004      	beq.n	e7a <camera_async_init+0x1a>
     e70:	683b      	ldr	r3, [r7, #0]
     e72:	2b00      	cmp	r3, #0
     e74:	d001      	beq.n	e7a <camera_async_init+0x1a>
     e76:	2301      	movs	r3, #1
     e78:	e000      	b.n	e7c <camera_async_init+0x1c>
     e7a:	2300      	movs	r3, #0
     e7c:	f003 0301 	and.w	r3, r3, #1
     e80:	b2db      	uxtb	r3, r3
     e82:	2232      	movs	r2, #50	; 0x32
     e84:	4908      	ldr	r1, [pc, #32]	; (ea8 <camera_async_init+0x48>)
     e86:	4618      	mov	r0, r3
     e88:	4b08      	ldr	r3, [pc, #32]	; (eac <camera_async_init+0x4c>)
     e8a:	4798      	blx	r3

	_camera_async_init(&descr->device, hw);
     e8c:	687b      	ldr	r3, [r7, #4]
     e8e:	6839      	ldr	r1, [r7, #0]
     e90:	4618      	mov	r0, r3
     e92:	4b07      	ldr	r3, [pc, #28]	; (eb0 <camera_async_init+0x50>)
     e94:	4798      	blx	r3

	descr->device.capture_done = camera_async_capture_done;
     e96:	687b      	ldr	r3, [r7, #4]
     e98:	4a06      	ldr	r2, [pc, #24]	; (eb4 <camera_async_init+0x54>)
     e9a:	601a      	str	r2, [r3, #0]

	return ERR_NONE;
     e9c:	2300      	movs	r3, #0
}
     e9e:	4618      	mov	r0, r3
     ea0:	3708      	adds	r7, #8
     ea2:	46bd      	mov	sp, r7
     ea4:	bd80      	pop	{r7, pc}
     ea6:	bf00      	nop
     ea8:	00005afc 	.word	0x00005afc
     eac:	00001849 	.word	0x00001849
     eb0:	00003421 	.word	0x00003421
     eb4:	00000e37 	.word	0x00000e37

00000eb8 <delay_init>:

/**
 * \brief Initialize Delay driver
 */
void delay_init(void *const hw)
{
     eb8:	b580      	push	{r7, lr}
     eba:	b082      	sub	sp, #8
     ebc:	af00      	add	r7, sp, #0
     ebe:	6078      	str	r0, [r7, #4]
	_delay_init(hardware = hw);
     ec0:	4a05      	ldr	r2, [pc, #20]	; (ed8 <delay_init+0x20>)
     ec2:	687b      	ldr	r3, [r7, #4]
     ec4:	6013      	str	r3, [r2, #0]
     ec6:	4b04      	ldr	r3, [pc, #16]	; (ed8 <delay_init+0x20>)
     ec8:	681b      	ldr	r3, [r3, #0]
     eca:	4618      	mov	r0, r3
     ecc:	4b03      	ldr	r3, [pc, #12]	; (edc <delay_init+0x24>)
     ece:	4798      	blx	r3
}
     ed0:	bf00      	nop
     ed2:	3708      	adds	r7, #8
     ed4:	46bd      	mov	sp, r7
     ed6:	bd80      	pop	{r7, pc}
     ed8:	2000050c 	.word	0x2000050c
     edc:	00004b8d 	.word	0x00004b8d

00000ee0 <delay_us>:

/**
 * \brief Perform delay in us
 */
void delay_us(const uint16_t us)
{
     ee0:	b590      	push	{r4, r7, lr}
     ee2:	b083      	sub	sp, #12
     ee4:	af00      	add	r7, sp, #0
     ee6:	4603      	mov	r3, r0
     ee8:	80fb      	strh	r3, [r7, #6]
	_delay_cycles(hardware, _get_cycles_for_us(us));
     eea:	4b07      	ldr	r3, [pc, #28]	; (f08 <delay_us+0x28>)
     eec:	681c      	ldr	r4, [r3, #0]
     eee:	88fb      	ldrh	r3, [r7, #6]
     ef0:	4618      	mov	r0, r3
     ef2:	4b06      	ldr	r3, [pc, #24]	; (f0c <delay_us+0x2c>)
     ef4:	4798      	blx	r3
     ef6:	4603      	mov	r3, r0
     ef8:	4619      	mov	r1, r3
     efa:	4620      	mov	r0, r4
     efc:	4b04      	ldr	r3, [pc, #16]	; (f10 <delay_us+0x30>)
     efe:	4798      	blx	r3
}
     f00:	bf00      	nop
     f02:	370c      	adds	r7, #12
     f04:	46bd      	mov	sp, r7
     f06:	bd90      	pop	{r4, r7, pc}
     f08:	2000050c 	.word	0x2000050c
     f0c:	00001b1d 	.word	0x00001b1d
     f10:	00004ba9 	.word	0x00004ba9

00000f14 <delay_ms>:

/**
 * \brief Perform delay in ms
 */
void delay_ms(const uint16_t ms)
{
     f14:	b590      	push	{r4, r7, lr}
     f16:	b083      	sub	sp, #12
     f18:	af00      	add	r7, sp, #0
     f1a:	4603      	mov	r3, r0
     f1c:	80fb      	strh	r3, [r7, #6]
	_delay_cycles(hardware, _get_cycles_for_ms(ms));
     f1e:	4b07      	ldr	r3, [pc, #28]	; (f3c <delay_ms+0x28>)
     f20:	681c      	ldr	r4, [r3, #0]
     f22:	88fb      	ldrh	r3, [r7, #6]
     f24:	4618      	mov	r0, r3
     f26:	4b06      	ldr	r3, [pc, #24]	; (f40 <delay_ms+0x2c>)
     f28:	4798      	blx	r3
     f2a:	4603      	mov	r3, r0
     f2c:	4619      	mov	r1, r3
     f2e:	4620      	mov	r0, r4
     f30:	4b04      	ldr	r3, [pc, #16]	; (f44 <delay_ms+0x30>)
     f32:	4798      	blx	r3
}
     f34:	bf00      	nop
     f36:	370c      	adds	r7, #12
     f38:	46bd      	mov	sp, r7
     f3a:	bd90      	pop	{r4, r7, pc}
     f3c:	2000050c 	.word	0x2000050c
     f40:	00001c51 	.word	0x00001c51
     f44:	00004ba9 	.word	0x00004ba9

00000f48 <event_system_init>:

/**
 * \brief Initialize event system.
 */
int32_t event_system_init(void)
{
     f48:	b580      	push	{r7, lr}
     f4a:	af00      	add	r7, sp, #0
	return _event_system_init();
     f4c:	4b02      	ldr	r3, [pc, #8]	; (f58 <event_system_init+0x10>)
     f4e:	4798      	blx	r3
     f50:	4603      	mov	r3, r0
}
     f52:	4618      	mov	r0, r3
     f54:	bd80      	pop	{r7, pc}
     f56:	bf00      	nop
     f58:	00002e69 	.word	0x00002e69

00000f5c <ext_irq_init>:

/**
 * \brief Initialize external irq component if any
 */
int32_t ext_irq_init(void)
{
     f5c:	b580      	push	{r7, lr}
     f5e:	b082      	sub	sp, #8
     f60:	af00      	add	r7, sp, #0
	uint16_t i;

	for (i = 0; i < EXT_IRQ_AMOUNT; i++) {
     f62:	2300      	movs	r3, #0
     f64:	80fb      	strh	r3, [r7, #6]
     f66:	e00e      	b.n	f86 <ext_irq_init+0x2a>
		ext_irqs[i].pin = 0xFFFFFFFF;
     f68:	88fb      	ldrh	r3, [r7, #6]
     f6a:	4a0c      	ldr	r2, [pc, #48]	; (f9c <ext_irq_init+0x40>)
     f6c:	00db      	lsls	r3, r3, #3
     f6e:	4413      	add	r3, r2
     f70:	f04f 32ff 	mov.w	r2, #4294967295
     f74:	605a      	str	r2, [r3, #4]
		ext_irqs[i].cb  = NULL;
     f76:	88fb      	ldrh	r3, [r7, #6]
     f78:	4a08      	ldr	r2, [pc, #32]	; (f9c <ext_irq_init+0x40>)
     f7a:	2100      	movs	r1, #0
     f7c:	f842 1033 	str.w	r1, [r2, r3, lsl #3]
	for (i = 0; i < EXT_IRQ_AMOUNT; i++) {
     f80:	88fb      	ldrh	r3, [r7, #6]
     f82:	3301      	adds	r3, #1
     f84:	80fb      	strh	r3, [r7, #6]
     f86:	88fb      	ldrh	r3, [r7, #6]
     f88:	2b01      	cmp	r3, #1
     f8a:	d9ed      	bls.n	f68 <ext_irq_init+0xc>
	}

	return _ext_irq_init(process_ext_irq);
     f8c:	4804      	ldr	r0, [pc, #16]	; (fa0 <ext_irq_init+0x44>)
     f8e:	4b05      	ldr	r3, [pc, #20]	; (fa4 <ext_irq_init+0x48>)
     f90:	4798      	blx	r3
     f92:	4603      	mov	r3, r0
}
     f94:	4618      	mov	r0, r3
     f96:	3708      	adds	r7, #8
     f98:	46bd      	mov	sp, r7
     f9a:	bd80      	pop	{r7, pc}
     f9c:	20000510 	.word	0x20000510
     fa0:	00001121 	.word	0x00001121
     fa4:	00002add 	.word	0x00002add

00000fa8 <ext_irq_register>:

/**
 * \brief Register callback for the given external interrupt
 */
int32_t ext_irq_register(const uint32_t pin, ext_irq_cb_t cb)
{
     fa8:	b580      	push	{r7, lr}
     faa:	b086      	sub	sp, #24
     fac:	af00      	add	r7, sp, #0
     fae:	6078      	str	r0, [r7, #4]
     fb0:	6039      	str	r1, [r7, #0]
	uint8_t i = 0, j = 0;
     fb2:	2300      	movs	r3, #0
     fb4:	75fb      	strb	r3, [r7, #23]
     fb6:	2300      	movs	r3, #0
     fb8:	75bb      	strb	r3, [r7, #22]
	bool    found = false;
     fba:	2300      	movs	r3, #0
     fbc:	757b      	strb	r3, [r7, #21]

	for (; i < EXT_IRQ_AMOUNT; i++) {
     fbe:	e012      	b.n	fe6 <ext_irq_register+0x3e>
		if (ext_irqs[i].pin == pin) {
     fc0:	7dfb      	ldrb	r3, [r7, #23]
     fc2:	4a4d      	ldr	r2, [pc, #308]	; (10f8 <ext_irq_register+0x150>)
     fc4:	00db      	lsls	r3, r3, #3
     fc6:	4413      	add	r3, r2
     fc8:	685a      	ldr	r2, [r3, #4]
     fca:	687b      	ldr	r3, [r7, #4]
     fcc:	429a      	cmp	r2, r3
     fce:	d107      	bne.n	fe0 <ext_irq_register+0x38>
			ext_irqs[i].cb = cb;
     fd0:	7dfb      	ldrb	r3, [r7, #23]
     fd2:	4949      	ldr	r1, [pc, #292]	; (10f8 <ext_irq_register+0x150>)
     fd4:	683a      	ldr	r2, [r7, #0]
     fd6:	f841 2033 	str.w	r2, [r1, r3, lsl #3]
			found          = true;
     fda:	2301      	movs	r3, #1
     fdc:	757b      	strb	r3, [r7, #21]
			break;
     fde:	e005      	b.n	fec <ext_irq_register+0x44>
	for (; i < EXT_IRQ_AMOUNT; i++) {
     fe0:	7dfb      	ldrb	r3, [r7, #23]
     fe2:	3301      	adds	r3, #1
     fe4:	75fb      	strb	r3, [r7, #23]
     fe6:	7dfb      	ldrb	r3, [r7, #23]
     fe8:	2b01      	cmp	r3, #1
     fea:	d9e9      	bls.n	fc0 <ext_irq_register+0x18>
		}
	}

	if (NULL == cb) {
     fec:	683b      	ldr	r3, [r7, #0]
     fee:	2b00      	cmp	r3, #0
     ff0:	d10e      	bne.n	1010 <ext_irq_register+0x68>
		if (!found) {
     ff2:	7d7b      	ldrb	r3, [r7, #21]
     ff4:	f083 0301 	eor.w	r3, r3, #1
     ff8:	b2db      	uxtb	r3, r3
     ffa:	2b00      	cmp	r3, #0
     ffc:	d002      	beq.n	1004 <ext_irq_register+0x5c>
			return ERR_INVALID_ARG;
     ffe:	f06f 030c 	mvn.w	r3, #12
    1002:	e074      	b.n	10ee <ext_irq_register+0x146>
		}
		return _ext_irq_enable(pin, false);
    1004:	2100      	movs	r1, #0
    1006:	6878      	ldr	r0, [r7, #4]
    1008:	4b3c      	ldr	r3, [pc, #240]	; (10fc <ext_irq_register+0x154>)
    100a:	4798      	blx	r3
    100c:	4603      	mov	r3, r0
    100e:	e06e      	b.n	10ee <ext_irq_register+0x146>
	}

	if (!found) {
    1010:	7d7b      	ldrb	r3, [r7, #21]
    1012:	f083 0301 	eor.w	r3, r3, #1
    1016:	b2db      	uxtb	r3, r3
    1018:	2b00      	cmp	r3, #0
    101a:	d05a      	beq.n	10d2 <ext_irq_register+0x12a>
		for (i = 0; i < EXT_IRQ_AMOUNT; i++) {
    101c:	2300      	movs	r3, #0
    101e:	75fb      	strb	r3, [r7, #23]
    1020:	e016      	b.n	1050 <ext_irq_register+0xa8>
			if (NULL == ext_irqs[i].cb) {
    1022:	7dfb      	ldrb	r3, [r7, #23]
    1024:	4a34      	ldr	r2, [pc, #208]	; (10f8 <ext_irq_register+0x150>)
    1026:	f852 3033 	ldr.w	r3, [r2, r3, lsl #3]
    102a:	2b00      	cmp	r3, #0
    102c:	d10d      	bne.n	104a <ext_irq_register+0xa2>
				ext_irqs[i].cb  = cb;
    102e:	7dfb      	ldrb	r3, [r7, #23]
    1030:	4931      	ldr	r1, [pc, #196]	; (10f8 <ext_irq_register+0x150>)
    1032:	683a      	ldr	r2, [r7, #0]
    1034:	f841 2033 	str.w	r2, [r1, r3, lsl #3]
				ext_irqs[i].pin = pin;
    1038:	7dfb      	ldrb	r3, [r7, #23]
    103a:	4a2f      	ldr	r2, [pc, #188]	; (10f8 <ext_irq_register+0x150>)
    103c:	00db      	lsls	r3, r3, #3
    103e:	4413      	add	r3, r2
    1040:	687a      	ldr	r2, [r7, #4]
    1042:	605a      	str	r2, [r3, #4]
				found           = true;
    1044:	2301      	movs	r3, #1
    1046:	757b      	strb	r3, [r7, #21]
				break;
    1048:	e005      	b.n	1056 <ext_irq_register+0xae>
		for (i = 0; i < EXT_IRQ_AMOUNT; i++) {
    104a:	7dfb      	ldrb	r3, [r7, #23]
    104c:	3301      	adds	r3, #1
    104e:	75fb      	strb	r3, [r7, #23]
    1050:	7dfb      	ldrb	r3, [r7, #23]
    1052:	2b01      	cmp	r3, #1
    1054:	d9e5      	bls.n	1022 <ext_irq_register+0x7a>
			}
		}
		for (; (j < EXT_IRQ_AMOUNT) && (i < EXT_IRQ_AMOUNT); j++) {
    1056:	e036      	b.n	10c6 <ext_irq_register+0x11e>
			if ((ext_irqs[i].pin < ext_irqs[j].pin) && (ext_irqs[j].pin != 0xFFFFFFFF)) {
    1058:	7dfb      	ldrb	r3, [r7, #23]
    105a:	4a27      	ldr	r2, [pc, #156]	; (10f8 <ext_irq_register+0x150>)
    105c:	00db      	lsls	r3, r3, #3
    105e:	4413      	add	r3, r2
    1060:	685a      	ldr	r2, [r3, #4]
    1062:	7dbb      	ldrb	r3, [r7, #22]
    1064:	4924      	ldr	r1, [pc, #144]	; (10f8 <ext_irq_register+0x150>)
    1066:	00db      	lsls	r3, r3, #3
    1068:	440b      	add	r3, r1
    106a:	685b      	ldr	r3, [r3, #4]
    106c:	429a      	cmp	r2, r3
    106e:	d227      	bcs.n	10c0 <ext_irq_register+0x118>
    1070:	7dbb      	ldrb	r3, [r7, #22]
    1072:	4a21      	ldr	r2, [pc, #132]	; (10f8 <ext_irq_register+0x150>)
    1074:	00db      	lsls	r3, r3, #3
    1076:	4413      	add	r3, r2
    1078:	685b      	ldr	r3, [r3, #4]
    107a:	f1b3 3fff 	cmp.w	r3, #4294967295
    107e:	d01f      	beq.n	10c0 <ext_irq_register+0x118>
				struct ext_irq tmp = ext_irqs[j];
    1080:	7dbb      	ldrb	r3, [r7, #22]
    1082:	491d      	ldr	r1, [pc, #116]	; (10f8 <ext_irq_register+0x150>)
    1084:	f107 020c 	add.w	r2, r7, #12
    1088:	00db      	lsls	r3, r3, #3
    108a:	440b      	add	r3, r1
    108c:	e893 0003 	ldmia.w	r3, {r0, r1}
    1090:	e882 0003 	stmia.w	r2, {r0, r1}

				ext_irqs[j] = ext_irqs[i];
    1094:	7dbb      	ldrb	r3, [r7, #22]
    1096:	7dfa      	ldrb	r2, [r7, #23]
    1098:	4817      	ldr	r0, [pc, #92]	; (10f8 <ext_irq_register+0x150>)
    109a:	4917      	ldr	r1, [pc, #92]	; (10f8 <ext_irq_register+0x150>)
    109c:	00db      	lsls	r3, r3, #3
    109e:	4403      	add	r3, r0
    10a0:	00d2      	lsls	r2, r2, #3
    10a2:	440a      	add	r2, r1
    10a4:	e892 0003 	ldmia.w	r2, {r0, r1}
    10a8:	e883 0003 	stmia.w	r3, {r0, r1}
				ext_irqs[i] = tmp;
    10ac:	7dfb      	ldrb	r3, [r7, #23]
    10ae:	4a12      	ldr	r2, [pc, #72]	; (10f8 <ext_irq_register+0x150>)
    10b0:	00db      	lsls	r3, r3, #3
    10b2:	4413      	add	r3, r2
    10b4:	f107 020c 	add.w	r2, r7, #12
    10b8:	e892 0003 	ldmia.w	r2, {r0, r1}
    10bc:	e883 0003 	stmia.w	r3, {r0, r1}
		for (; (j < EXT_IRQ_AMOUNT) && (i < EXT_IRQ_AMOUNT); j++) {
    10c0:	7dbb      	ldrb	r3, [r7, #22]
    10c2:	3301      	adds	r3, #1
    10c4:	75bb      	strb	r3, [r7, #22]
    10c6:	7dbb      	ldrb	r3, [r7, #22]
    10c8:	2b01      	cmp	r3, #1
    10ca:	d802      	bhi.n	10d2 <ext_irq_register+0x12a>
    10cc:	7dfb      	ldrb	r3, [r7, #23]
    10ce:	2b01      	cmp	r3, #1
    10d0:	d9c2      	bls.n	1058 <ext_irq_register+0xb0>
			}
		}
	}

	if (!found) {
    10d2:	7d7b      	ldrb	r3, [r7, #21]
    10d4:	f083 0301 	eor.w	r3, r3, #1
    10d8:	b2db      	uxtb	r3, r3
    10da:	2b00      	cmp	r3, #0
    10dc:	d002      	beq.n	10e4 <ext_irq_register+0x13c>
		return ERR_INVALID_ARG;
    10de:	f06f 030c 	mvn.w	r3, #12
    10e2:	e004      	b.n	10ee <ext_irq_register+0x146>
	}

	return _ext_irq_enable(pin, true);
    10e4:	2101      	movs	r1, #1
    10e6:	6878      	ldr	r0, [r7, #4]
    10e8:	4b04      	ldr	r3, [pc, #16]	; (10fc <ext_irq_register+0x154>)
    10ea:	4798      	blx	r3
    10ec:	4603      	mov	r3, r0
}
    10ee:	4618      	mov	r0, r3
    10f0:	3718      	adds	r7, #24
    10f2:	46bd      	mov	sp, r7
    10f4:	bd80      	pop	{r7, pc}
    10f6:	bf00      	nop
    10f8:	20000510 	.word	0x20000510
    10fc:	00002bf1 	.word	0x00002bf1

00001100 <ext_irq_disable>:

/**
 * \brief Disable external irq
 */
int32_t ext_irq_disable(const uint32_t pin)
{
    1100:	b580      	push	{r7, lr}
    1102:	b082      	sub	sp, #8
    1104:	af00      	add	r7, sp, #0
    1106:	6078      	str	r0, [r7, #4]
	return _ext_irq_enable(pin, false);
    1108:	2100      	movs	r1, #0
    110a:	6878      	ldr	r0, [r7, #4]
    110c:	4b03      	ldr	r3, [pc, #12]	; (111c <ext_irq_disable+0x1c>)
    110e:	4798      	blx	r3
    1110:	4603      	mov	r3, r0
}
    1112:	4618      	mov	r0, r3
    1114:	3708      	adds	r7, #8
    1116:	46bd      	mov	sp, r7
    1118:	bd80      	pop	{r7, pc}
    111a:	bf00      	nop
    111c:	00002bf1 	.word	0x00002bf1

00001120 <process_ext_irq>:
 * \brief Interrupt processing routine
 *
 * \param[in] pin The pin which triggered the interrupt
 */
static void process_ext_irq(const uint32_t pin)
{
    1120:	b580      	push	{r7, lr}
    1122:	b084      	sub	sp, #16
    1124:	af00      	add	r7, sp, #0
    1126:	6078      	str	r0, [r7, #4]
	uint8_t lower = 0, middle, upper = EXT_IRQ_AMOUNT;
    1128:	2300      	movs	r3, #0
    112a:	73fb      	strb	r3, [r7, #15]
    112c:	2302      	movs	r3, #2
    112e:	73bb      	strb	r3, [r7, #14]

	while (upper >= lower) {
    1130:	e02a      	b.n	1188 <process_ext_irq+0x68>
		middle = (upper + lower) >> 1;
    1132:	7bba      	ldrb	r2, [r7, #14]
    1134:	7bfb      	ldrb	r3, [r7, #15]
    1136:	4413      	add	r3, r2
    1138:	105b      	asrs	r3, r3, #1
    113a:	737b      	strb	r3, [r7, #13]
		if (middle >= EXT_IRQ_AMOUNT) {
    113c:	7b7b      	ldrb	r3, [r7, #13]
    113e:	2b01      	cmp	r3, #1
    1140:	d827      	bhi.n	1192 <process_ext_irq+0x72>
			return;
		}

		if (ext_irqs[middle].pin == pin) {
    1142:	7b7b      	ldrb	r3, [r7, #13]
    1144:	4a16      	ldr	r2, [pc, #88]	; (11a0 <process_ext_irq+0x80>)
    1146:	00db      	lsls	r3, r3, #3
    1148:	4413      	add	r3, r2
    114a:	685a      	ldr	r2, [r3, #4]
    114c:	687b      	ldr	r3, [r7, #4]
    114e:	429a      	cmp	r2, r3
    1150:	d10b      	bne.n	116a <process_ext_irq+0x4a>
			if (ext_irqs[middle].cb) {
    1152:	7b7b      	ldrb	r3, [r7, #13]
    1154:	4a12      	ldr	r2, [pc, #72]	; (11a0 <process_ext_irq+0x80>)
    1156:	f852 3033 	ldr.w	r3, [r2, r3, lsl #3]
    115a:	2b00      	cmp	r3, #0
    115c:	d01b      	beq.n	1196 <process_ext_irq+0x76>
				ext_irqs[middle].cb();
    115e:	7b7b      	ldrb	r3, [r7, #13]
    1160:	4a0f      	ldr	r2, [pc, #60]	; (11a0 <process_ext_irq+0x80>)
    1162:	f852 3033 	ldr.w	r3, [r2, r3, lsl #3]
    1166:	4798      	blx	r3
			}
			return;
    1168:	e015      	b.n	1196 <process_ext_irq+0x76>
		}

		if (ext_irqs[middle].pin < pin) {
    116a:	7b7b      	ldrb	r3, [r7, #13]
    116c:	4a0c      	ldr	r2, [pc, #48]	; (11a0 <process_ext_irq+0x80>)
    116e:	00db      	lsls	r3, r3, #3
    1170:	4413      	add	r3, r2
    1172:	685a      	ldr	r2, [r3, #4]
    1174:	687b      	ldr	r3, [r7, #4]
    1176:	429a      	cmp	r2, r3
    1178:	d203      	bcs.n	1182 <process_ext_irq+0x62>
			lower = middle + 1;
    117a:	7b7b      	ldrb	r3, [r7, #13]
    117c:	3301      	adds	r3, #1
    117e:	73fb      	strb	r3, [r7, #15]
    1180:	e002      	b.n	1188 <process_ext_irq+0x68>
		} else {
			upper = middle - 1;
    1182:	7b7b      	ldrb	r3, [r7, #13]
    1184:	3b01      	subs	r3, #1
    1186:	73bb      	strb	r3, [r7, #14]
	while (upper >= lower) {
    1188:	7bba      	ldrb	r2, [r7, #14]
    118a:	7bfb      	ldrb	r3, [r7, #15]
    118c:	429a      	cmp	r2, r3
    118e:	d2d0      	bcs.n	1132 <process_ext_irq+0x12>
    1190:	e002      	b.n	1198 <process_ext_irq+0x78>
			return;
    1192:	bf00      	nop
    1194:	e000      	b.n	1198 <process_ext_irq+0x78>
			return;
    1196:	bf00      	nop
		}
	}
}
    1198:	3710      	adds	r7, #16
    119a:	46bd      	mov	sp, r7
    119c:	bd80      	pop	{r7, pc}
    119e:	bf00      	nop
    11a0:	20000510 	.word	0x20000510

000011a4 <i2c_m_sync_read>:

/**
 * \brief Sync version of I2C I/O read
 */
static int32_t i2c_m_sync_read(struct io_descriptor *io, uint8_t *buf, const uint16_t n)
{
    11a4:	b580      	push	{r7, lr}
    11a6:	b08a      	sub	sp, #40	; 0x28
    11a8:	af00      	add	r7, sp, #0
    11aa:	60f8      	str	r0, [r7, #12]
    11ac:	60b9      	str	r1, [r7, #8]
    11ae:	4613      	mov	r3, r2
    11b0:	80fb      	strh	r3, [r7, #6]
	struct i2c_m_sync_desc *i2c = CONTAINER_OF(io, struct i2c_m_sync_desc, io);
    11b2:	68fb      	ldr	r3, [r7, #12]
    11b4:	3b14      	subs	r3, #20
    11b6:	627b      	str	r3, [r7, #36]	; 0x24
	struct _i2c_m_msg       msg;
	int32_t                 ret;

	msg.addr   = i2c->slave_addr;
    11b8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    11ba:	8b9b      	ldrh	r3, [r3, #28]
    11bc:	82bb      	strh	r3, [r7, #20]
	msg.len    = n;
    11be:	88fb      	ldrh	r3, [r7, #6]
    11c0:	61bb      	str	r3, [r7, #24]
	msg.flags  = I2C_M_STOP | I2C_M_RD;
    11c2:	f248 0301 	movw	r3, #32769	; 0x8001
    11c6:	82fb      	strh	r3, [r7, #22]
	msg.buffer = buf;
    11c8:	68bb      	ldr	r3, [r7, #8]
    11ca:	61fb      	str	r3, [r7, #28]

	ret = _i2c_m_sync_transfer(&i2c->device, &msg);
    11cc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    11ce:	f107 0214 	add.w	r2, r7, #20
    11d2:	4611      	mov	r1, r2
    11d4:	4618      	mov	r0, r3
    11d6:	4b06      	ldr	r3, [pc, #24]	; (11f0 <i2c_m_sync_read+0x4c>)
    11d8:	4798      	blx	r3
    11da:	6238      	str	r0, [r7, #32]

	if (ret) {
    11dc:	6a3b      	ldr	r3, [r7, #32]
    11de:	2b00      	cmp	r3, #0
    11e0:	d001      	beq.n	11e6 <i2c_m_sync_read+0x42>
		return ret;
    11e2:	6a3b      	ldr	r3, [r7, #32]
    11e4:	e000      	b.n	11e8 <i2c_m_sync_read+0x44>
	}

	return n;
    11e6:	88fb      	ldrh	r3, [r7, #6]
}
    11e8:	4618      	mov	r0, r3
    11ea:	3728      	adds	r7, #40	; 0x28
    11ec:	46bd      	mov	sp, r7
    11ee:	bd80      	pop	{r7, pc}
    11f0:	000047fd 	.word	0x000047fd

000011f4 <i2c_m_sync_write>:

/**
 * \brief Sync version of I2C I/O write
 */
static int32_t i2c_m_sync_write(struct io_descriptor *io, const uint8_t *buf, const uint16_t n)
{
    11f4:	b580      	push	{r7, lr}
    11f6:	b08a      	sub	sp, #40	; 0x28
    11f8:	af00      	add	r7, sp, #0
    11fa:	60f8      	str	r0, [r7, #12]
    11fc:	60b9      	str	r1, [r7, #8]
    11fe:	4613      	mov	r3, r2
    1200:	80fb      	strh	r3, [r7, #6]
	struct i2c_m_sync_desc *i2c = CONTAINER_OF(io, struct i2c_m_sync_desc, io);
    1202:	68fb      	ldr	r3, [r7, #12]
    1204:	3b14      	subs	r3, #20
    1206:	627b      	str	r3, [r7, #36]	; 0x24
	struct _i2c_m_msg       msg;
	int32_t                 ret;

	msg.addr   = i2c->slave_addr;
    1208:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    120a:	8b9b      	ldrh	r3, [r3, #28]
    120c:	82bb      	strh	r3, [r7, #20]
	msg.len    = n;
    120e:	88fb      	ldrh	r3, [r7, #6]
    1210:	61bb      	str	r3, [r7, #24]
	msg.flags  = I2C_M_STOP;
    1212:	f44f 4300 	mov.w	r3, #32768	; 0x8000
    1216:	82fb      	strh	r3, [r7, #22]
	msg.buffer = (uint8_t *)buf;
    1218:	68bb      	ldr	r3, [r7, #8]
    121a:	61fb      	str	r3, [r7, #28]

	ret = _i2c_m_sync_transfer(&i2c->device, &msg);
    121c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    121e:	f107 0214 	add.w	r2, r7, #20
    1222:	4611      	mov	r1, r2
    1224:	4618      	mov	r0, r3
    1226:	4b06      	ldr	r3, [pc, #24]	; (1240 <i2c_m_sync_write+0x4c>)
    1228:	4798      	blx	r3
    122a:	6238      	str	r0, [r7, #32]

	if (ret) {
    122c:	6a3b      	ldr	r3, [r7, #32]
    122e:	2b00      	cmp	r3, #0
    1230:	d001      	beq.n	1236 <i2c_m_sync_write+0x42>
		return ret;
    1232:	6a3b      	ldr	r3, [r7, #32]
    1234:	e000      	b.n	1238 <i2c_m_sync_write+0x44>
	}

	return n;
    1236:	88fb      	ldrh	r3, [r7, #6]
}
    1238:	4618      	mov	r0, r3
    123a:	3728      	adds	r7, #40	; 0x28
    123c:	46bd      	mov	sp, r7
    123e:	bd80      	pop	{r7, pc}
    1240:	000047fd 	.word	0x000047fd

00001244 <i2c_m_sync_init>:

/**
 * \brief Sync version of i2c initialize
 */
int32_t i2c_m_sync_init(struct i2c_m_sync_desc *i2c, void *hw)
{
    1244:	b580      	push	{r7, lr}
    1246:	b084      	sub	sp, #16
    1248:	af00      	add	r7, sp, #0
    124a:	6078      	str	r0, [r7, #4]
    124c:	6039      	str	r1, [r7, #0]
	int32_t init_status;
	ASSERT(i2c);
    124e:	687b      	ldr	r3, [r7, #4]
    1250:	2b00      	cmp	r3, #0
    1252:	bf14      	ite	ne
    1254:	2301      	movne	r3, #1
    1256:	2300      	moveq	r3, #0
    1258:	b2db      	uxtb	r3, r3
    125a:	225e      	movs	r2, #94	; 0x5e
    125c:	490c      	ldr	r1, [pc, #48]	; (1290 <i2c_m_sync_init+0x4c>)
    125e:	4618      	mov	r0, r3
    1260:	4b0c      	ldr	r3, [pc, #48]	; (1294 <i2c_m_sync_init+0x50>)
    1262:	4798      	blx	r3

	init_status = _i2c_m_sync_init(&i2c->device, hw);
    1264:	687b      	ldr	r3, [r7, #4]
    1266:	6839      	ldr	r1, [r7, #0]
    1268:	4618      	mov	r0, r3
    126a:	4b0b      	ldr	r3, [pc, #44]	; (1298 <i2c_m_sync_init+0x54>)
    126c:	4798      	blx	r3
    126e:	60f8      	str	r0, [r7, #12]
	if (init_status) {
    1270:	68fb      	ldr	r3, [r7, #12]
    1272:	2b00      	cmp	r3, #0
    1274:	d001      	beq.n	127a <i2c_m_sync_init+0x36>
		return init_status;
    1276:	68fb      	ldr	r3, [r7, #12]
    1278:	e006      	b.n	1288 <i2c_m_sync_init+0x44>
	}

	/* Init I/O */
	i2c->io.read  = i2c_m_sync_read;
    127a:	687b      	ldr	r3, [r7, #4]
    127c:	4a07      	ldr	r2, [pc, #28]	; (129c <i2c_m_sync_init+0x58>)
    127e:	619a      	str	r2, [r3, #24]
	i2c->io.write = i2c_m_sync_write;
    1280:	687b      	ldr	r3, [r7, #4]
    1282:	4a07      	ldr	r2, [pc, #28]	; (12a0 <i2c_m_sync_init+0x5c>)
    1284:	615a      	str	r2, [r3, #20]

	return ERR_NONE;
    1286:	2300      	movs	r3, #0
}
    1288:	4618      	mov	r0, r3
    128a:	3710      	adds	r7, #16
    128c:	46bd      	mov	sp, r7
    128e:	bd80      	pop	{r7, pc}
    1290:	00005b1c 	.word	0x00005b1c
    1294:	00001849 	.word	0x00001849
    1298:	000045f9 	.word	0x000045f9
    129c:	000011a5 	.word	0x000011a5
    12a0:	000011f5 	.word	0x000011f5

000012a4 <i2c_m_sync_enable>:

/**
 * \brief Sync version of i2c enable
 */
int32_t i2c_m_sync_enable(struct i2c_m_sync_desc *i2c)
{
    12a4:	b580      	push	{r7, lr}
    12a6:	b082      	sub	sp, #8
    12a8:	af00      	add	r7, sp, #0
    12aa:	6078      	str	r0, [r7, #4]
	return _i2c_m_sync_enable(&i2c->device);
    12ac:	687b      	ldr	r3, [r7, #4]
    12ae:	4618      	mov	r0, r3
    12b0:	4b03      	ldr	r3, [pc, #12]	; (12c0 <i2c_m_sync_enable+0x1c>)
    12b2:	4798      	blx	r3
    12b4:	4603      	mov	r3, r0
}
    12b6:	4618      	mov	r0, r3
    12b8:	3708      	adds	r7, #8
    12ba:	46bd      	mov	sp, r7
    12bc:	bd80      	pop	{r7, pc}
    12be:	bf00      	nop
    12c0:	00004641 	.word	0x00004641

000012c4 <i2c_m_sync_set_slaveaddr>:

/**
 * \brief Sync version of i2c set slave address
 */
int32_t i2c_m_sync_set_slaveaddr(struct i2c_m_sync_desc *i2c, int16_t addr, int32_t addr_len)
{
    12c4:	b480      	push	{r7}
    12c6:	b085      	sub	sp, #20
    12c8:	af00      	add	r7, sp, #0
    12ca:	60f8      	str	r0, [r7, #12]
    12cc:	460b      	mov	r3, r1
    12ce:	607a      	str	r2, [r7, #4]
    12d0:	817b      	strh	r3, [r7, #10]
	return i2c->slave_addr = (addr & 0x3ff) | (addr_len & I2C_M_TEN);
    12d2:	897b      	ldrh	r3, [r7, #10]
    12d4:	f3c3 0309 	ubfx	r3, r3, #0, #10
    12d8:	b21a      	sxth	r2, r3
    12da:	687b      	ldr	r3, [r7, #4]
    12dc:	b21b      	sxth	r3, r3
    12de:	f403 6380 	and.w	r3, r3, #1024	; 0x400
    12e2:	b21b      	sxth	r3, r3
    12e4:	4313      	orrs	r3, r2
    12e6:	b21b      	sxth	r3, r3
    12e8:	b29a      	uxth	r2, r3
    12ea:	68fb      	ldr	r3, [r7, #12]
    12ec:	839a      	strh	r2, [r3, #28]
    12ee:	68fb      	ldr	r3, [r7, #12]
    12f0:	8b9b      	ldrh	r3, [r3, #28]
}
    12f2:	4618      	mov	r0, r3
    12f4:	3714      	adds	r7, #20
    12f6:	46bd      	mov	sp, r7
    12f8:	f85d 7b04 	ldr.w	r7, [sp], #4
    12fc:	4770      	bx	lr

000012fe <i2c_m_sync_get_io_descriptor>:

/**
 * \brief Retrieve I/O descriptor
 */
int32_t i2c_m_sync_get_io_descriptor(struct i2c_m_sync_desc *const i2c, struct io_descriptor **io)
{
    12fe:	b480      	push	{r7}
    1300:	b083      	sub	sp, #12
    1302:	af00      	add	r7, sp, #0
    1304:	6078      	str	r0, [r7, #4]
    1306:	6039      	str	r1, [r7, #0]
	*io = &i2c->io;
    1308:	687b      	ldr	r3, [r7, #4]
    130a:	f103 0214 	add.w	r2, r3, #20
    130e:	683b      	ldr	r3, [r7, #0]
    1310:	601a      	str	r2, [r3, #0]
	return ERR_NONE;
    1312:	2300      	movs	r3, #0
}
    1314:	4618      	mov	r0, r3
    1316:	370c      	adds	r7, #12
    1318:	46bd      	mov	sp, r7
    131a:	f85d 7b04 	ldr.w	r7, [sp], #4
    131e:	4770      	bx	lr

00001320 <io_write>:

/**
 * \brief I/O write interface
 */
int32_t io_write(struct io_descriptor *const io_descr, const uint8_t *const buf, const uint16_t length)
{
    1320:	b580      	push	{r7, lr}
    1322:	b084      	sub	sp, #16
    1324:	af00      	add	r7, sp, #0
    1326:	60f8      	str	r0, [r7, #12]
    1328:	60b9      	str	r1, [r7, #8]
    132a:	4613      	mov	r3, r2
    132c:	80fb      	strh	r3, [r7, #6]
	ASSERT(io_descr && buf);
    132e:	68fb      	ldr	r3, [r7, #12]
    1330:	2b00      	cmp	r3, #0
    1332:	d004      	beq.n	133e <io_write+0x1e>
    1334:	68bb      	ldr	r3, [r7, #8]
    1336:	2b00      	cmp	r3, #0
    1338:	d001      	beq.n	133e <io_write+0x1e>
    133a:	2301      	movs	r3, #1
    133c:	e000      	b.n	1340 <io_write+0x20>
    133e:	2300      	movs	r3, #0
    1340:	f003 0301 	and.w	r3, r3, #1
    1344:	b2db      	uxtb	r3, r3
    1346:	2234      	movs	r2, #52	; 0x34
    1348:	4907      	ldr	r1, [pc, #28]	; (1368 <io_write+0x48>)
    134a:	4618      	mov	r0, r3
    134c:	4b07      	ldr	r3, [pc, #28]	; (136c <io_write+0x4c>)
    134e:	4798      	blx	r3
	return io_descr->write(io_descr, buf, length);
    1350:	68fb      	ldr	r3, [r7, #12]
    1352:	681b      	ldr	r3, [r3, #0]
    1354:	88fa      	ldrh	r2, [r7, #6]
    1356:	68b9      	ldr	r1, [r7, #8]
    1358:	68f8      	ldr	r0, [r7, #12]
    135a:	4798      	blx	r3
    135c:	4603      	mov	r3, r0
}
    135e:	4618      	mov	r0, r3
    1360:	3710      	adds	r7, #16
    1362:	46bd      	mov	sp, r7
    1364:	bd80      	pop	{r7, pc}
    1366:	bf00      	nop
    1368:	00005b38 	.word	0x00005b38
    136c:	00001849 	.word	0x00001849

00001370 <io_read>:

/**
 * \brief I/O read interface
 */
int32_t io_read(struct io_descriptor *const io_descr, uint8_t *const buf, const uint16_t length)
{
    1370:	b580      	push	{r7, lr}
    1372:	b084      	sub	sp, #16
    1374:	af00      	add	r7, sp, #0
    1376:	60f8      	str	r0, [r7, #12]
    1378:	60b9      	str	r1, [r7, #8]
    137a:	4613      	mov	r3, r2
    137c:	80fb      	strh	r3, [r7, #6]
	ASSERT(io_descr && buf);
    137e:	68fb      	ldr	r3, [r7, #12]
    1380:	2b00      	cmp	r3, #0
    1382:	d004      	beq.n	138e <io_read+0x1e>
    1384:	68bb      	ldr	r3, [r7, #8]
    1386:	2b00      	cmp	r3, #0
    1388:	d001      	beq.n	138e <io_read+0x1e>
    138a:	2301      	movs	r3, #1
    138c:	e000      	b.n	1390 <io_read+0x20>
    138e:	2300      	movs	r3, #0
    1390:	f003 0301 	and.w	r3, r3, #1
    1394:	b2db      	uxtb	r3, r3
    1396:	223d      	movs	r2, #61	; 0x3d
    1398:	4907      	ldr	r1, [pc, #28]	; (13b8 <io_read+0x48>)
    139a:	4618      	mov	r0, r3
    139c:	4b07      	ldr	r3, [pc, #28]	; (13bc <io_read+0x4c>)
    139e:	4798      	blx	r3
	return io_descr->read(io_descr, buf, length);
    13a0:	68fb      	ldr	r3, [r7, #12]
    13a2:	685b      	ldr	r3, [r3, #4]
    13a4:	88fa      	ldrh	r2, [r7, #6]
    13a6:	68b9      	ldr	r1, [r7, #8]
    13a8:	68f8      	ldr	r0, [r7, #12]
    13aa:	4798      	blx	r3
    13ac:	4603      	mov	r3, r0
}
    13ae:	4618      	mov	r0, r3
    13b0:	3710      	adds	r7, #16
    13b2:	46bd      	mov	sp, r7
    13b4:	bd80      	pop	{r7, pc}
    13b6:	bf00      	nop
    13b8:	00005b38 	.word	0x00005b38
    13bc:	00001849 	.word	0x00001849

000013c0 <pwm_init>:

/**
 * \brief Initialize pwm
 */
int32_t pwm_init(struct pwm_descriptor *const descr, void *const hw, struct _pwm_hpl_interface *const func)
{
    13c0:	b580      	push	{r7, lr}
    13c2:	b084      	sub	sp, #16
    13c4:	af00      	add	r7, sp, #0
    13c6:	60f8      	str	r0, [r7, #12]
    13c8:	60b9      	str	r1, [r7, #8]
    13ca:	607a      	str	r2, [r7, #4]
	ASSERT(descr && hw);
    13cc:	68fb      	ldr	r3, [r7, #12]
    13ce:	2b00      	cmp	r3, #0
    13d0:	d004      	beq.n	13dc <pwm_init+0x1c>
    13d2:	68bb      	ldr	r3, [r7, #8]
    13d4:	2b00      	cmp	r3, #0
    13d6:	d001      	beq.n	13dc <pwm_init+0x1c>
    13d8:	2301      	movs	r3, #1
    13da:	e000      	b.n	13de <pwm_init+0x1e>
    13dc:	2300      	movs	r3, #0
    13de:	f003 0301 	and.w	r3, r3, #1
    13e2:	b2db      	uxtb	r3, r3
    13e4:	2233      	movs	r2, #51	; 0x33
    13e6:	490a      	ldr	r1, [pc, #40]	; (1410 <pwm_init+0x50>)
    13e8:	4618      	mov	r0, r3
    13ea:	4b0a      	ldr	r3, [pc, #40]	; (1414 <pwm_init+0x54>)
    13ec:	4798      	blx	r3
	_pwm_init(&descr->device, hw);
    13ee:	68fb      	ldr	r3, [r7, #12]
    13f0:	68b9      	ldr	r1, [r7, #8]
    13f2:	4618      	mov	r0, r3
    13f4:	4b08      	ldr	r3, [pc, #32]	; (1418 <pwm_init+0x58>)
    13f6:	4798      	blx	r3
	descr->device.callback.pwm_period_cb = pwm_period_expired;
    13f8:	68fb      	ldr	r3, [r7, #12]
    13fa:	4a08      	ldr	r2, [pc, #32]	; (141c <pwm_init+0x5c>)
    13fc:	601a      	str	r2, [r3, #0]
	descr->device.callback.pwm_error_cb  = pwm_detect_fault;
    13fe:	68fb      	ldr	r3, [r7, #12]
    1400:	4a07      	ldr	r2, [pc, #28]	; (1420 <pwm_init+0x60>)
    1402:	605a      	str	r2, [r3, #4]
	return ERR_NONE;
    1404:	2300      	movs	r3, #0
}
    1406:	4618      	mov	r0, r3
    1408:	3710      	adds	r7, #16
    140a:	46bd      	mov	sp, r7
    140c:	bd80      	pop	{r7, pc}
    140e:	bf00      	nop
    1410:	00005b4c 	.word	0x00005b4c
    1414:	00001849 	.word	0x00001849
    1418:	00004fe9 	.word	0x00004fe9
    141c:	000014bd 	.word	0x000014bd
    1420:	000014e1 	.word	0x000014e1

00001424 <pwm_enable>:

/**
 * \brief Start pwm
 */
int32_t pwm_enable(struct pwm_descriptor *const descr)
{
    1424:	b580      	push	{r7, lr}
    1426:	b082      	sub	sp, #8
    1428:	af00      	add	r7, sp, #0
    142a:	6078      	str	r0, [r7, #4]
	ASSERT(descr);
    142c:	687b      	ldr	r3, [r7, #4]
    142e:	2b00      	cmp	r3, #0
    1430:	bf14      	ite	ne
    1432:	2301      	movne	r3, #1
    1434:	2300      	moveq	r3, #0
    1436:	b2db      	uxtb	r3, r3
    1438:	224a      	movs	r2, #74	; 0x4a
    143a:	490b      	ldr	r1, [pc, #44]	; (1468 <pwm_enable+0x44>)
    143c:	4618      	mov	r0, r3
    143e:	4b0b      	ldr	r3, [pc, #44]	; (146c <pwm_enable+0x48>)
    1440:	4798      	blx	r3
	if (_pwm_is_enabled(&descr->device)) {
    1442:	687b      	ldr	r3, [r7, #4]
    1444:	4618      	mov	r0, r3
    1446:	4b0a      	ldr	r3, [pc, #40]	; (1470 <pwm_enable+0x4c>)
    1448:	4798      	blx	r3
    144a:	4603      	mov	r3, r0
    144c:	2b00      	cmp	r3, #0
    144e:	d002      	beq.n	1456 <pwm_enable+0x32>
		return ERR_DENIED;
    1450:	f06f 0310 	mvn.w	r3, #16
    1454:	e004      	b.n	1460 <pwm_enable+0x3c>
	}
	_pwm_enable(&descr->device);
    1456:	687b      	ldr	r3, [r7, #4]
    1458:	4618      	mov	r0, r3
    145a:	4b06      	ldr	r3, [pc, #24]	; (1474 <pwm_enable+0x50>)
    145c:	4798      	blx	r3

	return ERR_NONE;
    145e:	2300      	movs	r3, #0
}
    1460:	4618      	mov	r0, r3
    1462:	3708      	adds	r7, #8
    1464:	46bd      	mov	sp, r7
    1466:	bd80      	pop	{r7, pc}
    1468:	00005b4c 	.word	0x00005b4c
    146c:	00001849 	.word	0x00001849
    1470:	00005261 	.word	0x00005261
    1474:	000051f5 	.word	0x000051f5

00001478 <pwm_set_parameters>:

/**
 * \brief Change PWM parameter
 */
int32_t pwm_set_parameters(struct pwm_descriptor *const descr, const pwm_period_t period, const pwm_period_t duty_cycle)
{
    1478:	b580      	push	{r7, lr}
    147a:	b084      	sub	sp, #16
    147c:	af00      	add	r7, sp, #0
    147e:	60f8      	str	r0, [r7, #12]
    1480:	60b9      	str	r1, [r7, #8]
    1482:	607a      	str	r2, [r7, #4]
	ASSERT(descr);
    1484:	68fb      	ldr	r3, [r7, #12]
    1486:	2b00      	cmp	r3, #0
    1488:	bf14      	ite	ne
    148a:	2301      	movne	r3, #1
    148c:	2300      	moveq	r3, #0
    148e:	b2db      	uxtb	r3, r3
    1490:	227c      	movs	r2, #124	; 0x7c
    1492:	4907      	ldr	r1, [pc, #28]	; (14b0 <pwm_set_parameters+0x38>)
    1494:	4618      	mov	r0, r3
    1496:	4b07      	ldr	r3, [pc, #28]	; (14b4 <pwm_set_parameters+0x3c>)
    1498:	4798      	blx	r3
	_pwm_set_param(&descr->device, period, duty_cycle);
    149a:	68fb      	ldr	r3, [r7, #12]
    149c:	687a      	ldr	r2, [r7, #4]
    149e:	68b9      	ldr	r1, [r7, #8]
    14a0:	4618      	mov	r0, r3
    14a2:	4b05      	ldr	r3, [pc, #20]	; (14b8 <pwm_set_parameters+0x40>)
    14a4:	4798      	blx	r3
	return ERR_NONE;
    14a6:	2300      	movs	r3, #0
}
    14a8:	4618      	mov	r0, r3
    14aa:	3710      	adds	r7, #16
    14ac:	46bd      	mov	sp, r7
    14ae:	bd80      	pop	{r7, pc}
    14b0:	00005b4c 	.word	0x00005b4c
    14b4:	00001849 	.word	0x00001849
    14b8:	00005215 	.word	0x00005215

000014bc <pwm_period_expired>:

/**
 * \internal Process interrupts caused by period experied
 */
static void pwm_period_expired(struct _pwm_device *device)
{
    14bc:	b580      	push	{r7, lr}
    14be:	b084      	sub	sp, #16
    14c0:	af00      	add	r7, sp, #0
    14c2:	6078      	str	r0, [r7, #4]
	struct pwm_descriptor *const descr = CONTAINER_OF(device, struct pwm_descriptor, device);
    14c4:	687b      	ldr	r3, [r7, #4]
    14c6:	60fb      	str	r3, [r7, #12]

	if (descr->pwm_cb.period) {
    14c8:	68fb      	ldr	r3, [r7, #12]
    14ca:	695b      	ldr	r3, [r3, #20]
    14cc:	2b00      	cmp	r3, #0
    14ce:	d003      	beq.n	14d8 <pwm_period_expired+0x1c>
		descr->pwm_cb.period(descr);
    14d0:	68fb      	ldr	r3, [r7, #12]
    14d2:	695b      	ldr	r3, [r3, #20]
    14d4:	68f8      	ldr	r0, [r7, #12]
    14d6:	4798      	blx	r3
	}
}
    14d8:	bf00      	nop
    14da:	3710      	adds	r7, #16
    14dc:	46bd      	mov	sp, r7
    14de:	bd80      	pop	{r7, pc}

000014e0 <pwm_detect_fault>:

/**
 * \internal Process interrupts caused by pwm fault
 */
static void pwm_detect_fault(struct _pwm_device *device)
{
    14e0:	b580      	push	{r7, lr}
    14e2:	b084      	sub	sp, #16
    14e4:	af00      	add	r7, sp, #0
    14e6:	6078      	str	r0, [r7, #4]
	struct pwm_descriptor *const descr = CONTAINER_OF(device, struct pwm_descriptor, device);
    14e8:	687b      	ldr	r3, [r7, #4]
    14ea:	60fb      	str	r3, [r7, #12]

	if (descr->pwm_cb.error) {
    14ec:	68fb      	ldr	r3, [r7, #12]
    14ee:	699b      	ldr	r3, [r3, #24]
    14f0:	2b00      	cmp	r3, #0
    14f2:	d003      	beq.n	14fc <pwm_detect_fault+0x1c>
		descr->pwm_cb.error(descr);
    14f4:	68fb      	ldr	r3, [r7, #12]
    14f6:	699b      	ldr	r3, [r3, #24]
    14f8:	68f8      	ldr	r0, [r7, #12]
    14fa:	4798      	blx	r3
	}
}
    14fc:	bf00      	nop
    14fe:	3710      	adds	r7, #16
    1500:	46bd      	mov	sp, r7
    1502:	bd80      	pop	{r7, pc}

00001504 <usart_async_init>:
/**
 * \brief Initialize usart interface
 */
int32_t usart_async_init(struct usart_async_descriptor *const descr, void *const hw, uint8_t *rx_buffer,
                         uint16_t rx_buffer_length, void *const func)
{
    1504:	b580      	push	{r7, lr}
    1506:	b086      	sub	sp, #24
    1508:	af00      	add	r7, sp, #0
    150a:	60f8      	str	r0, [r7, #12]
    150c:	60b9      	str	r1, [r7, #8]
    150e:	607a      	str	r2, [r7, #4]
    1510:	807b      	strh	r3, [r7, #2]
	int32_t init_status;
	ASSERT(descr && hw && rx_buffer && rx_buffer_length);
    1512:	68fb      	ldr	r3, [r7, #12]
    1514:	2b00      	cmp	r3, #0
    1516:	d00a      	beq.n	152e <usart_async_init+0x2a>
    1518:	68bb      	ldr	r3, [r7, #8]
    151a:	2b00      	cmp	r3, #0
    151c:	d007      	beq.n	152e <usart_async_init+0x2a>
    151e:	687b      	ldr	r3, [r7, #4]
    1520:	2b00      	cmp	r3, #0
    1522:	d004      	beq.n	152e <usart_async_init+0x2a>
    1524:	887b      	ldrh	r3, [r7, #2]
    1526:	2b00      	cmp	r3, #0
    1528:	d001      	beq.n	152e <usart_async_init+0x2a>
    152a:	2301      	movs	r3, #1
    152c:	e000      	b.n	1530 <usart_async_init+0x2c>
    152e:	2300      	movs	r3, #0
    1530:	f003 0301 	and.w	r3, r3, #1
    1534:	b2db      	uxtb	r3, r3
    1536:	223a      	movs	r2, #58	; 0x3a
    1538:	4919      	ldr	r1, [pc, #100]	; (15a0 <usart_async_init+0x9c>)
    153a:	4618      	mov	r0, r3
    153c:	4b19      	ldr	r3, [pc, #100]	; (15a4 <usart_async_init+0xa0>)
    153e:	4798      	blx	r3

	if (ERR_NONE != ringbuffer_init(&descr->rx, rx_buffer, rx_buffer_length)) {
    1540:	68fb      	ldr	r3, [r7, #12]
    1542:	3334      	adds	r3, #52	; 0x34
    1544:	887a      	ldrh	r2, [r7, #2]
    1546:	6879      	ldr	r1, [r7, #4]
    1548:	4618      	mov	r0, r3
    154a:	4b17      	ldr	r3, [pc, #92]	; (15a8 <usart_async_init+0xa4>)
    154c:	4798      	blx	r3
    154e:	4603      	mov	r3, r0
    1550:	2b00      	cmp	r3, #0
    1552:	d002      	beq.n	155a <usart_async_init+0x56>
		return ERR_INVALID_ARG;
    1554:	f06f 030c 	mvn.w	r3, #12
    1558:	e01e      	b.n	1598 <usart_async_init+0x94>
	}
	init_status = _usart_async_init(&descr->device, hw);
    155a:	68fb      	ldr	r3, [r7, #12]
    155c:	3308      	adds	r3, #8
    155e:	68b9      	ldr	r1, [r7, #8]
    1560:	4618      	mov	r0, r3
    1562:	4b12      	ldr	r3, [pc, #72]	; (15ac <usart_async_init+0xa8>)
    1564:	4798      	blx	r3
    1566:	6178      	str	r0, [r7, #20]
	if (init_status) {
    1568:	697b      	ldr	r3, [r7, #20]
    156a:	2b00      	cmp	r3, #0
    156c:	d001      	beq.n	1572 <usart_async_init+0x6e>
		return init_status;
    156e:	697b      	ldr	r3, [r7, #20]
    1570:	e012      	b.n	1598 <usart_async_init+0x94>
	}

	descr->io.read  = usart_async_read;
    1572:	68fb      	ldr	r3, [r7, #12]
    1574:	4a0e      	ldr	r2, [pc, #56]	; (15b0 <usart_async_init+0xac>)
    1576:	605a      	str	r2, [r3, #4]
	descr->io.write = usart_async_write;
    1578:	68fb      	ldr	r3, [r7, #12]
    157a:	4a0e      	ldr	r2, [pc, #56]	; (15b4 <usart_async_init+0xb0>)
    157c:	601a      	str	r2, [r3, #0]

	descr->device.usart_cb.tx_byte_sent = usart_process_byte_sent;
    157e:	68fb      	ldr	r3, [r7, #12]
    1580:	4a0d      	ldr	r2, [pc, #52]	; (15b8 <usart_async_init+0xb4>)
    1582:	609a      	str	r2, [r3, #8]
	descr->device.usart_cb.rx_done_cb   = usart_fill_rx_buffer;
    1584:	68fb      	ldr	r3, [r7, #12]
    1586:	4a0d      	ldr	r2, [pc, #52]	; (15bc <usart_async_init+0xb8>)
    1588:	60da      	str	r2, [r3, #12]
	descr->device.usart_cb.tx_done_cb   = usart_transmission_complete;
    158a:	68fb      	ldr	r3, [r7, #12]
    158c:	4a0c      	ldr	r2, [pc, #48]	; (15c0 <usart_async_init+0xbc>)
    158e:	611a      	str	r2, [r3, #16]
	descr->device.usart_cb.error_cb     = usart_error;
    1590:	68fb      	ldr	r3, [r7, #12]
    1592:	4a0c      	ldr	r2, [pc, #48]	; (15c4 <usart_async_init+0xc0>)
    1594:	615a      	str	r2, [r3, #20]

	return ERR_NONE;
    1596:	2300      	movs	r3, #0
}
    1598:	4618      	mov	r0, r3
    159a:	3718      	adds	r7, #24
    159c:	46bd      	mov	sp, r7
    159e:	bd80      	pop	{r7, pc}
    15a0:	00005b64 	.word	0x00005b64
    15a4:	00001849 	.word	0x00001849
    15a8:	00001871 	.word	0x00001871
    15ac:	00003e21 	.word	0x00003e21
    15b0:	00001699 	.word	0x00001699
    15b4:	00001609 	.word	0x00001609
    15b8:	00001749 	.word	0x00001749
    15bc:	000017e1 	.word	0x000017e1
    15c0:	000017b5 	.word	0x000017b5
    15c4:	0000181d 	.word	0x0000181d

000015c8 <usart_async_enable>:

/**
 * \brief Enable usart interface
 */
int32_t usart_async_enable(struct usart_async_descriptor *const descr)
{
    15c8:	b580      	push	{r7, lr}
    15ca:	b082      	sub	sp, #8
    15cc:	af00      	add	r7, sp, #0
    15ce:	6078      	str	r0, [r7, #4]
	ASSERT(descr);
    15d0:	687b      	ldr	r3, [r7, #4]
    15d2:	2b00      	cmp	r3, #0
    15d4:	bf14      	ite	ne
    15d6:	2301      	movne	r3, #1
    15d8:	2300      	moveq	r3, #0
    15da:	b2db      	uxtb	r3, r3
    15dc:	2261      	movs	r2, #97	; 0x61
    15de:	4907      	ldr	r1, [pc, #28]	; (15fc <usart_async_enable+0x34>)
    15e0:	4618      	mov	r0, r3
    15e2:	4b07      	ldr	r3, [pc, #28]	; (1600 <usart_async_enable+0x38>)
    15e4:	4798      	blx	r3
	_usart_async_enable(&descr->device);
    15e6:	687b      	ldr	r3, [r7, #4]
    15e8:	3308      	adds	r3, #8
    15ea:	4618      	mov	r0, r3
    15ec:	4b05      	ldr	r3, [pc, #20]	; (1604 <usart_async_enable+0x3c>)
    15ee:	4798      	blx	r3

	return ERR_NONE;
    15f0:	2300      	movs	r3, #0
}
    15f2:	4618      	mov	r0, r3
    15f4:	3708      	adds	r7, #8
    15f6:	46bd      	mov	sp, r7
    15f8:	bd80      	pop	{r7, pc}
    15fa:	bf00      	nop
    15fc:	00005b64 	.word	0x00005b64
    1600:	00001849 	.word	0x00001849
    1604:	00003ecd 	.word	0x00003ecd

00001608 <usart_async_write>:
 * \param[in] length The number of bytes to write
 *
 * \return The number of bytes written.
 */
static int32_t usart_async_write(struct io_descriptor *const io_descr, const uint8_t *const buf, const uint16_t length)
{
    1608:	b580      	push	{r7, lr}
    160a:	b086      	sub	sp, #24
    160c:	af00      	add	r7, sp, #0
    160e:	60f8      	str	r0, [r7, #12]
    1610:	60b9      	str	r1, [r7, #8]
    1612:	4613      	mov	r3, r2
    1614:	80fb      	strh	r3, [r7, #6]
	struct usart_async_descriptor *descr = CONTAINER_OF(io_descr, struct usart_async_descriptor, io);
    1616:	68fb      	ldr	r3, [r7, #12]
    1618:	617b      	str	r3, [r7, #20]

	ASSERT(descr && buf && length);
    161a:	697b      	ldr	r3, [r7, #20]
    161c:	2b00      	cmp	r3, #0
    161e:	d007      	beq.n	1630 <usart_async_write+0x28>
    1620:	68bb      	ldr	r3, [r7, #8]
    1622:	2b00      	cmp	r3, #0
    1624:	d004      	beq.n	1630 <usart_async_write+0x28>
    1626:	88fb      	ldrh	r3, [r7, #6]
    1628:	2b00      	cmp	r3, #0
    162a:	d001      	beq.n	1630 <usart_async_write+0x28>
    162c:	2301      	movs	r3, #1
    162e:	e000      	b.n	1632 <usart_async_write+0x2a>
    1630:	2300      	movs	r3, #0
    1632:	f003 0301 	and.w	r3, r3, #1
    1636:	b2db      	uxtb	r3, r3
    1638:	f240 123b 	movw	r2, #315	; 0x13b
    163c:	4913      	ldr	r1, [pc, #76]	; (168c <usart_async_write+0x84>)
    163e:	4618      	mov	r0, r3
    1640:	4b13      	ldr	r3, [pc, #76]	; (1690 <usart_async_write+0x88>)
    1642:	4798      	blx	r3

	if (descr->tx_por != descr->tx_buffer_length) {
    1644:	697b      	ldr	r3, [r7, #20]
    1646:	f8b3 2044 	ldrh.w	r2, [r3, #68]	; 0x44
    164a:	697b      	ldr	r3, [r7, #20]
    164c:	f8b3 304c 	ldrh.w	r3, [r3, #76]	; 0x4c
    1650:	429a      	cmp	r2, r3
    1652:	d002      	beq.n	165a <usart_async_write+0x52>
		return ERR_NO_RESOURCE;
    1654:	f06f 031b 	mvn.w	r3, #27
    1658:	e013      	b.n	1682 <usart_async_write+0x7a>
	}
	descr->tx_buffer        = (uint8_t *)buf;
    165a:	697b      	ldr	r3, [r7, #20]
    165c:	68ba      	ldr	r2, [r7, #8]
    165e:	649a      	str	r2, [r3, #72]	; 0x48
	descr->tx_buffer_length = length;
    1660:	697b      	ldr	r3, [r7, #20]
    1662:	88fa      	ldrh	r2, [r7, #6]
    1664:	f8a3 204c 	strh.w	r2, [r3, #76]	; 0x4c
	descr->tx_por           = 0;
    1668:	697b      	ldr	r3, [r7, #20]
    166a:	2200      	movs	r2, #0
    166c:	f8a3 2044 	strh.w	r2, [r3, #68]	; 0x44
	descr->stat             = USART_ASYNC_STATUS_BUSY;
    1670:	697b      	ldr	r3, [r7, #20]
    1672:	2201      	movs	r2, #1
    1674:	631a      	str	r2, [r3, #48]	; 0x30
	_usart_async_enable_byte_sent_irq(&descr->device);
    1676:	697b      	ldr	r3, [r7, #20]
    1678:	3308      	adds	r3, #8
    167a:	4618      	mov	r0, r3
    167c:	4b05      	ldr	r3, [pc, #20]	; (1694 <usart_async_write+0x8c>)
    167e:	4798      	blx	r3

	return (int32_t)length;
    1680:	88fb      	ldrh	r3, [r7, #6]
}
    1682:	4618      	mov	r0, r3
    1684:	3718      	adds	r7, #24
    1686:	46bd      	mov	sp, r7
    1688:	bd80      	pop	{r7, pc}
    168a:	bf00      	nop
    168c:	00005b64 	.word	0x00005b64
    1690:	00001849 	.word	0x00001849
    1694:	00003f35 	.word	0x00003f35

00001698 <usart_async_read>:
 * \param[in] length The size of a buffer
 *
 * \return The number of bytes read.
 */
static int32_t usart_async_read(struct io_descriptor *const io_descr, uint8_t *const buf, const uint16_t length)
{
    1698:	b580      	push	{r7, lr}
    169a:	b088      	sub	sp, #32
    169c:	af00      	add	r7, sp, #0
    169e:	60f8      	str	r0, [r7, #12]
    16a0:	60b9      	str	r1, [r7, #8]
    16a2:	4613      	mov	r3, r2
    16a4:	80fb      	strh	r3, [r7, #6]
	uint16_t                       was_read = 0;
    16a6:	2300      	movs	r3, #0
    16a8:	83fb      	strh	r3, [r7, #30]
	uint32_t                       num;
	struct usart_async_descriptor *descr = CONTAINER_OF(io_descr, struct usart_async_descriptor, io);
    16aa:	68fb      	ldr	r3, [r7, #12]
    16ac:	61bb      	str	r3, [r7, #24]

	ASSERT(descr && buf && length);
    16ae:	69bb      	ldr	r3, [r7, #24]
    16b0:	2b00      	cmp	r3, #0
    16b2:	d007      	beq.n	16c4 <usart_async_read+0x2c>
    16b4:	68bb      	ldr	r3, [r7, #8]
    16b6:	2b00      	cmp	r3, #0
    16b8:	d004      	beq.n	16c4 <usart_async_read+0x2c>
    16ba:	88fb      	ldrh	r3, [r7, #6]
    16bc:	2b00      	cmp	r3, #0
    16be:	d001      	beq.n	16c4 <usart_async_read+0x2c>
    16c0:	2301      	movs	r3, #1
    16c2:	e000      	b.n	16c6 <usart_async_read+0x2e>
    16c4:	2300      	movs	r3, #0
    16c6:	f003 0301 	and.w	r3, r3, #1
    16ca:	b2db      	uxtb	r3, r3
    16cc:	f44f 72ac 	mov.w	r2, #344	; 0x158
    16d0:	4917      	ldr	r1, [pc, #92]	; (1730 <usart_async_read+0x98>)
    16d2:	4618      	mov	r0, r3
    16d4:	4b17      	ldr	r3, [pc, #92]	; (1734 <usart_async_read+0x9c>)
    16d6:	4798      	blx	r3

	CRITICAL_SECTION_ENTER()
    16d8:	f107 0310 	add.w	r3, r7, #16
    16dc:	4618      	mov	r0, r3
    16de:	4b16      	ldr	r3, [pc, #88]	; (1738 <usart_async_read+0xa0>)
    16e0:	4798      	blx	r3
	num = ringbuffer_num(&descr->rx);
    16e2:	69bb      	ldr	r3, [r7, #24]
    16e4:	3334      	adds	r3, #52	; 0x34
    16e6:	4618      	mov	r0, r3
    16e8:	4b14      	ldr	r3, [pc, #80]	; (173c <usart_async_read+0xa4>)
    16ea:	4798      	blx	r3
    16ec:	6178      	str	r0, [r7, #20]
	CRITICAL_SECTION_LEAVE()
    16ee:	f107 0310 	add.w	r3, r7, #16
    16f2:	4618      	mov	r0, r3
    16f4:	4b12      	ldr	r3, [pc, #72]	; (1740 <usart_async_read+0xa8>)
    16f6:	4798      	blx	r3

	while ((was_read < num) && (was_read < length)) {
    16f8:	e00c      	b.n	1714 <usart_async_read+0x7c>
		ringbuffer_get(&descr->rx, &buf[was_read++]);
    16fa:	69bb      	ldr	r3, [r7, #24]
    16fc:	f103 0234 	add.w	r2, r3, #52	; 0x34
    1700:	8bfb      	ldrh	r3, [r7, #30]
    1702:	1c59      	adds	r1, r3, #1
    1704:	83f9      	strh	r1, [r7, #30]
    1706:	4619      	mov	r1, r3
    1708:	68bb      	ldr	r3, [r7, #8]
    170a:	440b      	add	r3, r1
    170c:	4619      	mov	r1, r3
    170e:	4610      	mov	r0, r2
    1710:	4b0c      	ldr	r3, [pc, #48]	; (1744 <usart_async_read+0xac>)
    1712:	4798      	blx	r3
	while ((was_read < num) && (was_read < length)) {
    1714:	8bfa      	ldrh	r2, [r7, #30]
    1716:	697b      	ldr	r3, [r7, #20]
    1718:	429a      	cmp	r2, r3
    171a:	d203      	bcs.n	1724 <usart_async_read+0x8c>
    171c:	8bfa      	ldrh	r2, [r7, #30]
    171e:	88fb      	ldrh	r3, [r7, #6]
    1720:	429a      	cmp	r2, r3
    1722:	d3ea      	bcc.n	16fa <usart_async_read+0x62>
	}

	return (int32_t)was_read;
    1724:	8bfb      	ldrh	r3, [r7, #30]
}
    1726:	4618      	mov	r0, r3
    1728:	3720      	adds	r7, #32
    172a:	46bd      	mov	sp, r7
    172c:	bd80      	pop	{r7, pc}
    172e:	bf00      	nop
    1730:	00005b64 	.word	0x00005b64
    1734:	00001849 	.word	0x00001849
    1738:	00000ded 	.word	0x00000ded
    173c:	000019c9 	.word	0x000019c9
    1740:	00000e13 	.word	0x00000e13
    1744:	000018e5 	.word	0x000018e5

00001748 <usart_process_byte_sent>:
 * \brief Process "byte is sent" interrupt
 *
 * \param[in] device The pointer to device structure
 */
static void usart_process_byte_sent(struct _usart_async_device *device)
{
    1748:	b590      	push	{r4, r7, lr}
    174a:	b085      	sub	sp, #20
    174c:	af00      	add	r7, sp, #0
    174e:	6078      	str	r0, [r7, #4]
	struct usart_async_descriptor *descr = CONTAINER_OF(device, struct usart_async_descriptor, device);
    1750:	687b      	ldr	r3, [r7, #4]
    1752:	3b08      	subs	r3, #8
    1754:	60fb      	str	r3, [r7, #12]
	if (descr->tx_por != descr->tx_buffer_length) {
    1756:	68fb      	ldr	r3, [r7, #12]
    1758:	f8b3 2044 	ldrh.w	r2, [r3, #68]	; 0x44
    175c:	68fb      	ldr	r3, [r7, #12]
    175e:	f8b3 304c 	ldrh.w	r3, [r3, #76]	; 0x4c
    1762:	429a      	cmp	r2, r3
    1764:	d017      	beq.n	1796 <usart_process_byte_sent+0x4e>
		_usart_async_write_byte(&descr->device, descr->tx_buffer[descr->tx_por++]);
    1766:	68fb      	ldr	r3, [r7, #12]
    1768:	f103 0008 	add.w	r0, r3, #8
    176c:	68fb      	ldr	r3, [r7, #12]
    176e:	6c9a      	ldr	r2, [r3, #72]	; 0x48
    1770:	68fb      	ldr	r3, [r7, #12]
    1772:	f8b3 3044 	ldrh.w	r3, [r3, #68]	; 0x44
    1776:	1c59      	adds	r1, r3, #1
    1778:	b28c      	uxth	r4, r1
    177a:	68f9      	ldr	r1, [r7, #12]
    177c:	f8a1 4044 	strh.w	r4, [r1, #68]	; 0x44
    1780:	4413      	add	r3, r2
    1782:	781b      	ldrb	r3, [r3, #0]
    1784:	4619      	mov	r1, r3
    1786:	4b08      	ldr	r3, [pc, #32]	; (17a8 <usart_process_byte_sent+0x60>)
    1788:	4798      	blx	r3
		_usart_async_enable_byte_sent_irq(&descr->device);
    178a:	68fb      	ldr	r3, [r7, #12]
    178c:	3308      	adds	r3, #8
    178e:	4618      	mov	r0, r3
    1790:	4b06      	ldr	r3, [pc, #24]	; (17ac <usart_process_byte_sent+0x64>)
    1792:	4798      	blx	r3
	} else {
		_usart_async_enable_tx_done_irq(&descr->device);
	}
}
    1794:	e004      	b.n	17a0 <usart_process_byte_sent+0x58>
		_usart_async_enable_tx_done_irq(&descr->device);
    1796:	68fb      	ldr	r3, [r7, #12]
    1798:	3308      	adds	r3, #8
    179a:	4618      	mov	r0, r3
    179c:	4b04      	ldr	r3, [pc, #16]	; (17b0 <usart_process_byte_sent+0x68>)
    179e:	4798      	blx	r3
}
    17a0:	bf00      	nop
    17a2:	3714      	adds	r7, #20
    17a4:	46bd      	mov	sp, r7
    17a6:	bd90      	pop	{r4, r7, pc}
    17a8:	00003eed 	.word	0x00003eed
    17ac:	00003f35 	.word	0x00003f35
    17b0:	00003f55 	.word	0x00003f55

000017b4 <usart_transmission_complete>:
 * \brief Process completion of data sending
 *
 * \param[in] device The pointer to device structure
 */
static void usart_transmission_complete(struct _usart_async_device *device)
{
    17b4:	b580      	push	{r7, lr}
    17b6:	b084      	sub	sp, #16
    17b8:	af00      	add	r7, sp, #0
    17ba:	6078      	str	r0, [r7, #4]
	struct usart_async_descriptor *descr = CONTAINER_OF(device, struct usart_async_descriptor, device);
    17bc:	687b      	ldr	r3, [r7, #4]
    17be:	3b08      	subs	r3, #8
    17c0:	60fb      	str	r3, [r7, #12]

	descr->stat = 0;
    17c2:	68fb      	ldr	r3, [r7, #12]
    17c4:	2200      	movs	r2, #0
    17c6:	631a      	str	r2, [r3, #48]	; 0x30
	if (descr->usart_cb.tx_done) {
    17c8:	68fb      	ldr	r3, [r7, #12]
    17ca:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    17cc:	2b00      	cmp	r3, #0
    17ce:	d003      	beq.n	17d8 <usart_transmission_complete+0x24>
		descr->usart_cb.tx_done(descr);
    17d0:	68fb      	ldr	r3, [r7, #12]
    17d2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    17d4:	68f8      	ldr	r0, [r7, #12]
    17d6:	4798      	blx	r3
	}
}
    17d8:	bf00      	nop
    17da:	3710      	adds	r7, #16
    17dc:	46bd      	mov	sp, r7
    17de:	bd80      	pop	{r7, pc}

000017e0 <usart_fill_rx_buffer>:
 *
 * \param[in] device The pointer to device structure
 * \param[in] data Data read
 */
static void usart_fill_rx_buffer(struct _usart_async_device *device, uint8_t data)
{
    17e0:	b580      	push	{r7, lr}
    17e2:	b084      	sub	sp, #16
    17e4:	af00      	add	r7, sp, #0
    17e6:	6078      	str	r0, [r7, #4]
    17e8:	460b      	mov	r3, r1
    17ea:	70fb      	strb	r3, [r7, #3]
	struct usart_async_descriptor *descr = CONTAINER_OF(device, struct usart_async_descriptor, device);
    17ec:	687b      	ldr	r3, [r7, #4]
    17ee:	3b08      	subs	r3, #8
    17f0:	60fb      	str	r3, [r7, #12]

	ringbuffer_put(&descr->rx, data);
    17f2:	68fb      	ldr	r3, [r7, #12]
    17f4:	3334      	adds	r3, #52	; 0x34
    17f6:	78fa      	ldrb	r2, [r7, #3]
    17f8:	4611      	mov	r1, r2
    17fa:	4618      	mov	r0, r3
    17fc:	4b06      	ldr	r3, [pc, #24]	; (1818 <usart_fill_rx_buffer+0x38>)
    17fe:	4798      	blx	r3

	if (descr->usart_cb.rx_done) {
    1800:	68fb      	ldr	r3, [r7, #12]
    1802:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    1804:	2b00      	cmp	r3, #0
    1806:	d003      	beq.n	1810 <usart_fill_rx_buffer+0x30>
		descr->usart_cb.rx_done(descr);
    1808:	68fb      	ldr	r3, [r7, #12]
    180a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    180c:	68f8      	ldr	r0, [r7, #12]
    180e:	4798      	blx	r3
	}
}
    1810:	bf00      	nop
    1812:	3710      	adds	r7, #16
    1814:	46bd      	mov	sp, r7
    1816:	bd80      	pop	{r7, pc}
    1818:	00001955 	.word	0x00001955

0000181c <usart_error>:
 * \brief Process error interrupt
 *
 * \param[in] device The pointer to device structure
 */
static void usart_error(struct _usart_async_device *device)
{
    181c:	b580      	push	{r7, lr}
    181e:	b084      	sub	sp, #16
    1820:	af00      	add	r7, sp, #0
    1822:	6078      	str	r0, [r7, #4]
	struct usart_async_descriptor *descr = CONTAINER_OF(device, struct usart_async_descriptor, device);
    1824:	687b      	ldr	r3, [r7, #4]
    1826:	3b08      	subs	r3, #8
    1828:	60fb      	str	r3, [r7, #12]

	descr->stat = 0;
    182a:	68fb      	ldr	r3, [r7, #12]
    182c:	2200      	movs	r2, #0
    182e:	631a      	str	r2, [r3, #48]	; 0x30
	if (descr->usart_cb.error) {
    1830:	68fb      	ldr	r3, [r7, #12]
    1832:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    1834:	2b00      	cmp	r3, #0
    1836:	d003      	beq.n	1840 <usart_error+0x24>
		descr->usart_cb.error(descr);
    1838:	68fb      	ldr	r3, [r7, #12]
    183a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    183c:	68f8      	ldr	r0, [r7, #12]
    183e:	4798      	blx	r3
	}
}
    1840:	bf00      	nop
    1842:	3710      	adds	r7, #16
    1844:	46bd      	mov	sp, r7
    1846:	bd80      	pop	{r7, pc}

00001848 <assert>:

/**
 * \brief Assert function
 */
void assert(const bool condition, const char *const file, const int line)
{
    1848:	b480      	push	{r7}
    184a:	b085      	sub	sp, #20
    184c:	af00      	add	r7, sp, #0
    184e:	4603      	mov	r3, r0
    1850:	60b9      	str	r1, [r7, #8]
    1852:	607a      	str	r2, [r7, #4]
    1854:	73fb      	strb	r3, [r7, #15]
	if (!(condition)) {
    1856:	7bfb      	ldrb	r3, [r7, #15]
    1858:	f083 0301 	eor.w	r3, r3, #1
    185c:	b2db      	uxtb	r3, r3
    185e:	2b00      	cmp	r3, #0
    1860:	d000      	beq.n	1864 <assert+0x1c>
		__asm("BKPT #0");
    1862:	be00      	bkpt	0x0000
	}
	(void)file;
	(void)line;
}
    1864:	bf00      	nop
    1866:	3714      	adds	r7, #20
    1868:	46bd      	mov	sp, r7
    186a:	f85d 7b04 	ldr.w	r7, [sp], #4
    186e:	4770      	bx	lr

00001870 <ringbuffer_init>:

/**
 * \brief Ringbuffer init
 */
int32_t ringbuffer_init(struct ringbuffer *const rb, void *buf, uint32_t size)
{
    1870:	b580      	push	{r7, lr}
    1872:	b084      	sub	sp, #16
    1874:	af00      	add	r7, sp, #0
    1876:	60f8      	str	r0, [r7, #12]
    1878:	60b9      	str	r1, [r7, #8]
    187a:	607a      	str	r2, [r7, #4]
	ASSERT(rb && buf && size);
    187c:	68fb      	ldr	r3, [r7, #12]
    187e:	2b00      	cmp	r3, #0
    1880:	d007      	beq.n	1892 <ringbuffer_init+0x22>
    1882:	68bb      	ldr	r3, [r7, #8]
    1884:	2b00      	cmp	r3, #0
    1886:	d004      	beq.n	1892 <ringbuffer_init+0x22>
    1888:	687b      	ldr	r3, [r7, #4]
    188a:	2b00      	cmp	r3, #0
    188c:	d001      	beq.n	1892 <ringbuffer_init+0x22>
    188e:	2301      	movs	r3, #1
    1890:	e000      	b.n	1894 <ringbuffer_init+0x24>
    1892:	2300      	movs	r3, #0
    1894:	f003 0301 	and.w	r3, r3, #1
    1898:	b2db      	uxtb	r3, r3
    189a:	2228      	movs	r2, #40	; 0x28
    189c:	490f      	ldr	r1, [pc, #60]	; (18dc <ringbuffer_init+0x6c>)
    189e:	4618      	mov	r0, r3
    18a0:	4b0f      	ldr	r3, [pc, #60]	; (18e0 <ringbuffer_init+0x70>)
    18a2:	4798      	blx	r3

	/*
	 * buf size must be aligned to power of 2
	 */
	if ((size & (size - 1)) != 0) {
    18a4:	687b      	ldr	r3, [r7, #4]
    18a6:	1e5a      	subs	r2, r3, #1
    18a8:	687b      	ldr	r3, [r7, #4]
    18aa:	4013      	ands	r3, r2
    18ac:	2b00      	cmp	r3, #0
    18ae:	d002      	beq.n	18b6 <ringbuffer_init+0x46>
		return ERR_INVALID_ARG;
    18b0:	f06f 030c 	mvn.w	r3, #12
    18b4:	e00e      	b.n	18d4 <ringbuffer_init+0x64>
	}

	/* size - 1 is faster in calculation */
	rb->size        = size - 1;
    18b6:	687b      	ldr	r3, [r7, #4]
    18b8:	1e5a      	subs	r2, r3, #1
    18ba:	68fb      	ldr	r3, [r7, #12]
    18bc:	605a      	str	r2, [r3, #4]
	rb->read_index  = 0;
    18be:	68fb      	ldr	r3, [r7, #12]
    18c0:	2200      	movs	r2, #0
    18c2:	609a      	str	r2, [r3, #8]
	rb->write_index = rb->read_index;
    18c4:	68fb      	ldr	r3, [r7, #12]
    18c6:	689a      	ldr	r2, [r3, #8]
    18c8:	68fb      	ldr	r3, [r7, #12]
    18ca:	60da      	str	r2, [r3, #12]
	rb->buf         = (uint8_t *)buf;
    18cc:	68fb      	ldr	r3, [r7, #12]
    18ce:	68ba      	ldr	r2, [r7, #8]
    18d0:	601a      	str	r2, [r3, #0]

	return ERR_NONE;
    18d2:	2300      	movs	r3, #0
}
    18d4:	4618      	mov	r0, r3
    18d6:	3710      	adds	r7, #16
    18d8:	46bd      	mov	sp, r7
    18da:	bd80      	pop	{r7, pc}
    18dc:	00005b84 	.word	0x00005b84
    18e0:	00001849 	.word	0x00001849

000018e4 <ringbuffer_get>:
/**
 * \brief Get one byte from ringbuffer
 *
 */
int32_t ringbuffer_get(struct ringbuffer *const rb, uint8_t *data)
{
    18e4:	b580      	push	{r7, lr}
    18e6:	b082      	sub	sp, #8
    18e8:	af00      	add	r7, sp, #0
    18ea:	6078      	str	r0, [r7, #4]
    18ec:	6039      	str	r1, [r7, #0]
	ASSERT(rb && data);
    18ee:	687b      	ldr	r3, [r7, #4]
    18f0:	2b00      	cmp	r3, #0
    18f2:	d004      	beq.n	18fe <ringbuffer_get+0x1a>
    18f4:	683b      	ldr	r3, [r7, #0]
    18f6:	2b00      	cmp	r3, #0
    18f8:	d001      	beq.n	18fe <ringbuffer_get+0x1a>
    18fa:	2301      	movs	r3, #1
    18fc:	e000      	b.n	1900 <ringbuffer_get+0x1c>
    18fe:	2300      	movs	r3, #0
    1900:	f003 0301 	and.w	r3, r3, #1
    1904:	b2db      	uxtb	r3, r3
    1906:	2240      	movs	r2, #64	; 0x40
    1908:	4910      	ldr	r1, [pc, #64]	; (194c <ringbuffer_get+0x68>)
    190a:	4618      	mov	r0, r3
    190c:	4b10      	ldr	r3, [pc, #64]	; (1950 <ringbuffer_get+0x6c>)
    190e:	4798      	blx	r3

	if (rb->write_index != rb->read_index) {
    1910:	687b      	ldr	r3, [r7, #4]
    1912:	68da      	ldr	r2, [r3, #12]
    1914:	687b      	ldr	r3, [r7, #4]
    1916:	689b      	ldr	r3, [r3, #8]
    1918:	429a      	cmp	r2, r3
    191a:	d011      	beq.n	1940 <ringbuffer_get+0x5c>
		*data = rb->buf[rb->read_index & rb->size];
    191c:	687b      	ldr	r3, [r7, #4]
    191e:	681a      	ldr	r2, [r3, #0]
    1920:	687b      	ldr	r3, [r7, #4]
    1922:	6899      	ldr	r1, [r3, #8]
    1924:	687b      	ldr	r3, [r7, #4]
    1926:	685b      	ldr	r3, [r3, #4]
    1928:	400b      	ands	r3, r1
    192a:	4413      	add	r3, r2
    192c:	781a      	ldrb	r2, [r3, #0]
    192e:	683b      	ldr	r3, [r7, #0]
    1930:	701a      	strb	r2, [r3, #0]
		rb->read_index++;
    1932:	687b      	ldr	r3, [r7, #4]
    1934:	689b      	ldr	r3, [r3, #8]
    1936:	1c5a      	adds	r2, r3, #1
    1938:	687b      	ldr	r3, [r7, #4]
    193a:	609a      	str	r2, [r3, #8]
		return ERR_NONE;
    193c:	2300      	movs	r3, #0
    193e:	e001      	b.n	1944 <ringbuffer_get+0x60>
	}

	return ERR_NOT_FOUND;
    1940:	f06f 0309 	mvn.w	r3, #9
}
    1944:	4618      	mov	r0, r3
    1946:	3708      	adds	r7, #8
    1948:	46bd      	mov	sp, r7
    194a:	bd80      	pop	{r7, pc}
    194c:	00005b84 	.word	0x00005b84
    1950:	00001849 	.word	0x00001849

00001954 <ringbuffer_put>:
/**
 * \brief Put one byte to ringbuffer
 *
 */
int32_t ringbuffer_put(struct ringbuffer *const rb, uint8_t data)
{
    1954:	b580      	push	{r7, lr}
    1956:	b082      	sub	sp, #8
    1958:	af00      	add	r7, sp, #0
    195a:	6078      	str	r0, [r7, #4]
    195c:	460b      	mov	r3, r1
    195e:	70fb      	strb	r3, [r7, #3]
	ASSERT(rb);
    1960:	687b      	ldr	r3, [r7, #4]
    1962:	2b00      	cmp	r3, #0
    1964:	bf14      	ite	ne
    1966:	2301      	movne	r3, #1
    1968:	2300      	moveq	r3, #0
    196a:	b2db      	uxtb	r3, r3
    196c:	2251      	movs	r2, #81	; 0x51
    196e:	4914      	ldr	r1, [pc, #80]	; (19c0 <ringbuffer_put+0x6c>)
    1970:	4618      	mov	r0, r3
    1972:	4b14      	ldr	r3, [pc, #80]	; (19c4 <ringbuffer_put+0x70>)
    1974:	4798      	blx	r3

	rb->buf[rb->write_index & rb->size] = data;
    1976:	687b      	ldr	r3, [r7, #4]
    1978:	681a      	ldr	r2, [r3, #0]
    197a:	687b      	ldr	r3, [r7, #4]
    197c:	68d9      	ldr	r1, [r3, #12]
    197e:	687b      	ldr	r3, [r7, #4]
    1980:	685b      	ldr	r3, [r3, #4]
    1982:	400b      	ands	r3, r1
    1984:	4413      	add	r3, r2
    1986:	78fa      	ldrb	r2, [r7, #3]
    1988:	701a      	strb	r2, [r3, #0]

	/*
	 * buffer full strategy: new data will overwrite the oldest data in
	 * the buffer
	 */
	if ((rb->write_index - rb->read_index) > rb->size) {
    198a:	687b      	ldr	r3, [r7, #4]
    198c:	68da      	ldr	r2, [r3, #12]
    198e:	687b      	ldr	r3, [r7, #4]
    1990:	689b      	ldr	r3, [r3, #8]
    1992:	1ad2      	subs	r2, r2, r3
    1994:	687b      	ldr	r3, [r7, #4]
    1996:	685b      	ldr	r3, [r3, #4]
    1998:	429a      	cmp	r2, r3
    199a:	d906      	bls.n	19aa <ringbuffer_put+0x56>
		rb->read_index = rb->write_index - rb->size;
    199c:	687b      	ldr	r3, [r7, #4]
    199e:	68da      	ldr	r2, [r3, #12]
    19a0:	687b      	ldr	r3, [r7, #4]
    19a2:	685b      	ldr	r3, [r3, #4]
    19a4:	1ad2      	subs	r2, r2, r3
    19a6:	687b      	ldr	r3, [r7, #4]
    19a8:	609a      	str	r2, [r3, #8]
	}

	rb->write_index++;
    19aa:	687b      	ldr	r3, [r7, #4]
    19ac:	68db      	ldr	r3, [r3, #12]
    19ae:	1c5a      	adds	r2, r3, #1
    19b0:	687b      	ldr	r3, [r7, #4]
    19b2:	60da      	str	r2, [r3, #12]

	return ERR_NONE;
    19b4:	2300      	movs	r3, #0
}
    19b6:	4618      	mov	r0, r3
    19b8:	3708      	adds	r7, #8
    19ba:	46bd      	mov	sp, r7
    19bc:	bd80      	pop	{r7, pc}
    19be:	bf00      	nop
    19c0:	00005b84 	.word	0x00005b84
    19c4:	00001849 	.word	0x00001849

000019c8 <ringbuffer_num>:

/**
 * \brief Return the element number of ringbuffer
 */
uint32_t ringbuffer_num(const struct ringbuffer *const rb)
{
    19c8:	b580      	push	{r7, lr}
    19ca:	b082      	sub	sp, #8
    19cc:	af00      	add	r7, sp, #0
    19ce:	6078      	str	r0, [r7, #4]
	ASSERT(rb);
    19d0:	687b      	ldr	r3, [r7, #4]
    19d2:	2b00      	cmp	r3, #0
    19d4:	bf14      	ite	ne
    19d6:	2301      	movne	r3, #1
    19d8:	2300      	moveq	r3, #0
    19da:	b2db      	uxtb	r3, r3
    19dc:	2267      	movs	r2, #103	; 0x67
    19de:	4906      	ldr	r1, [pc, #24]	; (19f8 <ringbuffer_num+0x30>)
    19e0:	4618      	mov	r0, r3
    19e2:	4b06      	ldr	r3, [pc, #24]	; (19fc <ringbuffer_num+0x34>)
    19e4:	4798      	blx	r3

	return rb->write_index - rb->read_index;
    19e6:	687b      	ldr	r3, [r7, #4]
    19e8:	68da      	ldr	r2, [r3, #12]
    19ea:	687b      	ldr	r3, [r7, #4]
    19ec:	689b      	ldr	r3, [r3, #8]
    19ee:	1ad3      	subs	r3, r2, r3
}
    19f0:	4618      	mov	r0, r3
    19f2:	3708      	adds	r7, #8
    19f4:	46bd      	mov	sp, r7
    19f6:	bd80      	pop	{r7, pc}
    19f8:	00005b84 	.word	0x00005b84
    19fc:	00001849 	.word	0x00001849

00001a00 <_get_cycles_for_us_internal>:

/**
 * \brief Retrieve the amount of cycles to delay for the given amount of us
 */
static inline uint32_t _get_cycles_for_us_internal(const uint16_t us, const uint32_t freq, const uint8_t power)
{
    1a00:	b480      	push	{r7}
    1a02:	b083      	sub	sp, #12
    1a04:	af00      	add	r7, sp, #0
    1a06:	4603      	mov	r3, r0
    1a08:	6039      	str	r1, [r7, #0]
    1a0a:	80fb      	strh	r3, [r7, #6]
    1a0c:	4613      	mov	r3, r2
    1a0e:	717b      	strb	r3, [r7, #5]
	switch (power) {
    1a10:	797b      	ldrb	r3, [r7, #5]
    1a12:	3b04      	subs	r3, #4
    1a14:	2b05      	cmp	r3, #5
    1a16:	d865      	bhi.n	1ae4 <_get_cycles_for_us_internal+0xe4>
    1a18:	a201      	add	r2, pc, #4	; (adr r2, 1a20 <_get_cycles_for_us_internal+0x20>)
    1a1a:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    1a1e:	bf00      	nop
    1a20:	00001ac5 	.word	0x00001ac5
    1a24:	00001aa7 	.word	0x00001aa7
    1a28:	00001a89 	.word	0x00001a89
    1a2c:	00001a6b 	.word	0x00001a6b
    1a30:	00001a4b 	.word	0x00001a4b
    1a34:	00001a39 	.word	0x00001a39
	case 9:
		return (us * (freq / 1000000) - 1) + 1;
    1a38:	88fb      	ldrh	r3, [r7, #6]
    1a3a:	683a      	ldr	r2, [r7, #0]
    1a3c:	4931      	ldr	r1, [pc, #196]	; (1b04 <_get_cycles_for_us_internal+0x104>)
    1a3e:	fba1 1202 	umull	r1, r2, r1, r2
    1a42:	0c92      	lsrs	r2, r2, #18
    1a44:	fb02 f303 	mul.w	r3, r2, r3
    1a48:	e056      	b.n	1af8 <_get_cycles_for_us_internal+0xf8>
	case 8:
		return (us * (freq / 100000) - 1) / 10 + 1;
    1a4a:	88fb      	ldrh	r3, [r7, #6]
    1a4c:	683a      	ldr	r2, [r7, #0]
    1a4e:	0952      	lsrs	r2, r2, #5
    1a50:	492d      	ldr	r1, [pc, #180]	; (1b08 <_get_cycles_for_us_internal+0x108>)
    1a52:	fba1 1202 	umull	r1, r2, r1, r2
    1a56:	09d2      	lsrs	r2, r2, #7
    1a58:	fb02 f303 	mul.w	r3, r2, r3
    1a5c:	3b01      	subs	r3, #1
    1a5e:	4a2b      	ldr	r2, [pc, #172]	; (1b0c <_get_cycles_for_us_internal+0x10c>)
    1a60:	fba2 2303 	umull	r2, r3, r2, r3
    1a64:	08db      	lsrs	r3, r3, #3
    1a66:	3301      	adds	r3, #1
    1a68:	e046      	b.n	1af8 <_get_cycles_for_us_internal+0xf8>
	case 7:
		return (us * (freq / 10000) - 1) / 100 + 1;
    1a6a:	88fb      	ldrh	r3, [r7, #6]
    1a6c:	683a      	ldr	r2, [r7, #0]
    1a6e:	4928      	ldr	r1, [pc, #160]	; (1b10 <_get_cycles_for_us_internal+0x110>)
    1a70:	fba1 1202 	umull	r1, r2, r1, r2
    1a74:	0b52      	lsrs	r2, r2, #13
    1a76:	fb02 f303 	mul.w	r3, r2, r3
    1a7a:	3b01      	subs	r3, #1
    1a7c:	4a25      	ldr	r2, [pc, #148]	; (1b14 <_get_cycles_for_us_internal+0x114>)
    1a7e:	fba2 2303 	umull	r2, r3, r2, r3
    1a82:	095b      	lsrs	r3, r3, #5
    1a84:	3301      	adds	r3, #1
    1a86:	e037      	b.n	1af8 <_get_cycles_for_us_internal+0xf8>
	case 6:
		return (us * (freq / 1000) - 1) / 1000 + 1;
    1a88:	88fb      	ldrh	r3, [r7, #6]
    1a8a:	683a      	ldr	r2, [r7, #0]
    1a8c:	4922      	ldr	r1, [pc, #136]	; (1b18 <_get_cycles_for_us_internal+0x118>)
    1a8e:	fba1 1202 	umull	r1, r2, r1, r2
    1a92:	0992      	lsrs	r2, r2, #6
    1a94:	fb02 f303 	mul.w	r3, r2, r3
    1a98:	3b01      	subs	r3, #1
    1a9a:	4a1f      	ldr	r2, [pc, #124]	; (1b18 <_get_cycles_for_us_internal+0x118>)
    1a9c:	fba2 2303 	umull	r2, r3, r2, r3
    1aa0:	099b      	lsrs	r3, r3, #6
    1aa2:	3301      	adds	r3, #1
    1aa4:	e028      	b.n	1af8 <_get_cycles_for_us_internal+0xf8>
	case 5:
		return (us * (freq / 100) - 1) / 10000 + 1;
    1aa6:	88fb      	ldrh	r3, [r7, #6]
    1aa8:	683a      	ldr	r2, [r7, #0]
    1aaa:	491a      	ldr	r1, [pc, #104]	; (1b14 <_get_cycles_for_us_internal+0x114>)
    1aac:	fba1 1202 	umull	r1, r2, r1, r2
    1ab0:	0952      	lsrs	r2, r2, #5
    1ab2:	fb02 f303 	mul.w	r3, r2, r3
    1ab6:	3b01      	subs	r3, #1
    1ab8:	4a15      	ldr	r2, [pc, #84]	; (1b10 <_get_cycles_for_us_internal+0x110>)
    1aba:	fba2 2303 	umull	r2, r3, r2, r3
    1abe:	0b5b      	lsrs	r3, r3, #13
    1ac0:	3301      	adds	r3, #1
    1ac2:	e019      	b.n	1af8 <_get_cycles_for_us_internal+0xf8>
	case 4:
		return (us * (freq / 10) - 1) / 100000 + 1;
    1ac4:	88fb      	ldrh	r3, [r7, #6]
    1ac6:	683a      	ldr	r2, [r7, #0]
    1ac8:	4910      	ldr	r1, [pc, #64]	; (1b0c <_get_cycles_for_us_internal+0x10c>)
    1aca:	fba1 1202 	umull	r1, r2, r1, r2
    1ace:	08d2      	lsrs	r2, r2, #3
    1ad0:	fb02 f303 	mul.w	r3, r2, r3
    1ad4:	3b01      	subs	r3, #1
    1ad6:	095b      	lsrs	r3, r3, #5
    1ad8:	4a0b      	ldr	r2, [pc, #44]	; (1b08 <_get_cycles_for_us_internal+0x108>)
    1ada:	fba2 2303 	umull	r2, r3, r2, r3
    1ade:	09db      	lsrs	r3, r3, #7
    1ae0:	3301      	adds	r3, #1
    1ae2:	e009      	b.n	1af8 <_get_cycles_for_us_internal+0xf8>
	default:
		return (us * freq - 1) / 1000000 + 1;
    1ae4:	88fb      	ldrh	r3, [r7, #6]
    1ae6:	683a      	ldr	r2, [r7, #0]
    1ae8:	fb02 f303 	mul.w	r3, r2, r3
    1aec:	3b01      	subs	r3, #1
    1aee:	4a05      	ldr	r2, [pc, #20]	; (1b04 <_get_cycles_for_us_internal+0x104>)
    1af0:	fba2 2303 	umull	r2, r3, r2, r3
    1af4:	0c9b      	lsrs	r3, r3, #18
    1af6:	3301      	adds	r3, #1
	}
}
    1af8:	4618      	mov	r0, r3
    1afa:	370c      	adds	r7, #12
    1afc:	46bd      	mov	sp, r7
    1afe:	f85d 7b04 	ldr.w	r7, [sp], #4
    1b02:	4770      	bx	lr
    1b04:	431bde83 	.word	0x431bde83
    1b08:	0a7c5ac5 	.word	0x0a7c5ac5
    1b0c:	cccccccd 	.word	0xcccccccd
    1b10:	d1b71759 	.word	0xd1b71759
    1b14:	51eb851f 	.word	0x51eb851f
    1b18:	10624dd3 	.word	0x10624dd3

00001b1c <_get_cycles_for_us>:

/**
 * \brief Retrieve the amount of cycles to delay for the given amount of us
 */
uint32_t _get_cycles_for_us(const uint16_t us)
{
    1b1c:	b580      	push	{r7, lr}
    1b1e:	b082      	sub	sp, #8
    1b20:	af00      	add	r7, sp, #0
    1b22:	4603      	mov	r3, r0
    1b24:	80fb      	strh	r3, [r7, #6]
	return _get_cycles_for_us_internal(us, CONF_CPU_FREQUENCY, CPU_FREQ_POWER);
    1b26:	88fb      	ldrh	r3, [r7, #6]
    1b28:	2209      	movs	r2, #9
    1b2a:	4904      	ldr	r1, [pc, #16]	; (1b3c <_get_cycles_for_us+0x20>)
    1b2c:	4618      	mov	r0, r3
    1b2e:	4b04      	ldr	r3, [pc, #16]	; (1b40 <_get_cycles_for_us+0x24>)
    1b30:	4798      	blx	r3
    1b32:	4603      	mov	r3, r0
}
    1b34:	4618      	mov	r0, r3
    1b36:	3708      	adds	r7, #8
    1b38:	46bd      	mov	sp, r7
    1b3a:	bd80      	pop	{r7, pc}
    1b3c:	07270e00 	.word	0x07270e00
    1b40:	00001a01 	.word	0x00001a01

00001b44 <_get_cycles_for_ms_internal>:

/**
 * \brief Retrieve the amount of cycles to delay for the given amount of ms
 */
static inline uint32_t _get_cycles_for_ms_internal(const uint16_t ms, const uint32_t freq, const uint8_t power)
{
    1b44:	b480      	push	{r7}
    1b46:	b083      	sub	sp, #12
    1b48:	af00      	add	r7, sp, #0
    1b4a:	4603      	mov	r3, r0
    1b4c:	6039      	str	r1, [r7, #0]
    1b4e:	80fb      	strh	r3, [r7, #6]
    1b50:	4613      	mov	r3, r2
    1b52:	717b      	strb	r3, [r7, #5]
	switch (power) {
    1b54:	797b      	ldrb	r3, [r7, #5]
    1b56:	3b04      	subs	r3, #4
    1b58:	2b05      	cmp	r3, #5
    1b5a:	d85d      	bhi.n	1c18 <_get_cycles_for_ms_internal+0xd4>
    1b5c:	a201      	add	r2, pc, #4	; (adr r2, 1b64 <_get_cycles_for_ms_internal+0x20>)
    1b5e:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    1b62:	bf00      	nop
    1b64:	00001bfb 	.word	0x00001bfb
    1b68:	00001bdd 	.word	0x00001bdd
    1b6c:	00001bcb 	.word	0x00001bcb
    1b70:	00001bb1 	.word	0x00001bb1
    1b74:	00001b97 	.word	0x00001b97
    1b78:	00001b7d 	.word	0x00001b7d
	case 9:
		return (ms * (freq / 1000000)) * 1000;
    1b7c:	88fb      	ldrh	r3, [r7, #6]
    1b7e:	683a      	ldr	r2, [r7, #0]
    1b80:	492d      	ldr	r1, [pc, #180]	; (1c38 <_get_cycles_for_ms_internal+0xf4>)
    1b82:	fba1 1202 	umull	r1, r2, r1, r2
    1b86:	0c92      	lsrs	r2, r2, #18
    1b88:	fb02 f303 	mul.w	r3, r2, r3
    1b8c:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
    1b90:	fb02 f303 	mul.w	r3, r2, r3
    1b94:	e04a      	b.n	1c2c <_get_cycles_for_ms_internal+0xe8>
	case 8:
		return (ms * (freq / 100000)) * 100;
    1b96:	88fb      	ldrh	r3, [r7, #6]
    1b98:	683a      	ldr	r2, [r7, #0]
    1b9a:	0952      	lsrs	r2, r2, #5
    1b9c:	4927      	ldr	r1, [pc, #156]	; (1c3c <_get_cycles_for_ms_internal+0xf8>)
    1b9e:	fba1 1202 	umull	r1, r2, r1, r2
    1ba2:	09d2      	lsrs	r2, r2, #7
    1ba4:	fb02 f303 	mul.w	r3, r2, r3
    1ba8:	2264      	movs	r2, #100	; 0x64
    1baa:	fb02 f303 	mul.w	r3, r2, r3
    1bae:	e03d      	b.n	1c2c <_get_cycles_for_ms_internal+0xe8>
	case 7:
		return (ms * (freq / 10000)) * 10;
    1bb0:	88fb      	ldrh	r3, [r7, #6]
    1bb2:	683a      	ldr	r2, [r7, #0]
    1bb4:	4922      	ldr	r1, [pc, #136]	; (1c40 <_get_cycles_for_ms_internal+0xfc>)
    1bb6:	fba1 1202 	umull	r1, r2, r1, r2
    1bba:	0b52      	lsrs	r2, r2, #13
    1bbc:	fb02 f203 	mul.w	r2, r2, r3
    1bc0:	4613      	mov	r3, r2
    1bc2:	009b      	lsls	r3, r3, #2
    1bc4:	4413      	add	r3, r2
    1bc6:	005b      	lsls	r3, r3, #1
    1bc8:	e030      	b.n	1c2c <_get_cycles_for_ms_internal+0xe8>
	case 6:
		return (ms * (freq / 1000));
    1bca:	88fb      	ldrh	r3, [r7, #6]
    1bcc:	683a      	ldr	r2, [r7, #0]
    1bce:	491d      	ldr	r1, [pc, #116]	; (1c44 <_get_cycles_for_ms_internal+0x100>)
    1bd0:	fba1 1202 	umull	r1, r2, r1, r2
    1bd4:	0992      	lsrs	r2, r2, #6
    1bd6:	fb02 f303 	mul.w	r3, r2, r3
    1bda:	e027      	b.n	1c2c <_get_cycles_for_ms_internal+0xe8>
	case 5:
		return (ms * (freq / 100) - 1) / 10 + 1;
    1bdc:	88fb      	ldrh	r3, [r7, #6]
    1bde:	683a      	ldr	r2, [r7, #0]
    1be0:	4919      	ldr	r1, [pc, #100]	; (1c48 <_get_cycles_for_ms_internal+0x104>)
    1be2:	fba1 1202 	umull	r1, r2, r1, r2
    1be6:	0952      	lsrs	r2, r2, #5
    1be8:	fb02 f303 	mul.w	r3, r2, r3
    1bec:	3b01      	subs	r3, #1
    1bee:	4a17      	ldr	r2, [pc, #92]	; (1c4c <_get_cycles_for_ms_internal+0x108>)
    1bf0:	fba2 2303 	umull	r2, r3, r2, r3
    1bf4:	08db      	lsrs	r3, r3, #3
    1bf6:	3301      	adds	r3, #1
    1bf8:	e018      	b.n	1c2c <_get_cycles_for_ms_internal+0xe8>
	case 4:
		return (ms * (freq / 10) - 1) / 100 + 1;
    1bfa:	88fb      	ldrh	r3, [r7, #6]
    1bfc:	683a      	ldr	r2, [r7, #0]
    1bfe:	4913      	ldr	r1, [pc, #76]	; (1c4c <_get_cycles_for_ms_internal+0x108>)
    1c00:	fba1 1202 	umull	r1, r2, r1, r2
    1c04:	08d2      	lsrs	r2, r2, #3
    1c06:	fb02 f303 	mul.w	r3, r2, r3
    1c0a:	3b01      	subs	r3, #1
    1c0c:	4a0e      	ldr	r2, [pc, #56]	; (1c48 <_get_cycles_for_ms_internal+0x104>)
    1c0e:	fba2 2303 	umull	r2, r3, r2, r3
    1c12:	095b      	lsrs	r3, r3, #5
    1c14:	3301      	adds	r3, #1
    1c16:	e009      	b.n	1c2c <_get_cycles_for_ms_internal+0xe8>
	default:
		return (ms * freq - 1) / 1000 + 1;
    1c18:	88fb      	ldrh	r3, [r7, #6]
    1c1a:	683a      	ldr	r2, [r7, #0]
    1c1c:	fb02 f303 	mul.w	r3, r2, r3
    1c20:	3b01      	subs	r3, #1
    1c22:	4a08      	ldr	r2, [pc, #32]	; (1c44 <_get_cycles_for_ms_internal+0x100>)
    1c24:	fba2 2303 	umull	r2, r3, r2, r3
    1c28:	099b      	lsrs	r3, r3, #6
    1c2a:	3301      	adds	r3, #1
	}
}
    1c2c:	4618      	mov	r0, r3
    1c2e:	370c      	adds	r7, #12
    1c30:	46bd      	mov	sp, r7
    1c32:	f85d 7b04 	ldr.w	r7, [sp], #4
    1c36:	4770      	bx	lr
    1c38:	431bde83 	.word	0x431bde83
    1c3c:	0a7c5ac5 	.word	0x0a7c5ac5
    1c40:	d1b71759 	.word	0xd1b71759
    1c44:	10624dd3 	.word	0x10624dd3
    1c48:	51eb851f 	.word	0x51eb851f
    1c4c:	cccccccd 	.word	0xcccccccd

00001c50 <_get_cycles_for_ms>:

/**
 * \brief Retrieve the amount of cycles to delay for the given amount of ms
 */
uint32_t _get_cycles_for_ms(const uint16_t ms)
{
    1c50:	b580      	push	{r7, lr}
    1c52:	b082      	sub	sp, #8
    1c54:	af00      	add	r7, sp, #0
    1c56:	4603      	mov	r3, r0
    1c58:	80fb      	strh	r3, [r7, #6]
	return _get_cycles_for_ms_internal(ms, CONF_CPU_FREQUENCY, CPU_FREQ_POWER);
    1c5a:	88fb      	ldrh	r3, [r7, #6]
    1c5c:	2209      	movs	r2, #9
    1c5e:	4904      	ldr	r1, [pc, #16]	; (1c70 <_get_cycles_for_ms+0x20>)
    1c60:	4618      	mov	r0, r3
    1c62:	4b04      	ldr	r3, [pc, #16]	; (1c74 <_get_cycles_for_ms+0x24>)
    1c64:	4798      	blx	r3
    1c66:	4603      	mov	r3, r0
}
    1c68:	4618      	mov	r0, r3
    1c6a:	3708      	adds	r7, #8
    1c6c:	46bd      	mov	sp, r7
    1c6e:	bd80      	pop	{r7, pc}
    1c70:	07270e00 	.word	0x07270e00
    1c74:	00001b45 	.word	0x00001b45

00001c78 <hri_mclk_set_AHBMASK_DMAC_bit>:
{
    1c78:	b480      	push	{r7}
    1c7a:	b083      	sub	sp, #12
    1c7c:	af00      	add	r7, sp, #0
    1c7e:	6078      	str	r0, [r7, #4]
	((Mclk *)hw)->AHBMASK.reg |= MCLK_AHBMASK_DMAC;
    1c80:	687b      	ldr	r3, [r7, #4]
    1c82:	691b      	ldr	r3, [r3, #16]
    1c84:	f443 7200 	orr.w	r2, r3, #512	; 0x200
    1c88:	687b      	ldr	r3, [r7, #4]
    1c8a:	611a      	str	r2, [r3, #16]
}
    1c8c:	bf00      	nop
    1c8e:	370c      	adds	r7, #12
    1c90:	46bd      	mov	sp, r7
    1c92:	f85d 7b04 	ldr.w	r7, [sp], #4
    1c96:	4770      	bx	lr

00001c98 <hri_nvmctrl_set_CTRLA_RWS_bf>:
	tmp = (tmp & NVMCTRL_CTRLA_PRM_Msk) >> NVMCTRL_CTRLA_PRM_Pos;
	return tmp;
}

static inline void hri_nvmctrl_set_CTRLA_RWS_bf(const void *const hw, hri_nvmctrl_ctrla_reg_t mask)
{
    1c98:	b480      	push	{r7}
    1c9a:	b083      	sub	sp, #12
    1c9c:	af00      	add	r7, sp, #0
    1c9e:	6078      	str	r0, [r7, #4]
    1ca0:	460b      	mov	r3, r1
    1ca2:	807b      	strh	r3, [r7, #2]
	NVMCTRL_CRITICAL_SECTION_ENTER();
	((Nvmctrl *)hw)->CTRLA.reg |= NVMCTRL_CTRLA_RWS(mask);
    1ca4:	687b      	ldr	r3, [r7, #4]
    1ca6:	881b      	ldrh	r3, [r3, #0]
    1ca8:	b29a      	uxth	r2, r3
    1caa:	887b      	ldrh	r3, [r7, #2]
    1cac:	021b      	lsls	r3, r3, #8
    1cae:	b29b      	uxth	r3, r3
    1cb0:	f403 6370 	and.w	r3, r3, #3840	; 0xf00
    1cb4:	b29b      	uxth	r3, r3
    1cb6:	4313      	orrs	r3, r2
    1cb8:	b29a      	uxth	r2, r3
    1cba:	687b      	ldr	r3, [r7, #4]
    1cbc:	801a      	strh	r2, [r3, #0]
	NVMCTRL_CRITICAL_SECTION_LEAVE();
}
    1cbe:	bf00      	nop
    1cc0:	370c      	adds	r7, #12
    1cc2:	46bd      	mov	sp, r7
    1cc4:	f85d 7b04 	ldr.w	r7, [sp], #4
    1cc8:	4770      	bx	lr
	...

00001ccc <_init_chip>:

/**
 * \brief Initialize the hardware abstraction layer
 */
void _init_chip(void)
{
    1ccc:	b580      	push	{r7, lr}
    1cce:	af00      	add	r7, sp, #0
	hri_nvmctrl_set_CTRLA_RWS_bf(NVMCTRL, CONF_NVM_WAIT_STATE);
    1cd0:	2100      	movs	r1, #0
    1cd2:	480c      	ldr	r0, [pc, #48]	; (1d04 <_init_chip+0x38>)
    1cd4:	4b0c      	ldr	r3, [pc, #48]	; (1d08 <_init_chip+0x3c>)
    1cd6:	4798      	blx	r3

	_osc32kctrl_init_sources();
    1cd8:	4b0c      	ldr	r3, [pc, #48]	; (1d0c <_init_chip+0x40>)
    1cda:	4798      	blx	r3
	_oscctrl_init_sources();
    1cdc:	4b0c      	ldr	r3, [pc, #48]	; (1d10 <_init_chip+0x44>)
    1cde:	4798      	blx	r3
	_mclk_init();
    1ce0:	4b0c      	ldr	r3, [pc, #48]	; (1d14 <_init_chip+0x48>)
    1ce2:	4798      	blx	r3
#if _GCLK_INIT_1ST
	_gclk_init_generators_by_fref(_GCLK_INIT_1ST);
    1ce4:	2004      	movs	r0, #4
    1ce6:	4b0c      	ldr	r3, [pc, #48]	; (1d18 <_init_chip+0x4c>)
    1ce8:	4798      	blx	r3
#endif
	_oscctrl_init_referenced_generators();
    1cea:	4b0c      	ldr	r3, [pc, #48]	; (1d1c <_init_chip+0x50>)
    1cec:	4798      	blx	r3
	_gclk_init_generators_by_fref(_GCLK_INIT_LAST);
    1cee:	f640 70fb 	movw	r0, #4091	; 0xffb
    1cf2:	4b09      	ldr	r3, [pc, #36]	; (1d18 <_init_chip+0x4c>)
    1cf4:	4798      	blx	r3

#if CONF_DMAC_ENABLE
	hri_mclk_set_AHBMASK_DMAC_bit(MCLK);
    1cf6:	480a      	ldr	r0, [pc, #40]	; (1d20 <_init_chip+0x54>)
    1cf8:	4b0a      	ldr	r3, [pc, #40]	; (1d24 <_init_chip+0x58>)
    1cfa:	4798      	blx	r3
	_dma_init();
    1cfc:	4b0a      	ldr	r3, [pc, #40]	; (1d28 <_init_chip+0x5c>)
    1cfe:	4798      	blx	r3
#endif

#if CONF_CMCC_ENABLE
	cache_init();
#endif
}
    1d00:	bf00      	nop
    1d02:	bd80      	pop	{r7, pc}
    1d04:	41004000 	.word	0x41004000
    1d08:	00001c99 	.word	0x00001c99
    1d0c:	00003065 	.word	0x00003065
    1d10:	00003275 	.word	0x00003275
    1d14:	00002fe1 	.word	0x00002fe1
    1d18:	00002f49 	.word	0x00002f49
    1d1c:	000032b5 	.word	0x000032b5
    1d20:	40000800 	.word	0x40000800
    1d24:	00001c79 	.word	0x00001c79
    1d28:	0000232d 	.word	0x0000232d

00001d2c <__NVIC_EnableIRQ>:
  \details Enables a device specific interrupt in the NVIC interrupt controller.
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
{
    1d2c:	b480      	push	{r7}
    1d2e:	b083      	sub	sp, #12
    1d30:	af00      	add	r7, sp, #0
    1d32:	4603      	mov	r3, r0
    1d34:	80fb      	strh	r3, [r7, #6]
  if ((int32_t)(IRQn) >= 0)
    1d36:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
    1d3a:	2b00      	cmp	r3, #0
    1d3c:	db0b      	blt.n	1d56 <__NVIC_EnableIRQ+0x2a>
  {
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    1d3e:	4909      	ldr	r1, [pc, #36]	; (1d64 <__NVIC_EnableIRQ+0x38>)
    1d40:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
    1d44:	095b      	lsrs	r3, r3, #5
    1d46:	88fa      	ldrh	r2, [r7, #6]
    1d48:	f002 021f 	and.w	r2, r2, #31
    1d4c:	2001      	movs	r0, #1
    1d4e:	fa00 f202 	lsl.w	r2, r0, r2
    1d52:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  }
}
    1d56:	bf00      	nop
    1d58:	370c      	adds	r7, #12
    1d5a:	46bd      	mov	sp, r7
    1d5c:	f85d 7b04 	ldr.w	r7, [sp], #4
    1d60:	4770      	bx	lr
    1d62:	bf00      	nop
    1d64:	e000e100 	.word	0xe000e100

00001d68 <__NVIC_DisableIRQ>:
  \details Disables a device specific interrupt in the NVIC interrupt controller.
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_DisableIRQ(IRQn_Type IRQn)
{
    1d68:	b480      	push	{r7}
    1d6a:	b083      	sub	sp, #12
    1d6c:	af00      	add	r7, sp, #0
    1d6e:	4603      	mov	r3, r0
    1d70:	80fb      	strh	r3, [r7, #6]
  if ((int32_t)(IRQn) >= 0)
    1d72:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
    1d76:	2b00      	cmp	r3, #0
    1d78:	db10      	blt.n	1d9c <__NVIC_DisableIRQ+0x34>
  {
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    1d7a:	490b      	ldr	r1, [pc, #44]	; (1da8 <__NVIC_DisableIRQ+0x40>)
    1d7c:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
    1d80:	095b      	lsrs	r3, r3, #5
    1d82:	88fa      	ldrh	r2, [r7, #6]
    1d84:	f002 021f 	and.w	r2, r2, #31
    1d88:	2001      	movs	r0, #1
    1d8a:	fa00 f202 	lsl.w	r2, r0, r2
    1d8e:	3320      	adds	r3, #32
    1d90:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  __ASM volatile ("dsb 0xF":::"memory");
    1d94:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    1d98:	f3bf 8f6f 	isb	sy
    __DSB();
    __ISB();
  }
}
    1d9c:	bf00      	nop
    1d9e:	370c      	adds	r7, #12
    1da0:	46bd      	mov	sp, r7
    1da2:	f85d 7b04 	ldr.w	r7, [sp], #4
    1da6:	4770      	bx	lr
    1da8:	e000e100 	.word	0xe000e100

00001dac <__NVIC_ClearPendingIRQ>:
  \details Clears the pending bit of a device specific interrupt in the NVIC pending register.
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
    1dac:	b480      	push	{r7}
    1dae:	b083      	sub	sp, #12
    1db0:	af00      	add	r7, sp, #0
    1db2:	4603      	mov	r3, r0
    1db4:	80fb      	strh	r3, [r7, #6]
  if ((int32_t)(IRQn) >= 0)
    1db6:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
    1dba:	2b00      	cmp	r3, #0
    1dbc:	db0c      	blt.n	1dd8 <__NVIC_ClearPendingIRQ+0x2c>
  {
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    1dbe:	4909      	ldr	r1, [pc, #36]	; (1de4 <__NVIC_ClearPendingIRQ+0x38>)
    1dc0:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
    1dc4:	095b      	lsrs	r3, r3, #5
    1dc6:	88fa      	ldrh	r2, [r7, #6]
    1dc8:	f002 021f 	and.w	r2, r2, #31
    1dcc:	2001      	movs	r0, #1
    1dce:	fa00 f202 	lsl.w	r2, r0, r2
    1dd2:	3360      	adds	r3, #96	; 0x60
    1dd4:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  }
}
    1dd8:	bf00      	nop
    1dda:	370c      	adds	r7, #12
    1ddc:	46bd      	mov	sp, r7
    1dde:	f85d 7b04 	ldr.w	r7, [sp], #4
    1de2:	4770      	bx	lr
    1de4:	e000e100 	.word	0xe000e100

00001de8 <hri_dmac_set_CTRL_SWRST_bit>:
{
	return ((Dmac *)hw)->ACTIVE.reg;
}

static inline void hri_dmac_set_CTRL_SWRST_bit(const void *const hw)
{
    1de8:	b480      	push	{r7}
    1dea:	b083      	sub	sp, #12
    1dec:	af00      	add	r7, sp, #0
    1dee:	6078      	str	r0, [r7, #4]
	DMAC_CRITICAL_SECTION_ENTER();
	((Dmac *)hw)->CTRL.reg |= DMAC_CTRL_SWRST;
    1df0:	687b      	ldr	r3, [r7, #4]
    1df2:	881b      	ldrh	r3, [r3, #0]
    1df4:	b29b      	uxth	r3, r3
    1df6:	f043 0301 	orr.w	r3, r3, #1
    1dfa:	b29a      	uxth	r2, r3
    1dfc:	687b      	ldr	r3, [r7, #4]
    1dfe:	801a      	strh	r2, [r3, #0]
	DMAC_CRITICAL_SECTION_LEAVE();
}
    1e00:	bf00      	nop
    1e02:	370c      	adds	r7, #12
    1e04:	46bd      	mov	sp, r7
    1e06:	f85d 7b04 	ldr.w	r7, [sp], #4
    1e0a:	4770      	bx	lr

00001e0c <hri_dmac_get_CTRL_SWRST_bit>:

static inline bool hri_dmac_get_CTRL_SWRST_bit(const void *const hw)
{
    1e0c:	b480      	push	{r7}
    1e0e:	b085      	sub	sp, #20
    1e10:	af00      	add	r7, sp, #0
    1e12:	6078      	str	r0, [r7, #4]
	uint16_t tmp;
	tmp = ((Dmac *)hw)->CTRL.reg;
    1e14:	687b      	ldr	r3, [r7, #4]
    1e16:	881b      	ldrh	r3, [r3, #0]
    1e18:	81fb      	strh	r3, [r7, #14]
	tmp = (tmp & DMAC_CTRL_SWRST) >> DMAC_CTRL_SWRST_Pos;
    1e1a:	89fb      	ldrh	r3, [r7, #14]
    1e1c:	f003 0301 	and.w	r3, r3, #1
    1e20:	81fb      	strh	r3, [r7, #14]
	return (bool)tmp;
    1e22:	89fb      	ldrh	r3, [r7, #14]
    1e24:	2b00      	cmp	r3, #0
    1e26:	bf14      	ite	ne
    1e28:	2301      	movne	r3, #1
    1e2a:	2300      	moveq	r3, #0
    1e2c:	b2db      	uxtb	r3, r3
}
    1e2e:	4618      	mov	r0, r3
    1e30:	3714      	adds	r7, #20
    1e32:	46bd      	mov	sp, r7
    1e34:	f85d 7b04 	ldr.w	r7, [sp], #4
    1e38:	4770      	bx	lr

00001e3a <hri_dmac_set_CTRL_DMAENABLE_bit>:

static inline void hri_dmac_set_CTRL_DMAENABLE_bit(const void *const hw)
{
    1e3a:	b480      	push	{r7}
    1e3c:	b083      	sub	sp, #12
    1e3e:	af00      	add	r7, sp, #0
    1e40:	6078      	str	r0, [r7, #4]
	DMAC_CRITICAL_SECTION_ENTER();
	((Dmac *)hw)->CTRL.reg |= DMAC_CTRL_DMAENABLE;
    1e42:	687b      	ldr	r3, [r7, #4]
    1e44:	881b      	ldrh	r3, [r3, #0]
    1e46:	b29b      	uxth	r3, r3
    1e48:	f043 0302 	orr.w	r3, r3, #2
    1e4c:	b29a      	uxth	r2, r3
    1e4e:	687b      	ldr	r3, [r7, #4]
    1e50:	801a      	strh	r2, [r3, #0]
	DMAC_CRITICAL_SECTION_LEAVE();
}
    1e52:	bf00      	nop
    1e54:	370c      	adds	r7, #12
    1e56:	46bd      	mov	sp, r7
    1e58:	f85d 7b04 	ldr.w	r7, [sp], #4
    1e5c:	4770      	bx	lr

00001e5e <hri_dmac_clear_CTRL_DMAENABLE_bit>:
	((Dmac *)hw)->CTRL.reg = tmp;
	DMAC_CRITICAL_SECTION_LEAVE();
}

static inline void hri_dmac_clear_CTRL_DMAENABLE_bit(const void *const hw)
{
    1e5e:	b480      	push	{r7}
    1e60:	b083      	sub	sp, #12
    1e62:	af00      	add	r7, sp, #0
    1e64:	6078      	str	r0, [r7, #4]
	DMAC_CRITICAL_SECTION_ENTER();
	((Dmac *)hw)->CTRL.reg &= ~DMAC_CTRL_DMAENABLE;
    1e66:	687b      	ldr	r3, [r7, #4]
    1e68:	881b      	ldrh	r3, [r3, #0]
    1e6a:	b29b      	uxth	r3, r3
    1e6c:	f023 0302 	bic.w	r3, r3, #2
    1e70:	b29a      	uxth	r2, r3
    1e72:	687b      	ldr	r3, [r7, #4]
    1e74:	801a      	strh	r2, [r3, #0]
	DMAC_CRITICAL_SECTION_LEAVE();
}
    1e76:	bf00      	nop
    1e78:	370c      	adds	r7, #12
    1e7a:	46bd      	mov	sp, r7
    1e7c:	f85d 7b04 	ldr.w	r7, [sp], #4
    1e80:	4770      	bx	lr

00001e82 <hri_dmac_write_CTRL_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_dmac_write_CTRL_reg(const void *const hw, hri_dmac_ctrl_reg_t data)
{
    1e82:	b480      	push	{r7}
    1e84:	b083      	sub	sp, #12
    1e86:	af00      	add	r7, sp, #0
    1e88:	6078      	str	r0, [r7, #4]
    1e8a:	460b      	mov	r3, r1
    1e8c:	807b      	strh	r3, [r7, #2]
	DMAC_CRITICAL_SECTION_ENTER();
	((Dmac *)hw)->CTRL.reg = data;
    1e8e:	687b      	ldr	r3, [r7, #4]
    1e90:	887a      	ldrh	r2, [r7, #2]
    1e92:	801a      	strh	r2, [r3, #0]
	DMAC_CRITICAL_SECTION_LEAVE();
}
    1e94:	bf00      	nop
    1e96:	370c      	adds	r7, #12
    1e98:	46bd      	mov	sp, r7
    1e9a:	f85d 7b04 	ldr.w	r7, [sp], #4
    1e9e:	4770      	bx	lr

00001ea0 <hri_dmac_clear_CRCCTRL_reg>:
	((Dmac *)hw)->CRCCTRL.reg = data;
	DMAC_CRITICAL_SECTION_LEAVE();
}

static inline void hri_dmac_clear_CRCCTRL_reg(const void *const hw, hri_dmac_crcctrl_reg_t mask)
{
    1ea0:	b480      	push	{r7}
    1ea2:	b083      	sub	sp, #12
    1ea4:	af00      	add	r7, sp, #0
    1ea6:	6078      	str	r0, [r7, #4]
    1ea8:	460b      	mov	r3, r1
    1eaa:	807b      	strh	r3, [r7, #2]
	DMAC_CRITICAL_SECTION_ENTER();
	((Dmac *)hw)->CRCCTRL.reg &= ~mask;
    1eac:	687b      	ldr	r3, [r7, #4]
    1eae:	885b      	ldrh	r3, [r3, #2]
    1eb0:	b29b      	uxth	r3, r3
    1eb2:	b21a      	sxth	r2, r3
    1eb4:	f9b7 3002 	ldrsh.w	r3, [r7, #2]
    1eb8:	43db      	mvns	r3, r3
    1eba:	b21b      	sxth	r3, r3
    1ebc:	4013      	ands	r3, r2
    1ebe:	b21b      	sxth	r3, r3
    1ec0:	b29a      	uxth	r2, r3
    1ec2:	687b      	ldr	r3, [r7, #4]
    1ec4:	805a      	strh	r2, [r3, #2]
	DMAC_CRITICAL_SECTION_LEAVE();
}
    1ec6:	bf00      	nop
    1ec8:	370c      	adds	r7, #12
    1eca:	46bd      	mov	sp, r7
    1ecc:	f85d 7b04 	ldr.w	r7, [sp], #4
    1ed0:	4770      	bx	lr

00001ed2 <hri_dmac_write_DBGCTRL_DBGRUN_bit>:
	tmp = (tmp & DMAC_DBGCTRL_DBGRUN) >> DMAC_DBGCTRL_DBGRUN_Pos;
	return (bool)tmp;
}

static inline void hri_dmac_write_DBGCTRL_DBGRUN_bit(const void *const hw, bool value)
{
    1ed2:	b480      	push	{r7}
    1ed4:	b085      	sub	sp, #20
    1ed6:	af00      	add	r7, sp, #0
    1ed8:	6078      	str	r0, [r7, #4]
    1eda:	460b      	mov	r3, r1
    1edc:	70fb      	strb	r3, [r7, #3]
	uint8_t tmp;
	DMAC_CRITICAL_SECTION_ENTER();
	tmp = ((Dmac *)hw)->DBGCTRL.reg;
    1ede:	687b      	ldr	r3, [r7, #4]
    1ee0:	7b5b      	ldrb	r3, [r3, #13]
    1ee2:	73fb      	strb	r3, [r7, #15]
	tmp &= ~DMAC_DBGCTRL_DBGRUN;
    1ee4:	7bfb      	ldrb	r3, [r7, #15]
    1ee6:	f023 0301 	bic.w	r3, r3, #1
    1eea:	73fb      	strb	r3, [r7, #15]
	tmp |= value << DMAC_DBGCTRL_DBGRUN_Pos;
    1eec:	78fa      	ldrb	r2, [r7, #3]
    1eee:	7bfb      	ldrb	r3, [r7, #15]
    1ef0:	4313      	orrs	r3, r2
    1ef2:	73fb      	strb	r3, [r7, #15]
	((Dmac *)hw)->DBGCTRL.reg = tmp;
    1ef4:	687b      	ldr	r3, [r7, #4]
    1ef6:	7bfa      	ldrb	r2, [r7, #15]
    1ef8:	735a      	strb	r2, [r3, #13]
	DMAC_CRITICAL_SECTION_LEAVE();
}
    1efa:	bf00      	nop
    1efc:	3714      	adds	r7, #20
    1efe:	46bd      	mov	sp, r7
    1f00:	f85d 7b04 	ldr.w	r7, [sp], #4
    1f04:	4770      	bx	lr

00001f06 <hri_dmac_set_SWTRIGCTRL_reg>:
	((Dmac *)hw)->SWTRIGCTRL.reg ^= DMAC_SWTRIGCTRL_SWTRIG31;
	DMAC_CRITICAL_SECTION_LEAVE();
}

static inline void hri_dmac_set_SWTRIGCTRL_reg(const void *const hw, hri_dmac_swtrigctrl_reg_t mask)
{
    1f06:	b480      	push	{r7}
    1f08:	b083      	sub	sp, #12
    1f0a:	af00      	add	r7, sp, #0
    1f0c:	6078      	str	r0, [r7, #4]
    1f0e:	6039      	str	r1, [r7, #0]
	DMAC_CRITICAL_SECTION_ENTER();
	((Dmac *)hw)->SWTRIGCTRL.reg |= mask;
    1f10:	687b      	ldr	r3, [r7, #4]
    1f12:	691a      	ldr	r2, [r3, #16]
    1f14:	683b      	ldr	r3, [r7, #0]
    1f16:	431a      	orrs	r2, r3
    1f18:	687b      	ldr	r3, [r7, #4]
    1f1a:	611a      	str	r2, [r3, #16]
	DMAC_CRITICAL_SECTION_LEAVE();
}
    1f1c:	bf00      	nop
    1f1e:	370c      	adds	r7, #12
    1f20:	46bd      	mov	sp, r7
    1f22:	f85d 7b04 	ldr.w	r7, [sp], #4
    1f26:	4770      	bx	lr

00001f28 <hri_dmac_write_PRICTRL0_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_dmac_write_PRICTRL0_reg(const void *const hw, hri_dmac_prictrl0_reg_t data)
{
    1f28:	b480      	push	{r7}
    1f2a:	b083      	sub	sp, #12
    1f2c:	af00      	add	r7, sp, #0
    1f2e:	6078      	str	r0, [r7, #4]
    1f30:	6039      	str	r1, [r7, #0]
	DMAC_CRITICAL_SECTION_ENTER();
	((Dmac *)hw)->PRICTRL0.reg = data;
    1f32:	687b      	ldr	r3, [r7, #4]
    1f34:	683a      	ldr	r2, [r7, #0]
    1f36:	615a      	str	r2, [r3, #20]
	DMAC_CRITICAL_SECTION_LEAVE();
}
    1f38:	bf00      	nop
    1f3a:	370c      	adds	r7, #12
    1f3c:	46bd      	mov	sp, r7
    1f3e:	f85d 7b04 	ldr.w	r7, [sp], #4
    1f42:	4770      	bx	lr

00001f44 <hri_dmac_get_INTPEND_reg>:
	((Dmac *)hw)->INTPEND.reg |= mask;
	DMAC_CRITICAL_SECTION_LEAVE();
}

static inline hri_dmac_intpend_reg_t hri_dmac_get_INTPEND_reg(const void *const hw, hri_dmac_intpend_reg_t mask)
{
    1f44:	b480      	push	{r7}
    1f46:	b085      	sub	sp, #20
    1f48:	af00      	add	r7, sp, #0
    1f4a:	6078      	str	r0, [r7, #4]
    1f4c:	460b      	mov	r3, r1
    1f4e:	807b      	strh	r3, [r7, #2]
	uint16_t tmp;
	tmp = ((Dmac *)hw)->INTPEND.reg;
    1f50:	687b      	ldr	r3, [r7, #4]
    1f52:	8c1b      	ldrh	r3, [r3, #32]
    1f54:	81fb      	strh	r3, [r7, #14]
	tmp &= mask;
    1f56:	89fa      	ldrh	r2, [r7, #14]
    1f58:	887b      	ldrh	r3, [r7, #2]
    1f5a:	4013      	ands	r3, r2
    1f5c:	81fb      	strh	r3, [r7, #14]
	return tmp;
    1f5e:	89fb      	ldrh	r3, [r7, #14]
}
    1f60:	4618      	mov	r0, r3
    1f62:	3714      	adds	r7, #20
    1f64:	46bd      	mov	sp, r7
    1f66:	f85d 7b04 	ldr.w	r7, [sp], #4
    1f6a:	4770      	bx	lr

00001f6c <hri_dmac_write_BASEADDR_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_dmac_write_BASEADDR_reg(const void *const hw, hri_dmac_baseaddr_reg_t data)
{
    1f6c:	b480      	push	{r7}
    1f6e:	b083      	sub	sp, #12
    1f70:	af00      	add	r7, sp, #0
    1f72:	6078      	str	r0, [r7, #4]
    1f74:	6039      	str	r1, [r7, #0]
	DMAC_CRITICAL_SECTION_ENTER();
	((Dmac *)hw)->BASEADDR.reg = data;
    1f76:	687b      	ldr	r3, [r7, #4]
    1f78:	683a      	ldr	r2, [r7, #0]
    1f7a:	635a      	str	r2, [r3, #52]	; 0x34
	DMAC_CRITICAL_SECTION_LEAVE();
}
    1f7c:	bf00      	nop
    1f7e:	370c      	adds	r7, #12
    1f80:	46bd      	mov	sp, r7
    1f82:	f85d 7b04 	ldr.w	r7, [sp], #4
    1f86:	4770      	bx	lr

00001f88 <hri_dmac_write_WRBADDR_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_dmac_write_WRBADDR_reg(const void *const hw, hri_dmac_wrbaddr_reg_t data)
{
    1f88:	b480      	push	{r7}
    1f8a:	b083      	sub	sp, #12
    1f8c:	af00      	add	r7, sp, #0
    1f8e:	6078      	str	r0, [r7, #4]
    1f90:	6039      	str	r1, [r7, #0]
	DMAC_CRITICAL_SECTION_ENTER();
	((Dmac *)hw)->WRBADDR.reg = data;
    1f92:	687b      	ldr	r3, [r7, #4]
    1f94:	683a      	ldr	r2, [r7, #0]
    1f96:	639a      	str	r2, [r3, #56]	; 0x38
	DMAC_CRITICAL_SECTION_LEAVE();
}
    1f98:	bf00      	nop
    1f9a:	370c      	adds	r7, #12
    1f9c:	46bd      	mov	sp, r7
    1f9e:	f85d 7b04 	ldr.w	r7, [sp], #4
    1fa2:	4770      	bx	lr

00001fa4 <hri_dmacdescriptor_set_BTCTRL_VALID_bit>:
{
	return ((Dmac *)hw)->CRCSTATUS.reg;
}

static inline void hri_dmacdescriptor_set_BTCTRL_VALID_bit(const void *const hw)
{
    1fa4:	b480      	push	{r7}
    1fa6:	b083      	sub	sp, #12
    1fa8:	af00      	add	r7, sp, #0
    1faa:	6078      	str	r0, [r7, #4]
	DMAC_CRITICAL_SECTION_ENTER();
	((DmacDescriptor *)hw)->BTCTRL.reg |= DMAC_BTCTRL_VALID;
    1fac:	687b      	ldr	r3, [r7, #4]
    1fae:	881b      	ldrh	r3, [r3, #0]
    1fb0:	b29b      	uxth	r3, r3
    1fb2:	f043 0301 	orr.w	r3, r3, #1
    1fb6:	b29a      	uxth	r2, r3
    1fb8:	687b      	ldr	r3, [r7, #4]
    1fba:	801a      	strh	r2, [r3, #0]
	DMAC_CRITICAL_SECTION_LEAVE();
}
    1fbc:	bf00      	nop
    1fbe:	370c      	adds	r7, #12
    1fc0:	46bd      	mov	sp, r7
    1fc2:	f85d 7b04 	ldr.w	r7, [sp], #4
    1fc6:	4770      	bx	lr

00001fc8 <hri_dmacdescriptor_get_BTCTRL_SRCINC_bit>:
	((DmacDescriptor *)hw)->BTCTRL.reg |= DMAC_BTCTRL_SRCINC;
	DMAC_CRITICAL_SECTION_LEAVE();
}

static inline bool hri_dmacdescriptor_get_BTCTRL_SRCINC_bit(const void *const hw)
{
    1fc8:	b480      	push	{r7}
    1fca:	b085      	sub	sp, #20
    1fcc:	af00      	add	r7, sp, #0
    1fce:	6078      	str	r0, [r7, #4]
	uint16_t tmp;
	tmp = ((DmacDescriptor *)hw)->BTCTRL.reg;
    1fd0:	687b      	ldr	r3, [r7, #4]
    1fd2:	881b      	ldrh	r3, [r3, #0]
    1fd4:	81fb      	strh	r3, [r7, #14]
	tmp = (tmp & DMAC_BTCTRL_SRCINC) >> DMAC_BTCTRL_SRCINC_Pos;
    1fd6:	89fb      	ldrh	r3, [r7, #14]
    1fd8:	0a9b      	lsrs	r3, r3, #10
    1fda:	b29b      	uxth	r3, r3
    1fdc:	f003 0301 	and.w	r3, r3, #1
    1fe0:	81fb      	strh	r3, [r7, #14]
	return (bool)tmp;
    1fe2:	89fb      	ldrh	r3, [r7, #14]
    1fe4:	2b00      	cmp	r3, #0
    1fe6:	bf14      	ite	ne
    1fe8:	2301      	movne	r3, #1
    1fea:	2300      	moveq	r3, #0
    1fec:	b2db      	uxtb	r3, r3
}
    1fee:	4618      	mov	r0, r3
    1ff0:	3714      	adds	r7, #20
    1ff2:	46bd      	mov	sp, r7
    1ff4:	f85d 7b04 	ldr.w	r7, [sp], #4
    1ff8:	4770      	bx	lr

00001ffa <hri_dmacdescriptor_write_BTCTRL_SRCINC_bit>:

static inline void hri_dmacdescriptor_write_BTCTRL_SRCINC_bit(const void *const hw, bool value)
{
    1ffa:	b480      	push	{r7}
    1ffc:	b085      	sub	sp, #20
    1ffe:	af00      	add	r7, sp, #0
    2000:	6078      	str	r0, [r7, #4]
    2002:	460b      	mov	r3, r1
    2004:	70fb      	strb	r3, [r7, #3]
	uint16_t tmp;
	DMAC_CRITICAL_SECTION_ENTER();
	tmp = ((DmacDescriptor *)hw)->BTCTRL.reg;
    2006:	687b      	ldr	r3, [r7, #4]
    2008:	881b      	ldrh	r3, [r3, #0]
    200a:	81fb      	strh	r3, [r7, #14]
	tmp &= ~DMAC_BTCTRL_SRCINC;
    200c:	89fb      	ldrh	r3, [r7, #14]
    200e:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
    2012:	81fb      	strh	r3, [r7, #14]
	tmp |= value << DMAC_BTCTRL_SRCINC_Pos;
    2014:	78fb      	ldrb	r3, [r7, #3]
    2016:	029b      	lsls	r3, r3, #10
    2018:	b21a      	sxth	r2, r3
    201a:	f9b7 300e 	ldrsh.w	r3, [r7, #14]
    201e:	4313      	orrs	r3, r2
    2020:	b21b      	sxth	r3, r3
    2022:	81fb      	strh	r3, [r7, #14]
	((DmacDescriptor *)hw)->BTCTRL.reg = tmp;
    2024:	687b      	ldr	r3, [r7, #4]
    2026:	89fa      	ldrh	r2, [r7, #14]
    2028:	801a      	strh	r2, [r3, #0]
	DMAC_CRITICAL_SECTION_LEAVE();
}
    202a:	bf00      	nop
    202c:	3714      	adds	r7, #20
    202e:	46bd      	mov	sp, r7
    2030:	f85d 7b04 	ldr.w	r7, [sp], #4
    2034:	4770      	bx	lr

00002036 <hri_dmacdescriptor_get_BTCTRL_DSTINC_bit>:
	((DmacDescriptor *)hw)->BTCTRL.reg |= DMAC_BTCTRL_DSTINC;
	DMAC_CRITICAL_SECTION_LEAVE();
}

static inline bool hri_dmacdescriptor_get_BTCTRL_DSTINC_bit(const void *const hw)
{
    2036:	b480      	push	{r7}
    2038:	b085      	sub	sp, #20
    203a:	af00      	add	r7, sp, #0
    203c:	6078      	str	r0, [r7, #4]
	uint16_t tmp;
	tmp = ((DmacDescriptor *)hw)->BTCTRL.reg;
    203e:	687b      	ldr	r3, [r7, #4]
    2040:	881b      	ldrh	r3, [r3, #0]
    2042:	81fb      	strh	r3, [r7, #14]
	tmp = (tmp & DMAC_BTCTRL_DSTINC) >> DMAC_BTCTRL_DSTINC_Pos;
    2044:	89fb      	ldrh	r3, [r7, #14]
    2046:	0adb      	lsrs	r3, r3, #11
    2048:	b29b      	uxth	r3, r3
    204a:	f003 0301 	and.w	r3, r3, #1
    204e:	81fb      	strh	r3, [r7, #14]
	return (bool)tmp;
    2050:	89fb      	ldrh	r3, [r7, #14]
    2052:	2b00      	cmp	r3, #0
    2054:	bf14      	ite	ne
    2056:	2301      	movne	r3, #1
    2058:	2300      	moveq	r3, #0
    205a:	b2db      	uxtb	r3, r3
}
    205c:	4618      	mov	r0, r3
    205e:	3714      	adds	r7, #20
    2060:	46bd      	mov	sp, r7
    2062:	f85d 7b04 	ldr.w	r7, [sp], #4
    2066:	4770      	bx	lr

00002068 <hri_dmacdescriptor_read_BTCTRL_BEATSIZE_bf>:
	((DmacDescriptor *)hw)->BTCTRL.reg ^= DMAC_BTCTRL_BEATSIZE(mask);
	DMAC_CRITICAL_SECTION_LEAVE();
}

static inline hri_dmacdescriptor_btctrl_reg_t hri_dmacdescriptor_read_BTCTRL_BEATSIZE_bf(const void *const hw)
{
    2068:	b480      	push	{r7}
    206a:	b085      	sub	sp, #20
    206c:	af00      	add	r7, sp, #0
    206e:	6078      	str	r0, [r7, #4]
	uint16_t tmp;
	tmp = ((DmacDescriptor *)hw)->BTCTRL.reg;
    2070:	687b      	ldr	r3, [r7, #4]
    2072:	881b      	ldrh	r3, [r3, #0]
    2074:	81fb      	strh	r3, [r7, #14]
	tmp = (tmp & DMAC_BTCTRL_BEATSIZE_Msk) >> DMAC_BTCTRL_BEATSIZE_Pos;
    2076:	89fb      	ldrh	r3, [r7, #14]
    2078:	0a1b      	lsrs	r3, r3, #8
    207a:	b29b      	uxth	r3, r3
    207c:	f003 0303 	and.w	r3, r3, #3
    2080:	81fb      	strh	r3, [r7, #14]
	return tmp;
    2082:	89fb      	ldrh	r3, [r7, #14]
}
    2084:	4618      	mov	r0, r3
    2086:	3714      	adds	r7, #20
    2088:	46bd      	mov	sp, r7
    208a:	f85d 7b04 	ldr.w	r7, [sp], #4
    208e:	4770      	bx	lr

00002090 <hri_dmacdescriptor_write_BTCTRL_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_dmacdescriptor_write_BTCTRL_reg(const void *const hw, hri_dmacdescriptor_btctrl_reg_t data)
{
    2090:	b480      	push	{r7}
    2092:	b083      	sub	sp, #12
    2094:	af00      	add	r7, sp, #0
    2096:	6078      	str	r0, [r7, #4]
    2098:	460b      	mov	r3, r1
    209a:	807b      	strh	r3, [r7, #2]
	DMAC_CRITICAL_SECTION_ENTER();
	((DmacDescriptor *)hw)->BTCTRL.reg = data;
    209c:	687b      	ldr	r3, [r7, #4]
    209e:	887a      	ldrh	r2, [r7, #2]
    20a0:	801a      	strh	r2, [r3, #0]
	DMAC_CRITICAL_SECTION_LEAVE();
}
    20a2:	bf00      	nop
    20a4:	370c      	adds	r7, #12
    20a6:	46bd      	mov	sp, r7
    20a8:	f85d 7b04 	ldr.w	r7, [sp], #4
    20ac:	4770      	bx	lr

000020ae <hri_dmacdescriptor_write_BTCNT_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_dmacdescriptor_write_BTCNT_reg(const void *const hw, hri_dmacdescriptor_btcnt_reg_t data)
{
    20ae:	b480      	push	{r7}
    20b0:	b083      	sub	sp, #12
    20b2:	af00      	add	r7, sp, #0
    20b4:	6078      	str	r0, [r7, #4]
    20b6:	460b      	mov	r3, r1
    20b8:	807b      	strh	r3, [r7, #2]
	DMAC_CRITICAL_SECTION_ENTER();
	((DmacDescriptor *)hw)->BTCNT.reg = data;
    20ba:	687b      	ldr	r3, [r7, #4]
    20bc:	887a      	ldrh	r2, [r7, #2]
    20be:	805a      	strh	r2, [r3, #2]
	DMAC_CRITICAL_SECTION_LEAVE();
}
    20c0:	bf00      	nop
    20c2:	370c      	adds	r7, #12
    20c4:	46bd      	mov	sp, r7
    20c6:	f85d 7b04 	ldr.w	r7, [sp], #4
    20ca:	4770      	bx	lr

000020cc <hri_dmacdescriptor_write_SRCADDR_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_dmacdescriptor_write_SRCADDR_reg(const void *const hw, hri_dmacdescriptor_srcaddr_reg_t data)
{
    20cc:	b480      	push	{r7}
    20ce:	b083      	sub	sp, #12
    20d0:	af00      	add	r7, sp, #0
    20d2:	6078      	str	r0, [r7, #4]
    20d4:	6039      	str	r1, [r7, #0]
	DMAC_CRITICAL_SECTION_ENTER();
	((DmacDescriptor *)hw)->SRCADDR.reg = data;
    20d6:	687b      	ldr	r3, [r7, #4]
    20d8:	683a      	ldr	r2, [r7, #0]
    20da:	605a      	str	r2, [r3, #4]
	DMAC_CRITICAL_SECTION_LEAVE();
}
    20dc:	bf00      	nop
    20de:	370c      	adds	r7, #12
    20e0:	46bd      	mov	sp, r7
    20e2:	f85d 7b04 	ldr.w	r7, [sp], #4
    20e6:	4770      	bx	lr

000020e8 <hri_dmacdescriptor_read_SRCADDR_reg>:
	((DmacDescriptor *)hw)->SRCADDR.reg ^= mask;
	DMAC_CRITICAL_SECTION_LEAVE();
}

static inline hri_dmacdescriptor_srcaddr_reg_t hri_dmacdescriptor_read_SRCADDR_reg(const void *const hw)
{
    20e8:	b480      	push	{r7}
    20ea:	b083      	sub	sp, #12
    20ec:	af00      	add	r7, sp, #0
    20ee:	6078      	str	r0, [r7, #4]
	return ((DmacDescriptor *)hw)->SRCADDR.reg;
    20f0:	687b      	ldr	r3, [r7, #4]
    20f2:	685b      	ldr	r3, [r3, #4]
}
    20f4:	4618      	mov	r0, r3
    20f6:	370c      	adds	r7, #12
    20f8:	46bd      	mov	sp, r7
    20fa:	f85d 7b04 	ldr.w	r7, [sp], #4
    20fe:	4770      	bx	lr

00002100 <hri_dmacdescriptor_write_DSTADDR_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_dmacdescriptor_write_DSTADDR_reg(const void *const hw, hri_dmacdescriptor_dstaddr_reg_t data)
{
    2100:	b480      	push	{r7}
    2102:	b083      	sub	sp, #12
    2104:	af00      	add	r7, sp, #0
    2106:	6078      	str	r0, [r7, #4]
    2108:	6039      	str	r1, [r7, #0]
	DMAC_CRITICAL_SECTION_ENTER();
	((DmacDescriptor *)hw)->DSTADDR.reg = data;
    210a:	687b      	ldr	r3, [r7, #4]
    210c:	683a      	ldr	r2, [r7, #0]
    210e:	609a      	str	r2, [r3, #8]
	DMAC_CRITICAL_SECTION_LEAVE();
}
    2110:	bf00      	nop
    2112:	370c      	adds	r7, #12
    2114:	46bd      	mov	sp, r7
    2116:	f85d 7b04 	ldr.w	r7, [sp], #4
    211a:	4770      	bx	lr

0000211c <hri_dmacdescriptor_read_DSTADDR_reg>:
	((DmacDescriptor *)hw)->DSTADDR.reg ^= mask;
	DMAC_CRITICAL_SECTION_LEAVE();
}

static inline hri_dmacdescriptor_dstaddr_reg_t hri_dmacdescriptor_read_DSTADDR_reg(const void *const hw)
{
    211c:	b480      	push	{r7}
    211e:	b083      	sub	sp, #12
    2120:	af00      	add	r7, sp, #0
    2122:	6078      	str	r0, [r7, #4]
	return ((DmacDescriptor *)hw)->DSTADDR.reg;
    2124:	687b      	ldr	r3, [r7, #4]
    2126:	689b      	ldr	r3, [r3, #8]
}
    2128:	4618      	mov	r0, r3
    212a:	370c      	adds	r7, #12
    212c:	46bd      	mov	sp, r7
    212e:	f85d 7b04 	ldr.w	r7, [sp], #4
    2132:	4770      	bx	lr

00002134 <hri_dmac_get_CHINTFLAG_TERR_bit>:
{
	return ((DmacChannel *)hw)->CHSTATUS.reg;
}

static inline bool hri_dmac_get_CHINTFLAG_TERR_bit(const void *const hw, uint8_t submodule_index)
{
    2134:	b480      	push	{r7}
    2136:	b083      	sub	sp, #12
    2138:	af00      	add	r7, sp, #0
    213a:	6078      	str	r0, [r7, #4]
    213c:	460b      	mov	r3, r1
    213e:	70fb      	strb	r3, [r7, #3]
	return (((Dmac *)hw)->Channel[submodule_index].CHINTFLAG.reg & DMAC_CHINTFLAG_TERR) >> DMAC_CHINTFLAG_TERR_Pos;
    2140:	78fb      	ldrb	r3, [r7, #3]
    2142:	687a      	ldr	r2, [r7, #4]
    2144:	011b      	lsls	r3, r3, #4
    2146:	4413      	add	r3, r2
    2148:	334e      	adds	r3, #78	; 0x4e
    214a:	781b      	ldrb	r3, [r3, #0]
    214c:	b2db      	uxtb	r3, r3
    214e:	f003 0301 	and.w	r3, r3, #1
    2152:	2b00      	cmp	r3, #0
    2154:	bf14      	ite	ne
    2156:	2301      	movne	r3, #1
    2158:	2300      	moveq	r3, #0
    215a:	b2db      	uxtb	r3, r3
}
    215c:	4618      	mov	r0, r3
    215e:	370c      	adds	r7, #12
    2160:	46bd      	mov	sp, r7
    2162:	f85d 7b04 	ldr.w	r7, [sp], #4
    2166:	4770      	bx	lr

00002168 <hri_dmac_clear_CHINTFLAG_TERR_bit>:

static inline void hri_dmac_clear_CHINTFLAG_TERR_bit(const void *const hw, uint8_t submodule_index)
{
    2168:	b480      	push	{r7}
    216a:	b083      	sub	sp, #12
    216c:	af00      	add	r7, sp, #0
    216e:	6078      	str	r0, [r7, #4]
    2170:	460b      	mov	r3, r1
    2172:	70fb      	strb	r3, [r7, #3]
	((Dmac *)hw)->Channel[submodule_index].CHINTFLAG.reg = DMAC_CHINTFLAG_TERR;
    2174:	78fb      	ldrb	r3, [r7, #3]
    2176:	687a      	ldr	r2, [r7, #4]
    2178:	011b      	lsls	r3, r3, #4
    217a:	4413      	add	r3, r2
    217c:	334e      	adds	r3, #78	; 0x4e
    217e:	2201      	movs	r2, #1
    2180:	701a      	strb	r2, [r3, #0]
}
    2182:	bf00      	nop
    2184:	370c      	adds	r7, #12
    2186:	46bd      	mov	sp, r7
    2188:	f85d 7b04 	ldr.w	r7, [sp], #4
    218c:	4770      	bx	lr

0000218e <hri_dmac_get_CHINTFLAG_TCMPL_bit>:

static inline bool hri_dmac_get_CHINTFLAG_TCMPL_bit(const void *const hw, uint8_t submodule_index)
{
    218e:	b480      	push	{r7}
    2190:	b083      	sub	sp, #12
    2192:	af00      	add	r7, sp, #0
    2194:	6078      	str	r0, [r7, #4]
    2196:	460b      	mov	r3, r1
    2198:	70fb      	strb	r3, [r7, #3]
	return (((Dmac *)hw)->Channel[submodule_index].CHINTFLAG.reg & DMAC_CHINTFLAG_TCMPL) >> DMAC_CHINTFLAG_TCMPL_Pos;
    219a:	78fb      	ldrb	r3, [r7, #3]
    219c:	687a      	ldr	r2, [r7, #4]
    219e:	011b      	lsls	r3, r3, #4
    21a0:	4413      	add	r3, r2
    21a2:	334e      	adds	r3, #78	; 0x4e
    21a4:	781b      	ldrb	r3, [r3, #0]
    21a6:	b2db      	uxtb	r3, r3
    21a8:	085b      	lsrs	r3, r3, #1
    21aa:	f003 0301 	and.w	r3, r3, #1
    21ae:	2b00      	cmp	r3, #0
    21b0:	bf14      	ite	ne
    21b2:	2301      	movne	r3, #1
    21b4:	2300      	moveq	r3, #0
    21b6:	b2db      	uxtb	r3, r3
}
    21b8:	4618      	mov	r0, r3
    21ba:	370c      	adds	r7, #12
    21bc:	46bd      	mov	sp, r7
    21be:	f85d 7b04 	ldr.w	r7, [sp], #4
    21c2:	4770      	bx	lr

000021c4 <hri_dmac_clear_CHINTFLAG_TCMPL_bit>:

static inline void hri_dmac_clear_CHINTFLAG_TCMPL_bit(const void *const hw, uint8_t submodule_index)
{
    21c4:	b480      	push	{r7}
    21c6:	b083      	sub	sp, #12
    21c8:	af00      	add	r7, sp, #0
    21ca:	6078      	str	r0, [r7, #4]
    21cc:	460b      	mov	r3, r1
    21ce:	70fb      	strb	r3, [r7, #3]
	((Dmac *)hw)->Channel[submodule_index].CHINTFLAG.reg = DMAC_CHINTFLAG_TCMPL;
    21d0:	78fb      	ldrb	r3, [r7, #3]
    21d2:	687a      	ldr	r2, [r7, #4]
    21d4:	011b      	lsls	r3, r3, #4
    21d6:	4413      	add	r3, r2
    21d8:	334e      	adds	r3, #78	; 0x4e
    21da:	2202      	movs	r2, #2
    21dc:	701a      	strb	r2, [r3, #0]
}
    21de:	bf00      	nop
    21e0:	370c      	adds	r7, #12
    21e2:	46bd      	mov	sp, r7
    21e4:	f85d 7b04 	ldr.w	r7, [sp], #4
    21e8:	4770      	bx	lr

000021ea <hri_dmac_write_CHINTEN_TERR_bit>:
{
	return (((Dmac *)hw)->Channel[submodule_index].CHINTENSET.reg & DMAC_CHINTENSET_TERR) >> DMAC_CHINTENSET_TERR_Pos;
}

static inline void hri_dmac_write_CHINTEN_TERR_bit(const void *const hw, uint8_t submodule_index, bool value)
{
    21ea:	b480      	push	{r7}
    21ec:	b083      	sub	sp, #12
    21ee:	af00      	add	r7, sp, #0
    21f0:	6078      	str	r0, [r7, #4]
    21f2:	460b      	mov	r3, r1
    21f4:	70fb      	strb	r3, [r7, #3]
    21f6:	4613      	mov	r3, r2
    21f8:	70bb      	strb	r3, [r7, #2]
	if (value == 0x0) {
    21fa:	78bb      	ldrb	r3, [r7, #2]
    21fc:	f083 0301 	eor.w	r3, r3, #1
    2200:	b2db      	uxtb	r3, r3
    2202:	2b00      	cmp	r3, #0
    2204:	d007      	beq.n	2216 <hri_dmac_write_CHINTEN_TERR_bit+0x2c>
		((Dmac *)hw)->Channel[submodule_index].CHINTENCLR.reg = DMAC_CHINTENSET_TERR;
    2206:	78fb      	ldrb	r3, [r7, #3]
    2208:	687a      	ldr	r2, [r7, #4]
    220a:	011b      	lsls	r3, r3, #4
    220c:	4413      	add	r3, r2
    220e:	334c      	adds	r3, #76	; 0x4c
    2210:	2201      	movs	r2, #1
    2212:	701a      	strb	r2, [r3, #0]
	} else {
		((Dmac *)hw)->Channel[submodule_index].CHINTENSET.reg = DMAC_CHINTENSET_TERR;
	}
}
    2214:	e006      	b.n	2224 <hri_dmac_write_CHINTEN_TERR_bit+0x3a>
		((Dmac *)hw)->Channel[submodule_index].CHINTENSET.reg = DMAC_CHINTENSET_TERR;
    2216:	78fb      	ldrb	r3, [r7, #3]
    2218:	687a      	ldr	r2, [r7, #4]
    221a:	011b      	lsls	r3, r3, #4
    221c:	4413      	add	r3, r2
    221e:	334d      	adds	r3, #77	; 0x4d
    2220:	2201      	movs	r2, #1
    2222:	701a      	strb	r2, [r3, #0]
}
    2224:	bf00      	nop
    2226:	370c      	adds	r7, #12
    2228:	46bd      	mov	sp, r7
    222a:	f85d 7b04 	ldr.w	r7, [sp], #4
    222e:	4770      	bx	lr

00002230 <hri_dmac_write_CHINTEN_TCMPL_bit>:
{
	return (((Dmac *)hw)->Channel[submodule_index].CHINTENSET.reg & DMAC_CHINTENSET_TCMPL) >> DMAC_CHINTENSET_TCMPL_Pos;
}

static inline void hri_dmac_write_CHINTEN_TCMPL_bit(const void *const hw, uint8_t submodule_index, bool value)
{
    2230:	b480      	push	{r7}
    2232:	b083      	sub	sp, #12
    2234:	af00      	add	r7, sp, #0
    2236:	6078      	str	r0, [r7, #4]
    2238:	460b      	mov	r3, r1
    223a:	70fb      	strb	r3, [r7, #3]
    223c:	4613      	mov	r3, r2
    223e:	70bb      	strb	r3, [r7, #2]
	if (value == 0x0) {
    2240:	78bb      	ldrb	r3, [r7, #2]
    2242:	f083 0301 	eor.w	r3, r3, #1
    2246:	b2db      	uxtb	r3, r3
    2248:	2b00      	cmp	r3, #0
    224a:	d007      	beq.n	225c <hri_dmac_write_CHINTEN_TCMPL_bit+0x2c>
		((Dmac *)hw)->Channel[submodule_index].CHINTENCLR.reg = DMAC_CHINTENSET_TCMPL;
    224c:	78fb      	ldrb	r3, [r7, #3]
    224e:	687a      	ldr	r2, [r7, #4]
    2250:	011b      	lsls	r3, r3, #4
    2252:	4413      	add	r3, r2
    2254:	334c      	adds	r3, #76	; 0x4c
    2256:	2202      	movs	r2, #2
    2258:	701a      	strb	r2, [r3, #0]
	} else {
		((Dmac *)hw)->Channel[submodule_index].CHINTENSET.reg = DMAC_CHINTENSET_TCMPL;
	}
}
    225a:	e006      	b.n	226a <hri_dmac_write_CHINTEN_TCMPL_bit+0x3a>
		((Dmac *)hw)->Channel[submodule_index].CHINTENSET.reg = DMAC_CHINTENSET_TCMPL;
    225c:	78fb      	ldrb	r3, [r7, #3]
    225e:	687a      	ldr	r2, [r7, #4]
    2260:	011b      	lsls	r3, r3, #4
    2262:	4413      	add	r3, r2
    2264:	334d      	adds	r3, #77	; 0x4d
    2266:	2202      	movs	r2, #2
    2268:	701a      	strb	r2, [r3, #0]
}
    226a:	bf00      	nop
    226c:	370c      	adds	r7, #12
    226e:	46bd      	mov	sp, r7
    2270:	f85d 7b04 	ldr.w	r7, [sp], #4
    2274:	4770      	bx	lr

00002276 <hri_dmac_set_CHCTRLA_ENABLE_bit>:
	tmp = (tmp & DMAC_CHCTRLA_SWRST) >> DMAC_CHCTRLA_SWRST_Pos;
	return (bool)tmp;
}

static inline void hri_dmac_set_CHCTRLA_ENABLE_bit(const void *const hw, uint8_t submodule_index)
{
    2276:	b480      	push	{r7}
    2278:	b083      	sub	sp, #12
    227a:	af00      	add	r7, sp, #0
    227c:	6078      	str	r0, [r7, #4]
    227e:	460b      	mov	r3, r1
    2280:	70fb      	strb	r3, [r7, #3]
	DMAC_CRITICAL_SECTION_ENTER();
	((Dmac *)hw)->Channel[submodule_index].CHCTRLA.reg |= DMAC_CHCTRLA_ENABLE;
    2282:	78fb      	ldrb	r3, [r7, #3]
    2284:	78fa      	ldrb	r2, [r7, #3]
    2286:	6879      	ldr	r1, [r7, #4]
    2288:	3204      	adds	r2, #4
    228a:	0112      	lsls	r2, r2, #4
    228c:	440a      	add	r2, r1
    228e:	6812      	ldr	r2, [r2, #0]
    2290:	f042 0202 	orr.w	r2, r2, #2
    2294:	6879      	ldr	r1, [r7, #4]
    2296:	3304      	adds	r3, #4
    2298:	011b      	lsls	r3, r3, #4
    229a:	440b      	add	r3, r1
    229c:	601a      	str	r2, [r3, #0]
	DMAC_CRITICAL_SECTION_LEAVE();
}
    229e:	bf00      	nop
    22a0:	370c      	adds	r7, #12
    22a2:	46bd      	mov	sp, r7
    22a4:	f85d 7b04 	ldr.w	r7, [sp], #4
    22a8:	4770      	bx	lr

000022aa <hri_dmac_write_CHCTRLA_reg>:
	return tmp;
}

static inline void hri_dmac_write_CHCTRLA_reg(const void *const hw, uint8_t submodule_index,
                                              hri_dmac_chctrla_reg_t data)
{
    22aa:	b480      	push	{r7}
    22ac:	b085      	sub	sp, #20
    22ae:	af00      	add	r7, sp, #0
    22b0:	60f8      	str	r0, [r7, #12]
    22b2:	460b      	mov	r3, r1
    22b4:	607a      	str	r2, [r7, #4]
    22b6:	72fb      	strb	r3, [r7, #11]
	DMAC_CRITICAL_SECTION_ENTER();
	((Dmac *)hw)->Channel[submodule_index].CHCTRLA.reg = data;
    22b8:	7afb      	ldrb	r3, [r7, #11]
    22ba:	68fa      	ldr	r2, [r7, #12]
    22bc:	3304      	adds	r3, #4
    22be:	011b      	lsls	r3, r3, #4
    22c0:	4413      	add	r3, r2
    22c2:	687a      	ldr	r2, [r7, #4]
    22c4:	601a      	str	r2, [r3, #0]
	DMAC_CRITICAL_SECTION_LEAVE();
}
    22c6:	bf00      	nop
    22c8:	3714      	adds	r7, #20
    22ca:	46bd      	mov	sp, r7
    22cc:	f85d 7b04 	ldr.w	r7, [sp], #4
    22d0:	4770      	bx	lr

000022d2 <hri_dmac_write_CHPRILVL_reg>:
	return tmp;
}

static inline void hri_dmac_write_CHPRILVL_reg(const void *const hw, uint8_t submodule_index,
                                               hri_dmac_chprilvl_reg_t data)
{
    22d2:	b480      	push	{r7}
    22d4:	b083      	sub	sp, #12
    22d6:	af00      	add	r7, sp, #0
    22d8:	6078      	str	r0, [r7, #4]
    22da:	460b      	mov	r3, r1
    22dc:	70fb      	strb	r3, [r7, #3]
    22de:	4613      	mov	r3, r2
    22e0:	70bb      	strb	r3, [r7, #2]
	DMAC_CRITICAL_SECTION_ENTER();
	((Dmac *)hw)->Channel[submodule_index].CHPRILVL.reg = data;
    22e2:	78fb      	ldrb	r3, [r7, #3]
    22e4:	687a      	ldr	r2, [r7, #4]
    22e6:	3304      	adds	r3, #4
    22e8:	011b      	lsls	r3, r3, #4
    22ea:	4413      	add	r3, r2
    22ec:	3305      	adds	r3, #5
    22ee:	78ba      	ldrb	r2, [r7, #2]
    22f0:	701a      	strb	r2, [r3, #0]
	DMAC_CRITICAL_SECTION_LEAVE();
}
    22f2:	bf00      	nop
    22f4:	370c      	adds	r7, #12
    22f6:	46bd      	mov	sp, r7
    22f8:	f85d 7b04 	ldr.w	r7, [sp], #4
    22fc:	4770      	bx	lr

000022fe <hri_dmac_write_CHEVCTRL_reg>:
	return tmp;
}

static inline void hri_dmac_write_CHEVCTRL_reg(const void *const hw, uint8_t submodule_index,
                                               hri_dmac_chevctrl_reg_t data)
{
    22fe:	b480      	push	{r7}
    2300:	b083      	sub	sp, #12
    2302:	af00      	add	r7, sp, #0
    2304:	6078      	str	r0, [r7, #4]
    2306:	460b      	mov	r3, r1
    2308:	70fb      	strb	r3, [r7, #3]
    230a:	4613      	mov	r3, r2
    230c:	70bb      	strb	r3, [r7, #2]
	DMAC_CRITICAL_SECTION_ENTER();
	((Dmac *)hw)->Channel[submodule_index].CHEVCTRL.reg = data;
    230e:	78fb      	ldrb	r3, [r7, #3]
    2310:	687a      	ldr	r2, [r7, #4]
    2312:	3304      	adds	r3, #4
    2314:	011b      	lsls	r3, r3, #4
    2316:	4413      	add	r3, r2
    2318:	3306      	adds	r3, #6
    231a:	78ba      	ldrb	r2, [r7, #2]
    231c:	701a      	strb	r2, [r3, #0]
	DMAC_CRITICAL_SECTION_LEAVE();
}
    231e:	bf00      	nop
    2320:	370c      	adds	r7, #12
    2322:	46bd      	mov	sp, r7
    2324:	f85d 7b04 	ldr.w	r7, [sp], #4
    2328:	4770      	bx	lr
	...

0000232c <_dma_init>:

/**
 * \brief Initialize DMAC
 */
int32_t _dma_init(void)
{
    232c:	b580      	push	{r7, lr}
    232e:	b082      	sub	sp, #8
    2330:	af00      	add	r7, sp, #0
	uint8_t i;

	hri_dmac_clear_CTRL_DMAENABLE_bit(DMAC);
    2332:	4842      	ldr	r0, [pc, #264]	; (243c <_dma_init+0x110>)
    2334:	4b42      	ldr	r3, [pc, #264]	; (2440 <_dma_init+0x114>)
    2336:	4798      	blx	r3
	hri_dmac_clear_CRCCTRL_reg(DMAC, DMAC_CRCCTRL_CRCSRC_Msk);
    2338:	f44f 517c 	mov.w	r1, #16128	; 0x3f00
    233c:	483f      	ldr	r0, [pc, #252]	; (243c <_dma_init+0x110>)
    233e:	4b41      	ldr	r3, [pc, #260]	; (2444 <_dma_init+0x118>)
    2340:	4798      	blx	r3
	hri_dmac_set_CTRL_SWRST_bit(DMAC);
    2342:	483e      	ldr	r0, [pc, #248]	; (243c <_dma_init+0x110>)
    2344:	4b40      	ldr	r3, [pc, #256]	; (2448 <_dma_init+0x11c>)
    2346:	4798      	blx	r3
	while (hri_dmac_get_CTRL_SWRST_bit(DMAC))
    2348:	bf00      	nop
    234a:	483c      	ldr	r0, [pc, #240]	; (243c <_dma_init+0x110>)
    234c:	4b3f      	ldr	r3, [pc, #252]	; (244c <_dma_init+0x120>)
    234e:	4798      	blx	r3
    2350:	4603      	mov	r3, r0
    2352:	2b00      	cmp	r3, #0
    2354:	d1f9      	bne.n	234a <_dma_init+0x1e>
		;

	hri_dmac_write_CTRL_reg(DMAC,
    2356:	f44f 7180 	mov.w	r1, #256	; 0x100
    235a:	4838      	ldr	r0, [pc, #224]	; (243c <_dma_init+0x110>)
    235c:	4b3c      	ldr	r3, [pc, #240]	; (2450 <_dma_init+0x124>)
    235e:	4798      	blx	r3
	                        (CONF_DMAC_LVLEN0 << DMAC_CTRL_LVLEN0_Pos) | (CONF_DMAC_LVLEN1 << DMAC_CTRL_LVLEN1_Pos)
	                            | (CONF_DMAC_LVLEN2 << DMAC_CTRL_LVLEN2_Pos)
	                            | (CONF_DMAC_LVLEN3 << DMAC_CTRL_LVLEN3_Pos));
	hri_dmac_write_DBGCTRL_DBGRUN_bit(DMAC, CONF_DMAC_DBGRUN);
    2360:	2101      	movs	r1, #1
    2362:	4836      	ldr	r0, [pc, #216]	; (243c <_dma_init+0x110>)
    2364:	4b3b      	ldr	r3, [pc, #236]	; (2454 <_dma_init+0x128>)
    2366:	4798      	blx	r3

	hri_dmac_write_PRICTRL0_reg(DMAC,
    2368:	2100      	movs	r1, #0
    236a:	4834      	ldr	r0, [pc, #208]	; (243c <_dma_init+0x110>)
    236c:	4b3a      	ldr	r3, [pc, #232]	; (2458 <_dma_init+0x12c>)
    236e:	4798      	blx	r3
	                                | DMAC_PRICTRL0_LVLPRI3(CONF_DMAC_LVLPRI3)
	                                | (CONF_DMAC_RRLVLEN0 << DMAC_PRICTRL0_RRLVLEN0_Pos)
	                                | (CONF_DMAC_RRLVLEN1 << DMAC_PRICTRL0_RRLVLEN1_Pos)
	                                | (CONF_DMAC_RRLVLEN2 << DMAC_PRICTRL0_RRLVLEN2_Pos)
	                                | (CONF_DMAC_RRLVLEN3 << DMAC_PRICTRL0_RRLVLEN3_Pos));
	hri_dmac_write_BASEADDR_reg(DMAC, (uint32_t)_descriptor_section);
    2370:	4b3a      	ldr	r3, [pc, #232]	; (245c <_dma_init+0x130>)
    2372:	4619      	mov	r1, r3
    2374:	4831      	ldr	r0, [pc, #196]	; (243c <_dma_init+0x110>)
    2376:	4b3a      	ldr	r3, [pc, #232]	; (2460 <_dma_init+0x134>)
    2378:	4798      	blx	r3
	hri_dmac_write_WRBADDR_reg(DMAC, (uint32_t)_write_back_section);
    237a:	4b3a      	ldr	r3, [pc, #232]	; (2464 <_dma_init+0x138>)
    237c:	4619      	mov	r1, r3
    237e:	482f      	ldr	r0, [pc, #188]	; (243c <_dma_init+0x110>)
    2380:	4b39      	ldr	r3, [pc, #228]	; (2468 <_dma_init+0x13c>)
    2382:	4798      	blx	r3

	for (i = 0; i < DMAC_CH_NUM; i++) {
    2384:	2300      	movs	r3, #0
    2386:	71fb      	strb	r3, [r7, #7]
    2388:	e02b      	b.n	23e2 <_dma_init+0xb6>
		hri_dmac_write_CHCTRLA_reg(DMAC, i, _cfgs[i].ctrla);
    238a:	79fb      	ldrb	r3, [r7, #7]
    238c:	4a37      	ldr	r2, [pc, #220]	; (246c <_dma_init+0x140>)
    238e:	f852 2033 	ldr.w	r2, [r2, r3, lsl #3]
    2392:	79fb      	ldrb	r3, [r7, #7]
    2394:	4619      	mov	r1, r3
    2396:	4829      	ldr	r0, [pc, #164]	; (243c <_dma_init+0x110>)
    2398:	4b35      	ldr	r3, [pc, #212]	; (2470 <_dma_init+0x144>)
    239a:	4798      	blx	r3
		hri_dmac_write_CHPRILVL_reg(DMAC, i, _cfgs[i].prilvl);
    239c:	79fb      	ldrb	r3, [r7, #7]
    239e:	4a33      	ldr	r2, [pc, #204]	; (246c <_dma_init+0x140>)
    23a0:	00db      	lsls	r3, r3, #3
    23a2:	4413      	add	r3, r2
    23a4:	791a      	ldrb	r2, [r3, #4]
    23a6:	79fb      	ldrb	r3, [r7, #7]
    23a8:	4619      	mov	r1, r3
    23aa:	4824      	ldr	r0, [pc, #144]	; (243c <_dma_init+0x110>)
    23ac:	4b31      	ldr	r3, [pc, #196]	; (2474 <_dma_init+0x148>)
    23ae:	4798      	blx	r3
		hri_dmac_write_CHEVCTRL_reg(DMAC, i, _cfgs[i].evctrl);
    23b0:	79fb      	ldrb	r3, [r7, #7]
    23b2:	4a2e      	ldr	r2, [pc, #184]	; (246c <_dma_init+0x140>)
    23b4:	00db      	lsls	r3, r3, #3
    23b6:	4413      	add	r3, r2
    23b8:	795a      	ldrb	r2, [r3, #5]
    23ba:	79fb      	ldrb	r3, [r7, #7]
    23bc:	4619      	mov	r1, r3
    23be:	481f      	ldr	r0, [pc, #124]	; (243c <_dma_init+0x110>)
    23c0:	4b2d      	ldr	r3, [pc, #180]	; (2478 <_dma_init+0x14c>)
    23c2:	4798      	blx	r3
		hri_dmacdescriptor_write_BTCTRL_reg(&_descriptor_section[i], _cfgs[i].btctrl);
    23c4:	79fb      	ldrb	r3, [r7, #7]
    23c6:	011b      	lsls	r3, r3, #4
    23c8:	4a24      	ldr	r2, [pc, #144]	; (245c <_dma_init+0x130>)
    23ca:	1898      	adds	r0, r3, r2
    23cc:	79fb      	ldrb	r3, [r7, #7]
    23ce:	4a27      	ldr	r2, [pc, #156]	; (246c <_dma_init+0x140>)
    23d0:	00db      	lsls	r3, r3, #3
    23d2:	4413      	add	r3, r2
    23d4:	88db      	ldrh	r3, [r3, #6]
    23d6:	4619      	mov	r1, r3
    23d8:	4b28      	ldr	r3, [pc, #160]	; (247c <_dma_init+0x150>)
    23da:	4798      	blx	r3
	for (i = 0; i < DMAC_CH_NUM; i++) {
    23dc:	79fb      	ldrb	r3, [r7, #7]
    23de:	3301      	adds	r3, #1
    23e0:	71fb      	strb	r3, [r7, #7]
    23e2:	79fb      	ldrb	r3, [r7, #7]
    23e4:	2b1f      	cmp	r3, #31
    23e6:	d9d0      	bls.n	238a <_dma_init+0x5e>
	}

	for (i = 0; i < 5; i++) {
    23e8:	2300      	movs	r3, #0
    23ea:	71fb      	strb	r3, [r7, #7]
    23ec:	e01a      	b.n	2424 <_dma_init+0xf8>
		NVIC_DisableIRQ(DMAC_0_IRQn + i);
    23ee:	79fb      	ldrb	r3, [r7, #7]
    23f0:	b29b      	uxth	r3, r3
    23f2:	331f      	adds	r3, #31
    23f4:	b29b      	uxth	r3, r3
    23f6:	b21b      	sxth	r3, r3
    23f8:	4618      	mov	r0, r3
    23fa:	4b21      	ldr	r3, [pc, #132]	; (2480 <_dma_init+0x154>)
    23fc:	4798      	blx	r3
		NVIC_ClearPendingIRQ(DMAC_0_IRQn + i);
    23fe:	79fb      	ldrb	r3, [r7, #7]
    2400:	b29b      	uxth	r3, r3
    2402:	331f      	adds	r3, #31
    2404:	b29b      	uxth	r3, r3
    2406:	b21b      	sxth	r3, r3
    2408:	4618      	mov	r0, r3
    240a:	4b1e      	ldr	r3, [pc, #120]	; (2484 <_dma_init+0x158>)
    240c:	4798      	blx	r3
		NVIC_EnableIRQ(DMAC_0_IRQn + i);
    240e:	79fb      	ldrb	r3, [r7, #7]
    2410:	b29b      	uxth	r3, r3
    2412:	331f      	adds	r3, #31
    2414:	b29b      	uxth	r3, r3
    2416:	b21b      	sxth	r3, r3
    2418:	4618      	mov	r0, r3
    241a:	4b1b      	ldr	r3, [pc, #108]	; (2488 <_dma_init+0x15c>)
    241c:	4798      	blx	r3
	for (i = 0; i < 5; i++) {
    241e:	79fb      	ldrb	r3, [r7, #7]
    2420:	3301      	adds	r3, #1
    2422:	71fb      	strb	r3, [r7, #7]
    2424:	79fb      	ldrb	r3, [r7, #7]
    2426:	2b04      	cmp	r3, #4
    2428:	d9e1      	bls.n	23ee <_dma_init+0xc2>
	}

	hri_dmac_set_CTRL_DMAENABLE_bit(DMAC);
    242a:	4804      	ldr	r0, [pc, #16]	; (243c <_dma_init+0x110>)
    242c:	4b17      	ldr	r3, [pc, #92]	; (248c <_dma_init+0x160>)
    242e:	4798      	blx	r3

	return ERR_NONE;
    2430:	2300      	movs	r3, #0
}
    2432:	4618      	mov	r0, r3
    2434:	3708      	adds	r7, #8
    2436:	46bd      	mov	sp, r7
    2438:	bd80      	pop	{r7, pc}
    243a:	bf00      	nop
    243c:	4100a000 	.word	0x4100a000
    2440:	00001e5f 	.word	0x00001e5f
    2444:	00001ea1 	.word	0x00001ea1
    2448:	00001de9 	.word	0x00001de9
    244c:	00001e0d 	.word	0x00001e0d
    2450:	00001e83 	.word	0x00001e83
    2454:	00001ed3 	.word	0x00001ed3
    2458:	00001f29 	.word	0x00001f29
    245c:	20000520 	.word	0x20000520
    2460:	00001f6d 	.word	0x00001f6d
    2464:	20000720 	.word	0x20000720
    2468:	00001f89 	.word	0x00001f89
    246c:	00005ba8 	.word	0x00005ba8
    2470:	000022ab 	.word	0x000022ab
    2474:	000022d3 	.word	0x000022d3
    2478:	000022ff 	.word	0x000022ff
    247c:	00002091 	.word	0x00002091
    2480:	00001d69 	.word	0x00001d69
    2484:	00001dad 	.word	0x00001dad
    2488:	00001d2d 	.word	0x00001d2d
    248c:	00001e3b 	.word	0x00001e3b

00002490 <_dma_set_irq_state>:

/**
 * \brief Enable/disable DMA interrupt
 */
void _dma_set_irq_state(const uint8_t channel, const enum _dma_callback_type type, const bool state)
{
    2490:	b580      	push	{r7, lr}
    2492:	b082      	sub	sp, #8
    2494:	af00      	add	r7, sp, #0
    2496:	4603      	mov	r3, r0
    2498:	71fb      	strb	r3, [r7, #7]
    249a:	460b      	mov	r3, r1
    249c:	71bb      	strb	r3, [r7, #6]
    249e:	4613      	mov	r3, r2
    24a0:	717b      	strb	r3, [r7, #5]
	if (DMA_TRANSFER_COMPLETE_CB == type) {
    24a2:	79bb      	ldrb	r3, [r7, #6]
    24a4:	2b00      	cmp	r3, #0
    24a6:	d106      	bne.n	24b6 <_dma_set_irq_state+0x26>
		hri_dmac_write_CHINTEN_TCMPL_bit(DMAC, channel, state);
    24a8:	797a      	ldrb	r2, [r7, #5]
    24aa:	79fb      	ldrb	r3, [r7, #7]
    24ac:	4619      	mov	r1, r3
    24ae:	4808      	ldr	r0, [pc, #32]	; (24d0 <_dma_set_irq_state+0x40>)
    24b0:	4b08      	ldr	r3, [pc, #32]	; (24d4 <_dma_set_irq_state+0x44>)
    24b2:	4798      	blx	r3
	} else if (DMA_TRANSFER_ERROR_CB == type) {
		hri_dmac_write_CHINTEN_TERR_bit(DMAC, channel, state);
	}
}
    24b4:	e008      	b.n	24c8 <_dma_set_irq_state+0x38>
	} else if (DMA_TRANSFER_ERROR_CB == type) {
    24b6:	79bb      	ldrb	r3, [r7, #6]
    24b8:	2b01      	cmp	r3, #1
    24ba:	d105      	bne.n	24c8 <_dma_set_irq_state+0x38>
		hri_dmac_write_CHINTEN_TERR_bit(DMAC, channel, state);
    24bc:	797a      	ldrb	r2, [r7, #5]
    24be:	79fb      	ldrb	r3, [r7, #7]
    24c0:	4619      	mov	r1, r3
    24c2:	4803      	ldr	r0, [pc, #12]	; (24d0 <_dma_set_irq_state+0x40>)
    24c4:	4b04      	ldr	r3, [pc, #16]	; (24d8 <_dma_set_irq_state+0x48>)
    24c6:	4798      	blx	r3
}
    24c8:	bf00      	nop
    24ca:	3708      	adds	r7, #8
    24cc:	46bd      	mov	sp, r7
    24ce:	bd80      	pop	{r7, pc}
    24d0:	4100a000 	.word	0x4100a000
    24d4:	00002231 	.word	0x00002231
    24d8:	000021eb 	.word	0x000021eb

000024dc <_dma_set_destination_address>:

int32_t _dma_set_destination_address(const uint8_t channel, const void *const dst)
{
    24dc:	b580      	push	{r7, lr}
    24de:	b082      	sub	sp, #8
    24e0:	af00      	add	r7, sp, #0
    24e2:	4603      	mov	r3, r0
    24e4:	6039      	str	r1, [r7, #0]
    24e6:	71fb      	strb	r3, [r7, #7]
	hri_dmacdescriptor_write_DSTADDR_reg(&_descriptor_section[channel], (uint32_t)dst);
    24e8:	79fb      	ldrb	r3, [r7, #7]
    24ea:	011b      	lsls	r3, r3, #4
    24ec:	4a05      	ldr	r2, [pc, #20]	; (2504 <_dma_set_destination_address+0x28>)
    24ee:	4413      	add	r3, r2
    24f0:	683a      	ldr	r2, [r7, #0]
    24f2:	4611      	mov	r1, r2
    24f4:	4618      	mov	r0, r3
    24f6:	4b04      	ldr	r3, [pc, #16]	; (2508 <_dma_set_destination_address+0x2c>)
    24f8:	4798      	blx	r3

	return ERR_NONE;
    24fa:	2300      	movs	r3, #0
}
    24fc:	4618      	mov	r0, r3
    24fe:	3708      	adds	r7, #8
    2500:	46bd      	mov	sp, r7
    2502:	bd80      	pop	{r7, pc}
    2504:	20000520 	.word	0x20000520
    2508:	00002101 	.word	0x00002101

0000250c <_dma_set_source_address>:

int32_t _dma_set_source_address(const uint8_t channel, const void *const src)
{
    250c:	b580      	push	{r7, lr}
    250e:	b082      	sub	sp, #8
    2510:	af00      	add	r7, sp, #0
    2512:	4603      	mov	r3, r0
    2514:	6039      	str	r1, [r7, #0]
    2516:	71fb      	strb	r3, [r7, #7]
	hri_dmacdescriptor_write_SRCADDR_reg(&_descriptor_section[channel], (uint32_t)src);
    2518:	79fb      	ldrb	r3, [r7, #7]
    251a:	011b      	lsls	r3, r3, #4
    251c:	4a05      	ldr	r2, [pc, #20]	; (2534 <_dma_set_source_address+0x28>)
    251e:	4413      	add	r3, r2
    2520:	683a      	ldr	r2, [r7, #0]
    2522:	4611      	mov	r1, r2
    2524:	4618      	mov	r0, r3
    2526:	4b04      	ldr	r3, [pc, #16]	; (2538 <_dma_set_source_address+0x2c>)
    2528:	4798      	blx	r3

	return ERR_NONE;
    252a:	2300      	movs	r3, #0
}
    252c:	4618      	mov	r0, r3
    252e:	3708      	adds	r7, #8
    2530:	46bd      	mov	sp, r7
    2532:	bd80      	pop	{r7, pc}
    2534:	20000520 	.word	0x20000520
    2538:	000020cd 	.word	0x000020cd

0000253c <_dma_srcinc_enable>:

int32_t _dma_srcinc_enable(const uint8_t channel, const bool enable)
{
    253c:	b580      	push	{r7, lr}
    253e:	b082      	sub	sp, #8
    2540:	af00      	add	r7, sp, #0
    2542:	4603      	mov	r3, r0
    2544:	460a      	mov	r2, r1
    2546:	71fb      	strb	r3, [r7, #7]
    2548:	4613      	mov	r3, r2
    254a:	71bb      	strb	r3, [r7, #6]
	hri_dmacdescriptor_write_BTCTRL_SRCINC_bit(&_descriptor_section[channel], enable);
    254c:	79fb      	ldrb	r3, [r7, #7]
    254e:	011b      	lsls	r3, r3, #4
    2550:	4a05      	ldr	r2, [pc, #20]	; (2568 <_dma_srcinc_enable+0x2c>)
    2552:	4413      	add	r3, r2
    2554:	79ba      	ldrb	r2, [r7, #6]
    2556:	4611      	mov	r1, r2
    2558:	4618      	mov	r0, r3
    255a:	4b04      	ldr	r3, [pc, #16]	; (256c <_dma_srcinc_enable+0x30>)
    255c:	4798      	blx	r3

	return ERR_NONE;
    255e:	2300      	movs	r3, #0
}
    2560:	4618      	mov	r0, r3
    2562:	3708      	adds	r7, #8
    2564:	46bd      	mov	sp, r7
    2566:	bd80      	pop	{r7, pc}
    2568:	20000520 	.word	0x20000520
    256c:	00001ffb 	.word	0x00001ffb

00002570 <_dma_set_data_amount>:

int32_t _dma_set_data_amount(const uint8_t channel, const uint32_t amount)
{
    2570:	b580      	push	{r7, lr}
    2572:	b084      	sub	sp, #16
    2574:	af00      	add	r7, sp, #0
    2576:	4603      	mov	r3, r0
    2578:	6039      	str	r1, [r7, #0]
    257a:	71fb      	strb	r3, [r7, #7]
	uint32_t address   = hri_dmacdescriptor_read_DSTADDR_reg(&_descriptor_section[channel]);
    257c:	79fb      	ldrb	r3, [r7, #7]
    257e:	011b      	lsls	r3, r3, #4
    2580:	4a28      	ldr	r2, [pc, #160]	; (2624 <_dma_set_data_amount+0xb4>)
    2582:	4413      	add	r3, r2
    2584:	4618      	mov	r0, r3
    2586:	4b28      	ldr	r3, [pc, #160]	; (2628 <_dma_set_data_amount+0xb8>)
    2588:	4798      	blx	r3
    258a:	60f8      	str	r0, [r7, #12]
	uint8_t  beat_size = hri_dmacdescriptor_read_BTCTRL_BEATSIZE_bf(&_descriptor_section[channel]);
    258c:	79fb      	ldrb	r3, [r7, #7]
    258e:	011b      	lsls	r3, r3, #4
    2590:	4a24      	ldr	r2, [pc, #144]	; (2624 <_dma_set_data_amount+0xb4>)
    2592:	4413      	add	r3, r2
    2594:	4618      	mov	r0, r3
    2596:	4b25      	ldr	r3, [pc, #148]	; (262c <_dma_set_data_amount+0xbc>)
    2598:	4798      	blx	r3
    259a:	4603      	mov	r3, r0
    259c:	72fb      	strb	r3, [r7, #11]

	if (hri_dmacdescriptor_get_BTCTRL_DSTINC_bit(&_descriptor_section[channel])) {
    259e:	79fb      	ldrb	r3, [r7, #7]
    25a0:	011b      	lsls	r3, r3, #4
    25a2:	4a20      	ldr	r2, [pc, #128]	; (2624 <_dma_set_data_amount+0xb4>)
    25a4:	4413      	add	r3, r2
    25a6:	4618      	mov	r0, r3
    25a8:	4b21      	ldr	r3, [pc, #132]	; (2630 <_dma_set_data_amount+0xc0>)
    25aa:	4798      	blx	r3
    25ac:	4603      	mov	r3, r0
    25ae:	2b00      	cmp	r3, #0
    25b0:	d00b      	beq.n	25ca <_dma_set_data_amount+0x5a>
		hri_dmacdescriptor_write_DSTADDR_reg(&_descriptor_section[channel], address + amount * (1 << beat_size));
    25b2:	79fb      	ldrb	r3, [r7, #7]
    25b4:	011b      	lsls	r3, r3, #4
    25b6:	4a1b      	ldr	r2, [pc, #108]	; (2624 <_dma_set_data_amount+0xb4>)
    25b8:	1898      	adds	r0, r3, r2
    25ba:	7afb      	ldrb	r3, [r7, #11]
    25bc:	683a      	ldr	r2, [r7, #0]
    25be:	409a      	lsls	r2, r3
    25c0:	68fb      	ldr	r3, [r7, #12]
    25c2:	4413      	add	r3, r2
    25c4:	4619      	mov	r1, r3
    25c6:	4b1b      	ldr	r3, [pc, #108]	; (2634 <_dma_set_data_amount+0xc4>)
    25c8:	4798      	blx	r3
	}

	address = hri_dmacdescriptor_read_SRCADDR_reg(&_descriptor_section[channel]);
    25ca:	79fb      	ldrb	r3, [r7, #7]
    25cc:	011b      	lsls	r3, r3, #4
    25ce:	4a15      	ldr	r2, [pc, #84]	; (2624 <_dma_set_data_amount+0xb4>)
    25d0:	4413      	add	r3, r2
    25d2:	4618      	mov	r0, r3
    25d4:	4b18      	ldr	r3, [pc, #96]	; (2638 <_dma_set_data_amount+0xc8>)
    25d6:	4798      	blx	r3
    25d8:	60f8      	str	r0, [r7, #12]

	if (hri_dmacdescriptor_get_BTCTRL_SRCINC_bit(&_descriptor_section[channel])) {
    25da:	79fb      	ldrb	r3, [r7, #7]
    25dc:	011b      	lsls	r3, r3, #4
    25de:	4a11      	ldr	r2, [pc, #68]	; (2624 <_dma_set_data_amount+0xb4>)
    25e0:	4413      	add	r3, r2
    25e2:	4618      	mov	r0, r3
    25e4:	4b15      	ldr	r3, [pc, #84]	; (263c <_dma_set_data_amount+0xcc>)
    25e6:	4798      	blx	r3
    25e8:	4603      	mov	r3, r0
    25ea:	2b00      	cmp	r3, #0
    25ec:	d00b      	beq.n	2606 <_dma_set_data_amount+0x96>
		hri_dmacdescriptor_write_SRCADDR_reg(&_descriptor_section[channel], address + amount * (1 << beat_size));
    25ee:	79fb      	ldrb	r3, [r7, #7]
    25f0:	011b      	lsls	r3, r3, #4
    25f2:	4a0c      	ldr	r2, [pc, #48]	; (2624 <_dma_set_data_amount+0xb4>)
    25f4:	1898      	adds	r0, r3, r2
    25f6:	7afb      	ldrb	r3, [r7, #11]
    25f8:	683a      	ldr	r2, [r7, #0]
    25fa:	409a      	lsls	r2, r3
    25fc:	68fb      	ldr	r3, [r7, #12]
    25fe:	4413      	add	r3, r2
    2600:	4619      	mov	r1, r3
    2602:	4b0f      	ldr	r3, [pc, #60]	; (2640 <_dma_set_data_amount+0xd0>)
    2604:	4798      	blx	r3
	}

	hri_dmacdescriptor_write_BTCNT_reg(&_descriptor_section[channel], amount);
    2606:	79fb      	ldrb	r3, [r7, #7]
    2608:	011b      	lsls	r3, r3, #4
    260a:	4a06      	ldr	r2, [pc, #24]	; (2624 <_dma_set_data_amount+0xb4>)
    260c:	4413      	add	r3, r2
    260e:	683a      	ldr	r2, [r7, #0]
    2610:	b292      	uxth	r2, r2
    2612:	4611      	mov	r1, r2
    2614:	4618      	mov	r0, r3
    2616:	4b0b      	ldr	r3, [pc, #44]	; (2644 <_dma_set_data_amount+0xd4>)
    2618:	4798      	blx	r3

	return ERR_NONE;
    261a:	2300      	movs	r3, #0
}
    261c:	4618      	mov	r0, r3
    261e:	3710      	adds	r7, #16
    2620:	46bd      	mov	sp, r7
    2622:	bd80      	pop	{r7, pc}
    2624:	20000520 	.word	0x20000520
    2628:	0000211d 	.word	0x0000211d
    262c:	00002069 	.word	0x00002069
    2630:	00002037 	.word	0x00002037
    2634:	00002101 	.word	0x00002101
    2638:	000020e9 	.word	0x000020e9
    263c:	00001fc9 	.word	0x00001fc9
    2640:	000020cd 	.word	0x000020cd
    2644:	000020af 	.word	0x000020af

00002648 <_dma_enable_transaction>:

int32_t _dma_enable_transaction(const uint8_t channel, const bool software_trigger)
{
    2648:	b580      	push	{r7, lr}
    264a:	b082      	sub	sp, #8
    264c:	af00      	add	r7, sp, #0
    264e:	4603      	mov	r3, r0
    2650:	460a      	mov	r2, r1
    2652:	71fb      	strb	r3, [r7, #7]
    2654:	4613      	mov	r3, r2
    2656:	71bb      	strb	r3, [r7, #6]
	hri_dmacdescriptor_set_BTCTRL_VALID_bit(&_descriptor_section[channel]);
    2658:	79fb      	ldrb	r3, [r7, #7]
    265a:	011b      	lsls	r3, r3, #4
    265c:	4a0c      	ldr	r2, [pc, #48]	; (2690 <_dma_enable_transaction+0x48>)
    265e:	4413      	add	r3, r2
    2660:	4618      	mov	r0, r3
    2662:	4b0c      	ldr	r3, [pc, #48]	; (2694 <_dma_enable_transaction+0x4c>)
    2664:	4798      	blx	r3
	hri_dmac_set_CHCTRLA_ENABLE_bit(DMAC, channel);
    2666:	79fb      	ldrb	r3, [r7, #7]
    2668:	4619      	mov	r1, r3
    266a:	480b      	ldr	r0, [pc, #44]	; (2698 <_dma_enable_transaction+0x50>)
    266c:	4b0b      	ldr	r3, [pc, #44]	; (269c <_dma_enable_transaction+0x54>)
    266e:	4798      	blx	r3

	if (software_trigger) {
    2670:	79bb      	ldrb	r3, [r7, #6]
    2672:	2b00      	cmp	r3, #0
    2674:	d007      	beq.n	2686 <_dma_enable_transaction+0x3e>
		hri_dmac_set_SWTRIGCTRL_reg(DMAC, 1 << channel);
    2676:	79fb      	ldrb	r3, [r7, #7]
    2678:	2201      	movs	r2, #1
    267a:	fa02 f303 	lsl.w	r3, r2, r3
    267e:	4619      	mov	r1, r3
    2680:	4805      	ldr	r0, [pc, #20]	; (2698 <_dma_enable_transaction+0x50>)
    2682:	4b07      	ldr	r3, [pc, #28]	; (26a0 <_dma_enable_transaction+0x58>)
    2684:	4798      	blx	r3
	}

	return ERR_NONE;
    2686:	2300      	movs	r3, #0
}
    2688:	4618      	mov	r0, r3
    268a:	3708      	adds	r7, #8
    268c:	46bd      	mov	sp, r7
    268e:	bd80      	pop	{r7, pc}
    2690:	20000520 	.word	0x20000520
    2694:	00001fa5 	.word	0x00001fa5
    2698:	4100a000 	.word	0x4100a000
    269c:	00002277 	.word	0x00002277
    26a0:	00001f07 	.word	0x00001f07

000026a4 <_dma_get_channel_resource>:

int32_t _dma_get_channel_resource(struct _dma_resource **resource, const uint8_t channel)
{
    26a4:	b480      	push	{r7}
    26a6:	b083      	sub	sp, #12
    26a8:	af00      	add	r7, sp, #0
    26aa:	6078      	str	r0, [r7, #4]
    26ac:	460b      	mov	r3, r1
    26ae:	70fb      	strb	r3, [r7, #3]
	*resource = &_resources[channel];
    26b0:	78fa      	ldrb	r2, [r7, #3]
    26b2:	4613      	mov	r3, r2
    26b4:	005b      	lsls	r3, r3, #1
    26b6:	4413      	add	r3, r2
    26b8:	009b      	lsls	r3, r3, #2
    26ba:	4a05      	ldr	r2, [pc, #20]	; (26d0 <_dma_get_channel_resource+0x2c>)
    26bc:	441a      	add	r2, r3
    26be:	687b      	ldr	r3, [r7, #4]
    26c0:	601a      	str	r2, [r3, #0]

	return ERR_NONE;
    26c2:	2300      	movs	r3, #0
}
    26c4:	4618      	mov	r0, r3
    26c6:	370c      	adds	r7, #12
    26c8:	46bd      	mov	sp, r7
    26ca:	f85d 7b04 	ldr.w	r7, [sp], #4
    26ce:	4770      	bx	lr
    26d0:	20000920 	.word	0x20000920

000026d4 <_dmac_handler>:

/**
 * \internal DMAC interrupt handler
 */
static void _dmac_handler(void)
{
    26d4:	b580      	push	{r7, lr}
    26d6:	b082      	sub	sp, #8
    26d8:	af00      	add	r7, sp, #0
	uint8_t               channel      = hri_dmac_get_INTPEND_reg(DMAC, DMAC_INTPEND_ID_Msk);
    26da:	211f      	movs	r1, #31
    26dc:	481b      	ldr	r0, [pc, #108]	; (274c <_dmac_handler+0x78>)
    26de:	4b1c      	ldr	r3, [pc, #112]	; (2750 <_dmac_handler+0x7c>)
    26e0:	4798      	blx	r3
    26e2:	4603      	mov	r3, r0
    26e4:	71fb      	strb	r3, [r7, #7]
	struct _dma_resource *tmp_resource = &_resources[channel];
    26e6:	79fa      	ldrb	r2, [r7, #7]
    26e8:	4613      	mov	r3, r2
    26ea:	005b      	lsls	r3, r3, #1
    26ec:	4413      	add	r3, r2
    26ee:	009b      	lsls	r3, r3, #2
    26f0:	4a18      	ldr	r2, [pc, #96]	; (2754 <_dmac_handler+0x80>)
    26f2:	4413      	add	r3, r2
    26f4:	603b      	str	r3, [r7, #0]

	if (hri_dmac_get_CHINTFLAG_TERR_bit(DMAC, channel)) {
    26f6:	79fb      	ldrb	r3, [r7, #7]
    26f8:	4619      	mov	r1, r3
    26fa:	4814      	ldr	r0, [pc, #80]	; (274c <_dmac_handler+0x78>)
    26fc:	4b16      	ldr	r3, [pc, #88]	; (2758 <_dmac_handler+0x84>)
    26fe:	4798      	blx	r3
    2700:	4603      	mov	r3, r0
    2702:	2b00      	cmp	r3, #0
    2704:	d009      	beq.n	271a <_dmac_handler+0x46>
		hri_dmac_clear_CHINTFLAG_TERR_bit(DMAC, channel);
    2706:	79fb      	ldrb	r3, [r7, #7]
    2708:	4619      	mov	r1, r3
    270a:	4810      	ldr	r0, [pc, #64]	; (274c <_dmac_handler+0x78>)
    270c:	4b13      	ldr	r3, [pc, #76]	; (275c <_dmac_handler+0x88>)
    270e:	4798      	blx	r3
		tmp_resource->dma_cb.error(tmp_resource);
    2710:	683b      	ldr	r3, [r7, #0]
    2712:	685b      	ldr	r3, [r3, #4]
    2714:	6838      	ldr	r0, [r7, #0]
    2716:	4798      	blx	r3
	} else if (hri_dmac_get_CHINTFLAG_TCMPL_bit(DMAC, channel)) {
		hri_dmac_clear_CHINTFLAG_TCMPL_bit(DMAC, channel);
		flag_frame_captured = 1;
		tmp_resource->dma_cb.transfer_done(tmp_resource);
	}
}
    2718:	e013      	b.n	2742 <_dmac_handler+0x6e>
	} else if (hri_dmac_get_CHINTFLAG_TCMPL_bit(DMAC, channel)) {
    271a:	79fb      	ldrb	r3, [r7, #7]
    271c:	4619      	mov	r1, r3
    271e:	480b      	ldr	r0, [pc, #44]	; (274c <_dmac_handler+0x78>)
    2720:	4b0f      	ldr	r3, [pc, #60]	; (2760 <_dmac_handler+0x8c>)
    2722:	4798      	blx	r3
    2724:	4603      	mov	r3, r0
    2726:	2b00      	cmp	r3, #0
    2728:	d00b      	beq.n	2742 <_dmac_handler+0x6e>
		hri_dmac_clear_CHINTFLAG_TCMPL_bit(DMAC, channel);
    272a:	79fb      	ldrb	r3, [r7, #7]
    272c:	4619      	mov	r1, r3
    272e:	4807      	ldr	r0, [pc, #28]	; (274c <_dmac_handler+0x78>)
    2730:	4b0c      	ldr	r3, [pc, #48]	; (2764 <_dmac_handler+0x90>)
    2732:	4798      	blx	r3
		flag_frame_captured = 1;
    2734:	4b0c      	ldr	r3, [pc, #48]	; (2768 <_dmac_handler+0x94>)
    2736:	2201      	movs	r2, #1
    2738:	601a      	str	r2, [r3, #0]
		tmp_resource->dma_cb.transfer_done(tmp_resource);
    273a:	683b      	ldr	r3, [r7, #0]
    273c:	681b      	ldr	r3, [r3, #0]
    273e:	6838      	ldr	r0, [r7, #0]
    2740:	4798      	blx	r3
}
    2742:	bf00      	nop
    2744:	3708      	adds	r7, #8
    2746:	46bd      	mov	sp, r7
    2748:	bd80      	pop	{r7, pc}
    274a:	bf00      	nop
    274c:	4100a000 	.word	0x4100a000
    2750:	00001f45 	.word	0x00001f45
    2754:	20000920 	.word	0x20000920
    2758:	00002135 	.word	0x00002135
    275c:	00002169 	.word	0x00002169
    2760:	0000218f 	.word	0x0000218f
    2764:	000021c5 	.word	0x000021c5
    2768:	200262c0 	.word	0x200262c0

0000276c <DMAC_0_Handler>:
/**
* \brief DMAC interrupt handler
*/
void DMAC_0_Handler(void)
{
    276c:	b580      	push	{r7, lr}
    276e:	af00      	add	r7, sp, #0
	_dmac_handler();
    2770:	4b01      	ldr	r3, [pc, #4]	; (2778 <DMAC_0_Handler+0xc>)
    2772:	4798      	blx	r3
}
    2774:	bf00      	nop
    2776:	bd80      	pop	{r7, pc}
    2778:	000026d5 	.word	0x000026d5

0000277c <DMAC_1_Handler>:
/**
* \brief DMAC interrupt handler
*/
void DMAC_1_Handler(void)
{
    277c:	b580      	push	{r7, lr}
    277e:	af00      	add	r7, sp, #0
	_dmac_handler();
    2780:	4b01      	ldr	r3, [pc, #4]	; (2788 <DMAC_1_Handler+0xc>)
    2782:	4798      	blx	r3
}
    2784:	bf00      	nop
    2786:	bd80      	pop	{r7, pc}
    2788:	000026d5 	.word	0x000026d5

0000278c <DMAC_2_Handler>:
/**
* \brief DMAC interrupt handler
*/
void DMAC_2_Handler(void)
{
    278c:	b580      	push	{r7, lr}
    278e:	af00      	add	r7, sp, #0
	_dmac_handler();
    2790:	4b01      	ldr	r3, [pc, #4]	; (2798 <DMAC_2_Handler+0xc>)
    2792:	4798      	blx	r3
}
    2794:	bf00      	nop
    2796:	bd80      	pop	{r7, pc}
    2798:	000026d5 	.word	0x000026d5

0000279c <DMAC_3_Handler>:
/**
* \brief DMAC interrupt handler
*/
void DMAC_3_Handler(void)
{
    279c:	b580      	push	{r7, lr}
    279e:	af00      	add	r7, sp, #0
	_dmac_handler();
    27a0:	4b01      	ldr	r3, [pc, #4]	; (27a8 <DMAC_3_Handler+0xc>)
    27a2:	4798      	blx	r3
}
    27a4:	bf00      	nop
    27a6:	bd80      	pop	{r7, pc}
    27a8:	000026d5 	.word	0x000026d5

000027ac <DMAC_4_Handler>:
/**
* \brief DMAC interrupt handler
*/
void DMAC_4_Handler(void)
{
    27ac:	b580      	push	{r7, lr}
    27ae:	af00      	add	r7, sp, #0
	_dmac_handler();
    27b0:	4b01      	ldr	r3, [pc, #4]	; (27b8 <DMAC_4_Handler+0xc>)
    27b2:	4798      	blx	r3
}
    27b4:	bf00      	nop
    27b6:	bd80      	pop	{r7, pc}
    27b8:	000026d5 	.word	0x000026d5

000027bc <__NVIC_EnableIRQ>:
{
    27bc:	b480      	push	{r7}
    27be:	b083      	sub	sp, #12
    27c0:	af00      	add	r7, sp, #0
    27c2:	4603      	mov	r3, r0
    27c4:	80fb      	strh	r3, [r7, #6]
  if ((int32_t)(IRQn) >= 0)
    27c6:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
    27ca:	2b00      	cmp	r3, #0
    27cc:	db0b      	blt.n	27e6 <__NVIC_EnableIRQ+0x2a>
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    27ce:	4909      	ldr	r1, [pc, #36]	; (27f4 <__NVIC_EnableIRQ+0x38>)
    27d0:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
    27d4:	095b      	lsrs	r3, r3, #5
    27d6:	88fa      	ldrh	r2, [r7, #6]
    27d8:	f002 021f 	and.w	r2, r2, #31
    27dc:	2001      	movs	r0, #1
    27de:	fa00 f202 	lsl.w	r2, r0, r2
    27e2:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    27e6:	bf00      	nop
    27e8:	370c      	adds	r7, #12
    27ea:	46bd      	mov	sp, r7
    27ec:	f85d 7b04 	ldr.w	r7, [sp], #4
    27f0:	4770      	bx	lr
    27f2:	bf00      	nop
    27f4:	e000e100 	.word	0xe000e100

000027f8 <__NVIC_DisableIRQ>:
{
    27f8:	b480      	push	{r7}
    27fa:	b083      	sub	sp, #12
    27fc:	af00      	add	r7, sp, #0
    27fe:	4603      	mov	r3, r0
    2800:	80fb      	strh	r3, [r7, #6]
  if ((int32_t)(IRQn) >= 0)
    2802:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
    2806:	2b00      	cmp	r3, #0
    2808:	db10      	blt.n	282c <__NVIC_DisableIRQ+0x34>
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    280a:	490b      	ldr	r1, [pc, #44]	; (2838 <__NVIC_DisableIRQ+0x40>)
    280c:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
    2810:	095b      	lsrs	r3, r3, #5
    2812:	88fa      	ldrh	r2, [r7, #6]
    2814:	f002 021f 	and.w	r2, r2, #31
    2818:	2001      	movs	r0, #1
    281a:	fa00 f202 	lsl.w	r2, r0, r2
    281e:	3320      	adds	r3, #32
    2820:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  __ASM volatile ("dsb 0xF":::"memory");
    2824:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    2828:	f3bf 8f6f 	isb	sy
}
    282c:	bf00      	nop
    282e:	370c      	adds	r7, #12
    2830:	46bd      	mov	sp, r7
    2832:	f85d 7b04 	ldr.w	r7, [sp], #4
    2836:	4770      	bx	lr
    2838:	e000e100 	.word	0xe000e100

0000283c <__NVIC_ClearPendingIRQ>:
{
    283c:	b480      	push	{r7}
    283e:	b083      	sub	sp, #12
    2840:	af00      	add	r7, sp, #0
    2842:	4603      	mov	r3, r0
    2844:	80fb      	strh	r3, [r7, #6]
  if ((int32_t)(IRQn) >= 0)
    2846:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
    284a:	2b00      	cmp	r3, #0
    284c:	db0c      	blt.n	2868 <__NVIC_ClearPendingIRQ+0x2c>
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    284e:	4909      	ldr	r1, [pc, #36]	; (2874 <__NVIC_ClearPendingIRQ+0x38>)
    2850:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
    2854:	095b      	lsrs	r3, r3, #5
    2856:	88fa      	ldrh	r2, [r7, #6]
    2858:	f002 021f 	and.w	r2, r2, #31
    285c:	2001      	movs	r0, #1
    285e:	fa00 f202 	lsl.w	r2, r0, r2
    2862:	3360      	adds	r3, #96	; 0x60
    2864:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    2868:	bf00      	nop
    286a:	370c      	adds	r7, #12
    286c:	46bd      	mov	sp, r7
    286e:	f85d 7b04 	ldr.w	r7, [sp], #4
    2872:	4770      	bx	lr
    2874:	e000e100 	.word	0xe000e100

00002878 <hri_eic_wait_for_sync>:
typedef uint32_t hri_eic_syncbusy_reg_t;
typedef uint8_t  hri_eic_ctrla_reg_t;
typedef uint8_t  hri_eic_nmictrl_reg_t;

static inline void hri_eic_wait_for_sync(const void *const hw, hri_eic_syncbusy_reg_t reg)
{
    2878:	b480      	push	{r7}
    287a:	b083      	sub	sp, #12
    287c:	af00      	add	r7, sp, #0
    287e:	6078      	str	r0, [r7, #4]
    2880:	6039      	str	r1, [r7, #0]
	while (((Eic *)hw)->SYNCBUSY.reg & reg) {
    2882:	bf00      	nop
    2884:	687b      	ldr	r3, [r7, #4]
    2886:	685a      	ldr	r2, [r3, #4]
    2888:	683b      	ldr	r3, [r7, #0]
    288a:	4013      	ands	r3, r2
    288c:	2b00      	cmp	r3, #0
    288e:	d1f9      	bne.n	2884 <hri_eic_wait_for_sync+0xc>
	};
}
    2890:	bf00      	nop
    2892:	370c      	adds	r7, #12
    2894:	46bd      	mov	sp, r7
    2896:	f85d 7b04 	ldr.w	r7, [sp], #4
    289a:	4770      	bx	lr

0000289c <hri_eic_is_syncing>:

static inline bool hri_eic_is_syncing(const void *const hw, hri_eic_syncbusy_reg_t reg)
{
    289c:	b480      	push	{r7}
    289e:	b083      	sub	sp, #12
    28a0:	af00      	add	r7, sp, #0
    28a2:	6078      	str	r0, [r7, #4]
    28a4:	6039      	str	r1, [r7, #0]
	return ((Eic *)hw)->SYNCBUSY.reg & reg;
    28a6:	687b      	ldr	r3, [r7, #4]
    28a8:	685a      	ldr	r2, [r3, #4]
    28aa:	683b      	ldr	r3, [r7, #0]
    28ac:	4013      	ands	r3, r2
    28ae:	2b00      	cmp	r3, #0
    28b0:	bf14      	ite	ne
    28b2:	2301      	movne	r3, #1
    28b4:	2300      	moveq	r3, #0
    28b6:	b2db      	uxtb	r3, r3
}
    28b8:	4618      	mov	r0, r3
    28ba:	370c      	adds	r7, #12
    28bc:	46bd      	mov	sp, r7
    28be:	f85d 7b04 	ldr.w	r7, [sp], #4
    28c2:	4770      	bx	lr

000028c4 <hri_eic_read_INTFLAG_reg>:
	tmp &= mask;
	return tmp;
}

static inline hri_eic_intflag_reg_t hri_eic_read_INTFLAG_reg(const void *const hw)
{
    28c4:	b480      	push	{r7}
    28c6:	b083      	sub	sp, #12
    28c8:	af00      	add	r7, sp, #0
    28ca:	6078      	str	r0, [r7, #4]
	return ((Eic *)hw)->INTFLAG.reg;
    28cc:	687b      	ldr	r3, [r7, #4]
    28ce:	695b      	ldr	r3, [r3, #20]
}
    28d0:	4618      	mov	r0, r3
    28d2:	370c      	adds	r7, #12
    28d4:	46bd      	mov	sp, r7
    28d6:	f85d 7b04 	ldr.w	r7, [sp], #4
    28da:	4770      	bx	lr

000028dc <hri_eic_clear_INTFLAG_reg>:

static inline void hri_eic_clear_INTFLAG_reg(const void *const hw, hri_eic_intflag_reg_t mask)
{
    28dc:	b480      	push	{r7}
    28de:	b083      	sub	sp, #12
    28e0:	af00      	add	r7, sp, #0
    28e2:	6078      	str	r0, [r7, #4]
    28e4:	6039      	str	r1, [r7, #0]
	((Eic *)hw)->INTFLAG.reg = mask;
    28e6:	687b      	ldr	r3, [r7, #4]
    28e8:	683a      	ldr	r2, [r7, #0]
    28ea:	615a      	str	r2, [r3, #20]
}
    28ec:	bf00      	nop
    28ee:	370c      	adds	r7, #12
    28f0:	46bd      	mov	sp, r7
    28f2:	f85d 7b04 	ldr.w	r7, [sp], #4
    28f6:	4770      	bx	lr

000028f8 <hri_eic_set_INTEN_reg>:
{
	((Eic *)hw)->INTENCLR.reg = EIC_INTENSET_EXTINT(mask);
}

static inline void hri_eic_set_INTEN_reg(const void *const hw, hri_eic_intenset_reg_t mask)
{
    28f8:	b480      	push	{r7}
    28fa:	b083      	sub	sp, #12
    28fc:	af00      	add	r7, sp, #0
    28fe:	6078      	str	r0, [r7, #4]
    2900:	6039      	str	r1, [r7, #0]
	((Eic *)hw)->INTENSET.reg = mask;
    2902:	687b      	ldr	r3, [r7, #4]
    2904:	683a      	ldr	r2, [r7, #0]
    2906:	611a      	str	r2, [r3, #16]
}
    2908:	bf00      	nop
    290a:	370c      	adds	r7, #12
    290c:	46bd      	mov	sp, r7
    290e:	f85d 7b04 	ldr.w	r7, [sp], #4
    2912:	4770      	bx	lr

00002914 <hri_eic_clear_INTEN_reg>:
	((Eic *)hw)->INTENSET.reg = data;
	((Eic *)hw)->INTENCLR.reg = ~data;
}

static inline void hri_eic_clear_INTEN_reg(const void *const hw, hri_eic_intenset_reg_t mask)
{
    2914:	b480      	push	{r7}
    2916:	b083      	sub	sp, #12
    2918:	af00      	add	r7, sp, #0
    291a:	6078      	str	r0, [r7, #4]
    291c:	6039      	str	r1, [r7, #0]
	((Eic *)hw)->INTENCLR.reg = mask;
    291e:	687b      	ldr	r3, [r7, #4]
    2920:	683a      	ldr	r2, [r7, #0]
    2922:	60da      	str	r2, [r3, #12]
}
    2924:	bf00      	nop
    2926:	370c      	adds	r7, #12
    2928:	46bd      	mov	sp, r7
    292a:	f85d 7b04 	ldr.w	r7, [sp], #4
    292e:	4770      	bx	lr

00002930 <hri_eic_set_CTRLA_ENABLE_bit>:
	tmp = (tmp & EIC_CTRLA_SWRST) >> EIC_CTRLA_SWRST_Pos;
	return (bool)tmp;
}

static inline void hri_eic_set_CTRLA_ENABLE_bit(const void *const hw)
{
    2930:	b580      	push	{r7, lr}
    2932:	b082      	sub	sp, #8
    2934:	af00      	add	r7, sp, #0
    2936:	6078      	str	r0, [r7, #4]
	EIC_CRITICAL_SECTION_ENTER();
	((Eic *)hw)->CTRLA.reg |= EIC_CTRLA_ENABLE;
    2938:	687b      	ldr	r3, [r7, #4]
    293a:	781b      	ldrb	r3, [r3, #0]
    293c:	b2db      	uxtb	r3, r3
    293e:	f043 0302 	orr.w	r3, r3, #2
    2942:	b2da      	uxtb	r2, r3
    2944:	687b      	ldr	r3, [r7, #4]
    2946:	701a      	strb	r2, [r3, #0]
	hri_eic_wait_for_sync(hw, EIC_SYNCBUSY_SWRST | EIC_SYNCBUSY_ENABLE);
    2948:	2103      	movs	r1, #3
    294a:	6878      	ldr	r0, [r7, #4]
    294c:	4b02      	ldr	r3, [pc, #8]	; (2958 <hri_eic_set_CTRLA_ENABLE_bit+0x28>)
    294e:	4798      	blx	r3
	EIC_CRITICAL_SECTION_LEAVE();
}
    2950:	bf00      	nop
    2952:	3708      	adds	r7, #8
    2954:	46bd      	mov	sp, r7
    2956:	bd80      	pop	{r7, pc}
    2958:	00002879 	.word	0x00002879

0000295c <hri_eic_clear_CTRLA_ENABLE_bit>:
	hri_eic_wait_for_sync(hw, EIC_SYNCBUSY_SWRST | EIC_SYNCBUSY_ENABLE);
	EIC_CRITICAL_SECTION_LEAVE();
}

static inline void hri_eic_clear_CTRLA_ENABLE_bit(const void *const hw)
{
    295c:	b580      	push	{r7, lr}
    295e:	b082      	sub	sp, #8
    2960:	af00      	add	r7, sp, #0
    2962:	6078      	str	r0, [r7, #4]
	EIC_CRITICAL_SECTION_ENTER();
	((Eic *)hw)->CTRLA.reg &= ~EIC_CTRLA_ENABLE;
    2964:	687b      	ldr	r3, [r7, #4]
    2966:	781b      	ldrb	r3, [r3, #0]
    2968:	b2db      	uxtb	r3, r3
    296a:	f023 0302 	bic.w	r3, r3, #2
    296e:	b2da      	uxtb	r2, r3
    2970:	687b      	ldr	r3, [r7, #4]
    2972:	701a      	strb	r2, [r3, #0]
	hri_eic_wait_for_sync(hw, EIC_SYNCBUSY_SWRST | EIC_SYNCBUSY_ENABLE);
    2974:	2103      	movs	r1, #3
    2976:	6878      	ldr	r0, [r7, #4]
    2978:	4b02      	ldr	r3, [pc, #8]	; (2984 <hri_eic_clear_CTRLA_ENABLE_bit+0x28>)
    297a:	4798      	blx	r3
	EIC_CRITICAL_SECTION_LEAVE();
}
    297c:	bf00      	nop
    297e:	3708      	adds	r7, #8
    2980:	46bd      	mov	sp, r7
    2982:	bd80      	pop	{r7, pc}
    2984:	00002879 	.word	0x00002879

00002988 <hri_eic_write_CTRLA_CKSEL_bit>:
	tmp = (tmp & EIC_CTRLA_CKSEL) >> EIC_CTRLA_CKSEL_Pos;
	return (bool)tmp;
}

static inline void hri_eic_write_CTRLA_CKSEL_bit(const void *const hw, bool value)
{
    2988:	b580      	push	{r7, lr}
    298a:	b084      	sub	sp, #16
    298c:	af00      	add	r7, sp, #0
    298e:	6078      	str	r0, [r7, #4]
    2990:	460b      	mov	r3, r1
    2992:	70fb      	strb	r3, [r7, #3]
	uint8_t tmp;
	EIC_CRITICAL_SECTION_ENTER();
	tmp = ((Eic *)hw)->CTRLA.reg;
    2994:	687b      	ldr	r3, [r7, #4]
    2996:	781b      	ldrb	r3, [r3, #0]
    2998:	73fb      	strb	r3, [r7, #15]
	tmp &= ~EIC_CTRLA_CKSEL;
    299a:	7bfb      	ldrb	r3, [r7, #15]
    299c:	f023 0310 	bic.w	r3, r3, #16
    29a0:	73fb      	strb	r3, [r7, #15]
	tmp |= value << EIC_CTRLA_CKSEL_Pos;
    29a2:	78fb      	ldrb	r3, [r7, #3]
    29a4:	011b      	lsls	r3, r3, #4
    29a6:	b25a      	sxtb	r2, r3
    29a8:	f997 300f 	ldrsb.w	r3, [r7, #15]
    29ac:	4313      	orrs	r3, r2
    29ae:	b25b      	sxtb	r3, r3
    29b0:	73fb      	strb	r3, [r7, #15]
	((Eic *)hw)->CTRLA.reg = tmp;
    29b2:	687b      	ldr	r3, [r7, #4]
    29b4:	7bfa      	ldrb	r2, [r7, #15]
    29b6:	701a      	strb	r2, [r3, #0]
	hri_eic_wait_for_sync(hw, EIC_SYNCBUSY_MASK);
    29b8:	2103      	movs	r1, #3
    29ba:	6878      	ldr	r0, [r7, #4]
    29bc:	4b02      	ldr	r3, [pc, #8]	; (29c8 <hri_eic_write_CTRLA_CKSEL_bit+0x40>)
    29be:	4798      	blx	r3
	EIC_CRITICAL_SECTION_LEAVE();
}
    29c0:	bf00      	nop
    29c2:	3710      	adds	r7, #16
    29c4:	46bd      	mov	sp, r7
    29c6:	bd80      	pop	{r7, pc}
    29c8:	00002879 	.word	0x00002879

000029cc <hri_eic_get_CTRLA_reg>:
	hri_eic_wait_for_sync(hw, EIC_SYNCBUSY_MASK);
	EIC_CRITICAL_SECTION_LEAVE();
}

static inline hri_eic_ctrla_reg_t hri_eic_get_CTRLA_reg(const void *const hw, hri_eic_ctrla_reg_t mask)
{
    29cc:	b580      	push	{r7, lr}
    29ce:	b084      	sub	sp, #16
    29d0:	af00      	add	r7, sp, #0
    29d2:	6078      	str	r0, [r7, #4]
    29d4:	460b      	mov	r3, r1
    29d6:	70fb      	strb	r3, [r7, #3]
	uint8_t tmp;
	hri_eic_wait_for_sync(hw, EIC_SYNCBUSY_MASK);
    29d8:	2103      	movs	r1, #3
    29da:	6878      	ldr	r0, [r7, #4]
    29dc:	4b06      	ldr	r3, [pc, #24]	; (29f8 <hri_eic_get_CTRLA_reg+0x2c>)
    29de:	4798      	blx	r3
	tmp = ((Eic *)hw)->CTRLA.reg;
    29e0:	687b      	ldr	r3, [r7, #4]
    29e2:	781b      	ldrb	r3, [r3, #0]
    29e4:	73fb      	strb	r3, [r7, #15]
	tmp &= mask;
    29e6:	7bfa      	ldrb	r2, [r7, #15]
    29e8:	78fb      	ldrb	r3, [r7, #3]
    29ea:	4013      	ands	r3, r2
    29ec:	73fb      	strb	r3, [r7, #15]
	return tmp;
    29ee:	7bfb      	ldrb	r3, [r7, #15]
}
    29f0:	4618      	mov	r0, r3
    29f2:	3710      	adds	r7, #16
    29f4:	46bd      	mov	sp, r7
    29f6:	bd80      	pop	{r7, pc}
    29f8:	00002879 	.word	0x00002879

000029fc <hri_eic_write_CTRLA_reg>:

static inline void hri_eic_write_CTRLA_reg(const void *const hw, hri_eic_ctrla_reg_t data)
{
    29fc:	b580      	push	{r7, lr}
    29fe:	b082      	sub	sp, #8
    2a00:	af00      	add	r7, sp, #0
    2a02:	6078      	str	r0, [r7, #4]
    2a04:	460b      	mov	r3, r1
    2a06:	70fb      	strb	r3, [r7, #3]
	EIC_CRITICAL_SECTION_ENTER();
	((Eic *)hw)->CTRLA.reg = data;
    2a08:	687b      	ldr	r3, [r7, #4]
    2a0a:	78fa      	ldrb	r2, [r7, #3]
    2a0c:	701a      	strb	r2, [r3, #0]
	hri_eic_wait_for_sync(hw, EIC_SYNCBUSY_MASK);
    2a0e:	2103      	movs	r1, #3
    2a10:	6878      	ldr	r0, [r7, #4]
    2a12:	4b03      	ldr	r3, [pc, #12]	; (2a20 <hri_eic_write_CTRLA_reg+0x24>)
    2a14:	4798      	blx	r3
	EIC_CRITICAL_SECTION_LEAVE();
}
    2a16:	bf00      	nop
    2a18:	3708      	adds	r7, #8
    2a1a:	46bd      	mov	sp, r7
    2a1c:	bd80      	pop	{r7, pc}
    2a1e:	bf00      	nop
    2a20:	00002879 	.word	0x00002879

00002a24 <hri_eic_write_NMICTRL_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_eic_write_NMICTRL_reg(const void *const hw, hri_eic_nmictrl_reg_t data)
{
    2a24:	b480      	push	{r7}
    2a26:	b083      	sub	sp, #12
    2a28:	af00      	add	r7, sp, #0
    2a2a:	6078      	str	r0, [r7, #4]
    2a2c:	460b      	mov	r3, r1
    2a2e:	70fb      	strb	r3, [r7, #3]
	EIC_CRITICAL_SECTION_ENTER();
	((Eic *)hw)->NMICTRL.reg = data;
    2a30:	687b      	ldr	r3, [r7, #4]
    2a32:	78fa      	ldrb	r2, [r7, #3]
    2a34:	705a      	strb	r2, [r3, #1]
	EIC_CRITICAL_SECTION_LEAVE();
}
    2a36:	bf00      	nop
    2a38:	370c      	adds	r7, #12
    2a3a:	46bd      	mov	sp, r7
    2a3c:	f85d 7b04 	ldr.w	r7, [sp], #4
    2a40:	4770      	bx	lr

00002a42 <hri_eic_write_EVCTRL_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_eic_write_EVCTRL_reg(const void *const hw, hri_eic_evctrl_reg_t data)
{
    2a42:	b480      	push	{r7}
    2a44:	b083      	sub	sp, #12
    2a46:	af00      	add	r7, sp, #0
    2a48:	6078      	str	r0, [r7, #4]
    2a4a:	6039      	str	r1, [r7, #0]
	EIC_CRITICAL_SECTION_ENTER();
	((Eic *)hw)->EVCTRL.reg = data;
    2a4c:	687b      	ldr	r3, [r7, #4]
    2a4e:	683a      	ldr	r2, [r7, #0]
    2a50:	609a      	str	r2, [r3, #8]
	EIC_CRITICAL_SECTION_LEAVE();
}
    2a52:	bf00      	nop
    2a54:	370c      	adds	r7, #12
    2a56:	46bd      	mov	sp, r7
    2a58:	f85d 7b04 	ldr.w	r7, [sp], #4
    2a5c:	4770      	bx	lr

00002a5e <hri_eic_write_ASYNCH_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_eic_write_ASYNCH_reg(const void *const hw, hri_eic_asynch_reg_t data)
{
    2a5e:	b480      	push	{r7}
    2a60:	b083      	sub	sp, #12
    2a62:	af00      	add	r7, sp, #0
    2a64:	6078      	str	r0, [r7, #4]
    2a66:	6039      	str	r1, [r7, #0]
	EIC_CRITICAL_SECTION_ENTER();
	((Eic *)hw)->ASYNCH.reg = data;
    2a68:	687b      	ldr	r3, [r7, #4]
    2a6a:	683a      	ldr	r2, [r7, #0]
    2a6c:	619a      	str	r2, [r3, #24]
	EIC_CRITICAL_SECTION_LEAVE();
}
    2a6e:	bf00      	nop
    2a70:	370c      	adds	r7, #12
    2a72:	46bd      	mov	sp, r7
    2a74:	f85d 7b04 	ldr.w	r7, [sp], #4
    2a78:	4770      	bx	lr

00002a7a <hri_eic_write_CONFIG_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_eic_write_CONFIG_reg(const void *const hw, uint8_t index, hri_eic_config_reg_t data)
{
    2a7a:	b480      	push	{r7}
    2a7c:	b085      	sub	sp, #20
    2a7e:	af00      	add	r7, sp, #0
    2a80:	60f8      	str	r0, [r7, #12]
    2a82:	460b      	mov	r3, r1
    2a84:	607a      	str	r2, [r7, #4]
    2a86:	72fb      	strb	r3, [r7, #11]
	EIC_CRITICAL_SECTION_ENTER();
	((Eic *)hw)->CONFIG[index].reg = data;
    2a88:	7afb      	ldrb	r3, [r7, #11]
    2a8a:	68fa      	ldr	r2, [r7, #12]
    2a8c:	3306      	adds	r3, #6
    2a8e:	009b      	lsls	r3, r3, #2
    2a90:	4413      	add	r3, r2
    2a92:	687a      	ldr	r2, [r7, #4]
    2a94:	605a      	str	r2, [r3, #4]
	EIC_CRITICAL_SECTION_LEAVE();
}
    2a96:	bf00      	nop
    2a98:	3714      	adds	r7, #20
    2a9a:	46bd      	mov	sp, r7
    2a9c:	f85d 7b04 	ldr.w	r7, [sp], #4
    2aa0:	4770      	bx	lr

00002aa2 <hri_eic_write_DEBOUNCEN_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_eic_write_DEBOUNCEN_reg(const void *const hw, hri_eic_debouncen_reg_t data)
{
    2aa2:	b480      	push	{r7}
    2aa4:	b083      	sub	sp, #12
    2aa6:	af00      	add	r7, sp, #0
    2aa8:	6078      	str	r0, [r7, #4]
    2aaa:	6039      	str	r1, [r7, #0]
	EIC_CRITICAL_SECTION_ENTER();
	((Eic *)hw)->DEBOUNCEN.reg = data;
    2aac:	687b      	ldr	r3, [r7, #4]
    2aae:	683a      	ldr	r2, [r7, #0]
    2ab0:	631a      	str	r2, [r3, #48]	; 0x30
	EIC_CRITICAL_SECTION_LEAVE();
}
    2ab2:	bf00      	nop
    2ab4:	370c      	adds	r7, #12
    2ab6:	46bd      	mov	sp, r7
    2ab8:	f85d 7b04 	ldr.w	r7, [sp], #4
    2abc:	4770      	bx	lr

00002abe <hri_eic_write_DPRESCALER_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_eic_write_DPRESCALER_reg(const void *const hw, hri_eic_dprescaler_reg_t data)
{
    2abe:	b480      	push	{r7}
    2ac0:	b083      	sub	sp, #12
    2ac2:	af00      	add	r7, sp, #0
    2ac4:	6078      	str	r0, [r7, #4]
    2ac6:	6039      	str	r1, [r7, #0]
	EIC_CRITICAL_SECTION_ENTER();
	((Eic *)hw)->DPRESCALER.reg = data;
    2ac8:	687b      	ldr	r3, [r7, #4]
    2aca:	683a      	ldr	r2, [r7, #0]
    2acc:	635a      	str	r2, [r3, #52]	; 0x34
	EIC_CRITICAL_SECTION_LEAVE();
}
    2ace:	bf00      	nop
    2ad0:	370c      	adds	r7, #12
    2ad2:	46bd      	mov	sp, r7
    2ad4:	f85d 7b04 	ldr.w	r7, [sp], #4
    2ad8:	4770      	bx	lr
	...

00002adc <_ext_irq_init>:

/**
 * \brief Initialize external interrupt module
 */
int32_t _ext_irq_init(void (*cb)(const uint32_t pin))
{
    2adc:	b580      	push	{r7, lr}
    2ade:	b082      	sub	sp, #8
    2ae0:	af00      	add	r7, sp, #0
    2ae2:	6078      	str	r0, [r7, #4]
	if (!hri_eic_is_syncing(EIC, EIC_SYNCBUSY_SWRST)) {
    2ae4:	2101      	movs	r1, #1
    2ae6:	4830      	ldr	r0, [pc, #192]	; (2ba8 <_ext_irq_init+0xcc>)
    2ae8:	4b30      	ldr	r3, [pc, #192]	; (2bac <_ext_irq_init+0xd0>)
    2aea:	4798      	blx	r3
    2aec:	4603      	mov	r3, r0
    2aee:	f083 0301 	eor.w	r3, r3, #1
    2af2:	b2db      	uxtb	r3, r3
    2af4:	2b00      	cmp	r3, #0
    2af6:	d011      	beq.n	2b1c <_ext_irq_init+0x40>
		if (hri_eic_get_CTRLA_reg(EIC, EIC_CTRLA_ENABLE)) {
    2af8:	2102      	movs	r1, #2
    2afa:	482b      	ldr	r0, [pc, #172]	; (2ba8 <_ext_irq_init+0xcc>)
    2afc:	4b2c      	ldr	r3, [pc, #176]	; (2bb0 <_ext_irq_init+0xd4>)
    2afe:	4798      	blx	r3
    2b00:	4603      	mov	r3, r0
    2b02:	2b00      	cmp	r3, #0
    2b04:	d006      	beq.n	2b14 <_ext_irq_init+0x38>
			hri_eic_clear_CTRLA_ENABLE_bit(EIC);
    2b06:	4828      	ldr	r0, [pc, #160]	; (2ba8 <_ext_irq_init+0xcc>)
    2b08:	4b2a      	ldr	r3, [pc, #168]	; (2bb4 <_ext_irq_init+0xd8>)
    2b0a:	4798      	blx	r3
			hri_eic_wait_for_sync(EIC, EIC_SYNCBUSY_ENABLE);
    2b0c:	2102      	movs	r1, #2
    2b0e:	4826      	ldr	r0, [pc, #152]	; (2ba8 <_ext_irq_init+0xcc>)
    2b10:	4b29      	ldr	r3, [pc, #164]	; (2bb8 <_ext_irq_init+0xdc>)
    2b12:	4798      	blx	r3
		}
		hri_eic_write_CTRLA_reg(EIC, EIC_CTRLA_SWRST);
    2b14:	2101      	movs	r1, #1
    2b16:	4824      	ldr	r0, [pc, #144]	; (2ba8 <_ext_irq_init+0xcc>)
    2b18:	4b28      	ldr	r3, [pc, #160]	; (2bbc <_ext_irq_init+0xe0>)
    2b1a:	4798      	blx	r3
	}
	hri_eic_wait_for_sync(EIC, EIC_SYNCBUSY_SWRST);
    2b1c:	2101      	movs	r1, #1
    2b1e:	4822      	ldr	r0, [pc, #136]	; (2ba8 <_ext_irq_init+0xcc>)
    2b20:	4b25      	ldr	r3, [pc, #148]	; (2bb8 <_ext_irq_init+0xdc>)
    2b22:	4798      	blx	r3

	hri_eic_write_CTRLA_CKSEL_bit(EIC, CONF_EIC_CKSEL);
    2b24:	2100      	movs	r1, #0
    2b26:	4820      	ldr	r0, [pc, #128]	; (2ba8 <_ext_irq_init+0xcc>)
    2b28:	4b25      	ldr	r3, [pc, #148]	; (2bc0 <_ext_irq_init+0xe4>)
    2b2a:	4798      	blx	r3

	hri_eic_write_NMICTRL_reg(EIC,
    2b2c:	2100      	movs	r1, #0
    2b2e:	481e      	ldr	r0, [pc, #120]	; (2ba8 <_ext_irq_init+0xcc>)
    2b30:	4b24      	ldr	r3, [pc, #144]	; (2bc4 <_ext_irq_init+0xe8>)
    2b32:	4798      	blx	r3
	                          (CONF_EIC_NMIFILTEN << EIC_NMICTRL_NMIFILTEN_Pos)
	                              | EIC_NMICTRL_NMISENSE(CONF_EIC_NMISENSE) | EIC_ASYNCH_ASYNCH(CONF_EIC_NMIASYNCH)
	                              | 0);

	hri_eic_write_EVCTRL_reg(EIC,
    2b34:	f44f 5180 	mov.w	r1, #4096	; 0x1000
    2b38:	481b      	ldr	r0, [pc, #108]	; (2ba8 <_ext_irq_init+0xcc>)
    2b3a:	4b23      	ldr	r3, [pc, #140]	; (2bc8 <_ext_irq_init+0xec>)
    2b3c:	4798      	blx	r3
	                             | (CONF_EIC_EXTINTEO3 << 3) | (CONF_EIC_EXTINTEO4 << 4) | (CONF_EIC_EXTINTEO5 << 5)
	                             | (CONF_EIC_EXTINTEO6 << 6) | (CONF_EIC_EXTINTEO7 << 7) | (CONF_EIC_EXTINTEO8 << 8)
	                             | (CONF_EIC_EXTINTEO9 << 9) | (CONF_EIC_EXTINTEO10 << 10) | (CONF_EIC_EXTINTEO11 << 11)
	                             | (CONF_EIC_EXTINTEO12 << 12) | (CONF_EIC_EXTINTEO13 << 13)
	                             | (CONF_EIC_EXTINTEO14 << 14) | (CONF_EIC_EXTINTEO15 << 15) | 0);
	hri_eic_write_ASYNCH_reg(EIC,
    2b3e:	2100      	movs	r1, #0
    2b40:	4819      	ldr	r0, [pc, #100]	; (2ba8 <_ext_irq_init+0xcc>)
    2b42:	4b22      	ldr	r3, [pc, #136]	; (2bcc <_ext_irq_init+0xf0>)
    2b44:	4798      	blx	r3
	                             | (CONF_EIC_ASYNCH3 << 3) | (CONF_EIC_ASYNCH4 << 4) | (CONF_EIC_ASYNCH5 << 5)
	                             | (CONF_EIC_ASYNCH6 << 6) | (CONF_EIC_ASYNCH7 << 7) | (CONF_EIC_ASYNCH8 << 8)
	                             | (CONF_EIC_ASYNCH9 << 9) | (CONF_EIC_ASYNCH10 << 10) | (CONF_EIC_ASYNCH11 << 11)
	                             | (CONF_EIC_ASYNCH12 << 12) | (CONF_EIC_ASYNCH13 << 13) | (CONF_EIC_ASYNCH14 << 14)
	                             | (CONF_EIC_ASYNCH15 << 15) | 0);
	hri_eic_write_DEBOUNCEN_reg(
    2b46:	f44f 5180 	mov.w	r1, #4096	; 0x1000
    2b4a:	4817      	ldr	r0, [pc, #92]	; (2ba8 <_ext_irq_init+0xcc>)
    2b4c:	4b20      	ldr	r3, [pc, #128]	; (2bd0 <_ext_irq_init+0xf4>)
    2b4e:	4798      	blx	r3
	        | (CONF_EIC_DEBOUNCE_ENABLE6 << 6) | (CONF_EIC_DEBOUNCE_ENABLE7 << 7) | (CONF_EIC_DEBOUNCE_ENABLE8 << 8)
	        | (CONF_EIC_DEBOUNCE_ENABLE9 << 9) | (CONF_EIC_DEBOUNCE_ENABLE10 << 10) | (CONF_EIC_DEBOUNCE_ENABLE11 << 11)
	        | (CONF_EIC_DEBOUNCE_ENABLE12 << 12) | (CONF_EIC_DEBOUNCE_ENABLE13 << 13)
	        | (CONF_EIC_DEBOUNCE_ENABLE14 << 14) | (CONF_EIC_DEBOUNCE_ENABLE15 << 15) | 0);

	hri_eic_write_DPRESCALER_reg(
    2b50:	2100      	movs	r1, #0
    2b52:	4815      	ldr	r0, [pc, #84]	; (2ba8 <_ext_irq_init+0xcc>)
    2b54:	4b1f      	ldr	r3, [pc, #124]	; (2bd4 <_ext_irq_init+0xf8>)
    2b56:	4798      	blx	r3
	    EIC,
	    (EIC_DPRESCALER_PRESCALER0(CONF_EIC_DPRESCALER0)) | (CONF_EIC_STATES0 << EIC_DPRESCALER_STATES0_Pos)
	        | (EIC_DPRESCALER_PRESCALER1(CONF_EIC_DPRESCALER1)) | (CONF_EIC_STATES1 << EIC_DPRESCALER_STATES1_Pos)
	        | CONF_EIC_TICKON << EIC_DPRESCALER_TICKON_Pos | 0);

	hri_eic_write_CONFIG_reg(EIC,
    2b58:	2200      	movs	r2, #0
    2b5a:	2100      	movs	r1, #0
    2b5c:	4812      	ldr	r0, [pc, #72]	; (2ba8 <_ext_irq_init+0xcc>)
    2b5e:	4b1e      	ldr	r3, [pc, #120]	; (2bd8 <_ext_irq_init+0xfc>)
    2b60:	4798      	blx	r3
	                             | (CONF_EIC_FILTEN5 << EIC_CONFIG_FILTEN5_Pos) | EIC_CONFIG_SENSE5(CONF_EIC_SENSE5)
	                             | (CONF_EIC_FILTEN6 << EIC_CONFIG_FILTEN6_Pos) | EIC_CONFIG_SENSE6(CONF_EIC_SENSE6)
	                             | (CONF_EIC_FILTEN7 << EIC_CONFIG_FILTEN7_Pos) | EIC_CONFIG_SENSE7(CONF_EIC_SENSE7)
	                             | 0);

	hri_eic_write_CONFIG_reg(EIC,
    2b62:	f44f 3280 	mov.w	r2, #65536	; 0x10000
    2b66:	2101      	movs	r1, #1
    2b68:	480f      	ldr	r0, [pc, #60]	; (2ba8 <_ext_irq_init+0xcc>)
    2b6a:	4b1b      	ldr	r3, [pc, #108]	; (2bd8 <_ext_irq_init+0xfc>)
    2b6c:	4798      	blx	r3
	                             | (CONF_EIC_FILTEN13 << EIC_CONFIG_FILTEN5_Pos) | EIC_CONFIG_SENSE5(CONF_EIC_SENSE13)
	                             | (CONF_EIC_FILTEN14 << EIC_CONFIG_FILTEN6_Pos) | EIC_CONFIG_SENSE6(CONF_EIC_SENSE14)
	                             | (CONF_EIC_FILTEN15 << EIC_CONFIG_FILTEN7_Pos) | EIC_CONFIG_SENSE7(CONF_EIC_SENSE15)
	                             | 0);

	hri_eic_set_CTRLA_ENABLE_bit(EIC);
    2b6e:	480e      	ldr	r0, [pc, #56]	; (2ba8 <_ext_irq_init+0xcc>)
    2b70:	4b1a      	ldr	r3, [pc, #104]	; (2bdc <_ext_irq_init+0x100>)
    2b72:	4798      	blx	r3
	NVIC_DisableIRQ(EIC_12_IRQn);
    2b74:	2018      	movs	r0, #24
    2b76:	4b1a      	ldr	r3, [pc, #104]	; (2be0 <_ext_irq_init+0x104>)
    2b78:	4798      	blx	r3
	NVIC_ClearPendingIRQ(EIC_12_IRQn);
    2b7a:	2018      	movs	r0, #24
    2b7c:	4b19      	ldr	r3, [pc, #100]	; (2be4 <_ext_irq_init+0x108>)
    2b7e:	4798      	blx	r3
	NVIC_EnableIRQ(EIC_12_IRQn);
    2b80:	2018      	movs	r0, #24
    2b82:	4b19      	ldr	r3, [pc, #100]	; (2be8 <_ext_irq_init+0x10c>)
    2b84:	4798      	blx	r3
	NVIC_DisableIRQ(EIC_13_IRQn);
    2b86:	2019      	movs	r0, #25
    2b88:	4b15      	ldr	r3, [pc, #84]	; (2be0 <_ext_irq_init+0x104>)
    2b8a:	4798      	blx	r3
	NVIC_ClearPendingIRQ(EIC_13_IRQn);
    2b8c:	2019      	movs	r0, #25
    2b8e:	4b15      	ldr	r3, [pc, #84]	; (2be4 <_ext_irq_init+0x108>)
    2b90:	4798      	blx	r3
	NVIC_EnableIRQ(EIC_13_IRQn);
    2b92:	2019      	movs	r0, #25
    2b94:	4b14      	ldr	r3, [pc, #80]	; (2be8 <_ext_irq_init+0x10c>)
    2b96:	4798      	blx	r3

	callback = cb;
    2b98:	4a14      	ldr	r2, [pc, #80]	; (2bec <_ext_irq_init+0x110>)
    2b9a:	687b      	ldr	r3, [r7, #4]
    2b9c:	6013      	str	r3, [r2, #0]

	return ERR_NONE;
    2b9e:	2300      	movs	r3, #0
}
    2ba0:	4618      	mov	r0, r3
    2ba2:	3708      	adds	r7, #8
    2ba4:	46bd      	mov	sp, r7
    2ba6:	bd80      	pop	{r7, pc}
    2ba8:	40002800 	.word	0x40002800
    2bac:	0000289d 	.word	0x0000289d
    2bb0:	000029cd 	.word	0x000029cd
    2bb4:	0000295d 	.word	0x0000295d
    2bb8:	00002879 	.word	0x00002879
    2bbc:	000029fd 	.word	0x000029fd
    2bc0:	00002989 	.word	0x00002989
    2bc4:	00002a25 	.word	0x00002a25
    2bc8:	00002a43 	.word	0x00002a43
    2bcc:	00002a5f 	.word	0x00002a5f
    2bd0:	00002aa3 	.word	0x00002aa3
    2bd4:	00002abf 	.word	0x00002abf
    2bd8:	00002a7b 	.word	0x00002a7b
    2bdc:	00002931 	.word	0x00002931
    2be0:	000027f9 	.word	0x000027f9
    2be4:	0000283d 	.word	0x0000283d
    2be8:	000027bd 	.word	0x000027bd
    2bec:	20000aa0 	.word	0x20000aa0

00002bf0 <_ext_irq_enable>:

/**
 * \brief Enable / disable external irq
 */
int32_t _ext_irq_enable(const uint32_t pin, const bool enable)
{
    2bf0:	b580      	push	{r7, lr}
    2bf2:	b084      	sub	sp, #16
    2bf4:	af00      	add	r7, sp, #0
    2bf6:	6078      	str	r0, [r7, #4]
    2bf8:	460b      	mov	r3, r1
    2bfa:	70fb      	strb	r3, [r7, #3]
	uint8_t extint = INVALID_EXTINT_NUMBER;
    2bfc:	23ff      	movs	r3, #255	; 0xff
    2bfe:	73fb      	strb	r3, [r7, #15]
	uint8_t i      = 0;
    2c00:	2300      	movs	r3, #0
    2c02:	73bb      	strb	r3, [r7, #14]

	for (; i < ARRAY_SIZE(_map); i++) {
    2c04:	e010      	b.n	2c28 <_ext_irq_enable+0x38>
		if (_map[i].pin == pin) {
    2c06:	7bbb      	ldrb	r3, [r7, #14]
    2c08:	4a1c      	ldr	r2, [pc, #112]	; (2c7c <_ext_irq_enable+0x8c>)
    2c0a:	00db      	lsls	r3, r3, #3
    2c0c:	4413      	add	r3, r2
    2c0e:	685a      	ldr	r2, [r3, #4]
    2c10:	687b      	ldr	r3, [r7, #4]
    2c12:	429a      	cmp	r2, r3
    2c14:	d105      	bne.n	2c22 <_ext_irq_enable+0x32>
			extint = _map[i].extint;
    2c16:	7bbb      	ldrb	r3, [r7, #14]
    2c18:	4a18      	ldr	r2, [pc, #96]	; (2c7c <_ext_irq_enable+0x8c>)
    2c1a:	f812 3033 	ldrb.w	r3, [r2, r3, lsl #3]
    2c1e:	73fb      	strb	r3, [r7, #15]
			break;
    2c20:	e005      	b.n	2c2e <_ext_irq_enable+0x3e>
	for (; i < ARRAY_SIZE(_map); i++) {
    2c22:	7bbb      	ldrb	r3, [r7, #14]
    2c24:	3301      	adds	r3, #1
    2c26:	73bb      	strb	r3, [r7, #14]
    2c28:	7bbb      	ldrb	r3, [r7, #14]
    2c2a:	2b01      	cmp	r3, #1
    2c2c:	d9eb      	bls.n	2c06 <_ext_irq_enable+0x16>
		}
	}
	if (INVALID_EXTINT_NUMBER == extint) {
    2c2e:	7bfb      	ldrb	r3, [r7, #15]
    2c30:	2bff      	cmp	r3, #255	; 0xff
    2c32:	d102      	bne.n	2c3a <_ext_irq_enable+0x4a>
		return -1;
    2c34:	f04f 33ff 	mov.w	r3, #4294967295
    2c38:	e01c      	b.n	2c74 <_ext_irq_enable+0x84>
	}

	if (enable) {
    2c3a:	78fb      	ldrb	r3, [r7, #3]
    2c3c:	2b00      	cmp	r3, #0
    2c3e:	d008      	beq.n	2c52 <_ext_irq_enable+0x62>
		hri_eic_set_INTEN_reg(EIC, 1ul << extint);
    2c40:	7bfb      	ldrb	r3, [r7, #15]
    2c42:	2201      	movs	r2, #1
    2c44:	fa02 f303 	lsl.w	r3, r2, r3
    2c48:	4619      	mov	r1, r3
    2c4a:	480d      	ldr	r0, [pc, #52]	; (2c80 <_ext_irq_enable+0x90>)
    2c4c:	4b0d      	ldr	r3, [pc, #52]	; (2c84 <_ext_irq_enable+0x94>)
    2c4e:	4798      	blx	r3
    2c50:	e00f      	b.n	2c72 <_ext_irq_enable+0x82>
	} else {
		hri_eic_clear_INTEN_reg(EIC, 1ul << extint);
    2c52:	7bfb      	ldrb	r3, [r7, #15]
    2c54:	2201      	movs	r2, #1
    2c56:	fa02 f303 	lsl.w	r3, r2, r3
    2c5a:	4619      	mov	r1, r3
    2c5c:	4808      	ldr	r0, [pc, #32]	; (2c80 <_ext_irq_enable+0x90>)
    2c5e:	4b0a      	ldr	r3, [pc, #40]	; (2c88 <_ext_irq_enable+0x98>)
    2c60:	4798      	blx	r3
		hri_eic_clear_INTFLAG_reg(EIC, 1ul << extint);
    2c62:	7bfb      	ldrb	r3, [r7, #15]
    2c64:	2201      	movs	r2, #1
    2c66:	fa02 f303 	lsl.w	r3, r2, r3
    2c6a:	4619      	mov	r1, r3
    2c6c:	4804      	ldr	r0, [pc, #16]	; (2c80 <_ext_irq_enable+0x90>)
    2c6e:	4b07      	ldr	r3, [pc, #28]	; (2c8c <_ext_irq_enable+0x9c>)
    2c70:	4798      	blx	r3
	}

	return ERR_NONE;
    2c72:	2300      	movs	r3, #0
}
    2c74:	4618      	mov	r0, r3
    2c76:	3710      	adds	r7, #16
    2c78:	46bd      	mov	sp, r7
    2c7a:	bd80      	pop	{r7, pc}
    2c7c:	00005ca8 	.word	0x00005ca8
    2c80:	40002800 	.word	0x40002800
    2c84:	000028f9 	.word	0x000028f9
    2c88:	00002915 	.word	0x00002915
    2c8c:	000028dd 	.word	0x000028dd

00002c90 <_ext_irq_handler>:

/**
 * \brief Inter EIC interrupt handler
 */
static void _ext_irq_handler(void)
{
    2c90:	b580      	push	{r7, lr}
    2c92:	b084      	sub	sp, #16
    2c94:	af00      	add	r7, sp, #0
	volatile uint32_t flags = hri_eic_read_INTFLAG_reg(EIC);
    2c96:	4841      	ldr	r0, [pc, #260]	; (2d9c <_ext_irq_handler+0x10c>)
    2c98:	4b41      	ldr	r3, [pc, #260]	; (2da0 <_ext_irq_handler+0x110>)
    2c9a:	4798      	blx	r3
    2c9c:	4603      	mov	r3, r0
    2c9e:	603b      	str	r3, [r7, #0]
	int8_t            pos;
	uint32_t          pin = INVALID_PIN_NUMBER;
    2ca0:	f04f 33ff 	mov.w	r3, #4294967295
    2ca4:	60bb      	str	r3, [r7, #8]

	hri_eic_clear_INTFLAG_reg(EIC, flags);
    2ca6:	683b      	ldr	r3, [r7, #0]
    2ca8:	4619      	mov	r1, r3
    2caa:	483c      	ldr	r0, [pc, #240]	; (2d9c <_ext_irq_handler+0x10c>)
    2cac:	4b3d      	ldr	r3, [pc, #244]	; (2da4 <_ext_irq_handler+0x114>)
    2cae:	4798      	blx	r3

	ASSERT(callback);
    2cb0:	4b3d      	ldr	r3, [pc, #244]	; (2da8 <_ext_irq_handler+0x118>)
    2cb2:	681b      	ldr	r3, [r3, #0]
    2cb4:	2b00      	cmp	r3, #0
    2cb6:	bf14      	ite	ne
    2cb8:	2301      	movne	r3, #1
    2cba:	2300      	moveq	r3, #0
    2cbc:	b2db      	uxtb	r3, r3
    2cbe:	22ec      	movs	r2, #236	; 0xec
    2cc0:	493a      	ldr	r1, [pc, #232]	; (2dac <_ext_irq_handler+0x11c>)
    2cc2:	4618      	mov	r0, r3
    2cc4:	4b3a      	ldr	r3, [pc, #232]	; (2db0 <_ext_irq_handler+0x120>)
    2cc6:	4798      	blx	r3

	while (flags) {
    2cc8:	e060      	b.n	2d8c <_ext_irq_handler+0xfc>
		pos = ffs(flags) - 1;
    2cca:	683b      	ldr	r3, [r7, #0]
    2ccc:	4618      	mov	r0, r3
    2cce:	4b39      	ldr	r3, [pc, #228]	; (2db4 <_ext_irq_handler+0x124>)
    2cd0:	4798      	blx	r3
    2cd2:	4603      	mov	r3, r0
    2cd4:	b2db      	uxtb	r3, r3
    2cd6:	3b01      	subs	r3, #1
    2cd8:	b2db      	uxtb	r3, r3
    2cda:	73fb      	strb	r3, [r7, #15]
		while (-1 != pos) {
    2cdc:	e047      	b.n	2d6e <_ext_irq_handler+0xde>
			uint8_t lower = 0, middle, upper = EXT_IRQ_AMOUNT;
    2cde:	2300      	movs	r3, #0
    2ce0:	71fb      	strb	r3, [r7, #7]
    2ce2:	2302      	movs	r3, #2
    2ce4:	71bb      	strb	r3, [r7, #6]

			while (upper >= lower) {
    2ce6:	e024      	b.n	2d32 <_ext_irq_handler+0xa2>
				middle = (upper + lower) >> 1;
    2ce8:	79ba      	ldrb	r2, [r7, #6]
    2cea:	79fb      	ldrb	r3, [r7, #7]
    2cec:	4413      	add	r3, r2
    2cee:	105b      	asrs	r3, r3, #1
    2cf0:	717b      	strb	r3, [r7, #5]
				if (_map[middle].extint == pos) {
    2cf2:	797b      	ldrb	r3, [r7, #5]
    2cf4:	4a30      	ldr	r2, [pc, #192]	; (2db8 <_ext_irq_handler+0x128>)
    2cf6:	f812 3033 	ldrb.w	r3, [r2, r3, lsl #3]
    2cfa:	461a      	mov	r2, r3
    2cfc:	f997 300f 	ldrsb.w	r3, [r7, #15]
    2d00:	429a      	cmp	r2, r3
    2d02:	d106      	bne.n	2d12 <_ext_irq_handler+0x82>
					pin = _map[middle].pin;
    2d04:	797b      	ldrb	r3, [r7, #5]
    2d06:	4a2c      	ldr	r2, [pc, #176]	; (2db8 <_ext_irq_handler+0x128>)
    2d08:	00db      	lsls	r3, r3, #3
    2d0a:	4413      	add	r3, r2
    2d0c:	685b      	ldr	r3, [r3, #4]
    2d0e:	60bb      	str	r3, [r7, #8]
					break;
    2d10:	e013      	b.n	2d3a <_ext_irq_handler+0xaa>
				}
				if (_map[middle].extint < pos) {
    2d12:	797b      	ldrb	r3, [r7, #5]
    2d14:	4a28      	ldr	r2, [pc, #160]	; (2db8 <_ext_irq_handler+0x128>)
    2d16:	f812 3033 	ldrb.w	r3, [r2, r3, lsl #3]
    2d1a:	461a      	mov	r2, r3
    2d1c:	f997 300f 	ldrsb.w	r3, [r7, #15]
    2d20:	429a      	cmp	r2, r3
    2d22:	da03      	bge.n	2d2c <_ext_irq_handler+0x9c>
					lower = middle + 1;
    2d24:	797b      	ldrb	r3, [r7, #5]
    2d26:	3301      	adds	r3, #1
    2d28:	71fb      	strb	r3, [r7, #7]
    2d2a:	e002      	b.n	2d32 <_ext_irq_handler+0xa2>
				} else {
					upper = middle - 1;
    2d2c:	797b      	ldrb	r3, [r7, #5]
    2d2e:	3b01      	subs	r3, #1
    2d30:	71bb      	strb	r3, [r7, #6]
			while (upper >= lower) {
    2d32:	79ba      	ldrb	r2, [r7, #6]
    2d34:	79fb      	ldrb	r3, [r7, #7]
    2d36:	429a      	cmp	r2, r3
    2d38:	d2d6      	bcs.n	2ce8 <_ext_irq_handler+0x58>
				}
			}

			if (INVALID_PIN_NUMBER != pin) {
    2d3a:	68bb      	ldr	r3, [r7, #8]
    2d3c:	f1b3 3fff 	cmp.w	r3, #4294967295
    2d40:	d003      	beq.n	2d4a <_ext_irq_handler+0xba>
				callback(pin);
    2d42:	4b19      	ldr	r3, [pc, #100]	; (2da8 <_ext_irq_handler+0x118>)
    2d44:	681b      	ldr	r3, [r3, #0]
    2d46:	68b8      	ldr	r0, [r7, #8]
    2d48:	4798      	blx	r3
			}
			flags &= ~(1ul << pos);
    2d4a:	f997 300f 	ldrsb.w	r3, [r7, #15]
    2d4e:	2201      	movs	r2, #1
    2d50:	fa02 f303 	lsl.w	r3, r2, r3
    2d54:	43da      	mvns	r2, r3
    2d56:	683b      	ldr	r3, [r7, #0]
    2d58:	4013      	ands	r3, r2
    2d5a:	603b      	str	r3, [r7, #0]
			pos = ffs(flags) - 1;
    2d5c:	683b      	ldr	r3, [r7, #0]
    2d5e:	4618      	mov	r0, r3
    2d60:	4b14      	ldr	r3, [pc, #80]	; (2db4 <_ext_irq_handler+0x124>)
    2d62:	4798      	blx	r3
    2d64:	4603      	mov	r3, r0
    2d66:	b2db      	uxtb	r3, r3
    2d68:	3b01      	subs	r3, #1
    2d6a:	b2db      	uxtb	r3, r3
    2d6c:	73fb      	strb	r3, [r7, #15]
		while (-1 != pos) {
    2d6e:	f997 300f 	ldrsb.w	r3, [r7, #15]
    2d72:	f1b3 3fff 	cmp.w	r3, #4294967295
    2d76:	d1b2      	bne.n	2cde <_ext_irq_handler+0x4e>
		}
		flags = hri_eic_read_INTFLAG_reg(EIC);
    2d78:	4808      	ldr	r0, [pc, #32]	; (2d9c <_ext_irq_handler+0x10c>)
    2d7a:	4b09      	ldr	r3, [pc, #36]	; (2da0 <_ext_irq_handler+0x110>)
    2d7c:	4798      	blx	r3
    2d7e:	4603      	mov	r3, r0
    2d80:	603b      	str	r3, [r7, #0]
		hri_eic_clear_INTFLAG_reg(EIC, flags);
    2d82:	683b      	ldr	r3, [r7, #0]
    2d84:	4619      	mov	r1, r3
    2d86:	4805      	ldr	r0, [pc, #20]	; (2d9c <_ext_irq_handler+0x10c>)
    2d88:	4b06      	ldr	r3, [pc, #24]	; (2da4 <_ext_irq_handler+0x114>)
    2d8a:	4798      	blx	r3
	while (flags) {
    2d8c:	683b      	ldr	r3, [r7, #0]
    2d8e:	2b00      	cmp	r3, #0
    2d90:	d19b      	bne.n	2cca <_ext_irq_handler+0x3a>
	}
}
    2d92:	bf00      	nop
    2d94:	3710      	adds	r7, #16
    2d96:	46bd      	mov	sp, r7
    2d98:	bd80      	pop	{r7, pc}
    2d9a:	bf00      	nop
    2d9c:	40002800 	.word	0x40002800
    2da0:	000028c5 	.word	0x000028c5
    2da4:	000028dd 	.word	0x000028dd
    2da8:	20000aa0 	.word	0x20000aa0
    2dac:	00005cb8 	.word	0x00005cb8
    2db0:	00001849 	.word	0x00001849
    2db4:	00005955 	.word	0x00005955
    2db8:	00005ca8 	.word	0x00005ca8

00002dbc <EIC_12_Handler>:

/**
 * \brief EIC interrupt handler
 */
void EIC_12_Handler(void)
{
    2dbc:	b580      	push	{r7, lr}
    2dbe:	af00      	add	r7, sp, #0
	_ext_irq_handler();
    2dc0:	4b01      	ldr	r3, [pc, #4]	; (2dc8 <EIC_12_Handler+0xc>)
    2dc2:	4798      	blx	r3
} /**
    2dc4:	bf00      	nop
    2dc6:	bd80      	pop	{r7, pc}
    2dc8:	00002c91 	.word	0x00002c91

00002dcc <EIC_13_Handler>:
   * \brief EIC interrupt handler
   */
void EIC_13_Handler(void)
{
    2dcc:	b580      	push	{r7, lr}
    2dce:	af00      	add	r7, sp, #0
	_ext_irq_handler();
    2dd0:	4b01      	ldr	r3, [pc, #4]	; (2dd8 <EIC_13_Handler+0xc>)
    2dd2:	4798      	blx	r3
}
    2dd4:	bf00      	nop
    2dd6:	bd80      	pop	{r7, pc}
    2dd8:	00002c91 	.word	0x00002c91

00002ddc <hri_evsys_write_USER_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_evsys_write_USER_reg(const void *const hw, uint8_t index, hri_evsys_user_reg_t data)
{
    2ddc:	b480      	push	{r7}
    2dde:	b085      	sub	sp, #20
    2de0:	af00      	add	r7, sp, #0
    2de2:	60f8      	str	r0, [r7, #12]
    2de4:	460b      	mov	r3, r1
    2de6:	607a      	str	r2, [r7, #4]
    2de8:	72fb      	strb	r3, [r7, #11]
	EVSYS_CRITICAL_SECTION_ENTER();
	((Evsys *)hw)->USER[index].reg = data;
    2dea:	7afa      	ldrb	r2, [r7, #11]
    2dec:	68fb      	ldr	r3, [r7, #12]
    2dee:	3248      	adds	r2, #72	; 0x48
    2df0:	6879      	ldr	r1, [r7, #4]
    2df2:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
	EVSYS_CRITICAL_SECTION_LEAVE();
}
    2df6:	bf00      	nop
    2df8:	3714      	adds	r7, #20
    2dfa:	46bd      	mov	sp, r7
    2dfc:	f85d 7b04 	ldr.w	r7, [sp], #4
    2e00:	4770      	bx	lr

00002e02 <hri_evsys_write_CHINTEN_reg>:
	return ((Evsys *)hw)->Channel[submodule_index].CHINTENSET.reg;
}

static inline void hri_evsys_write_CHINTEN_reg(const void *const hw, uint8_t submodule_index,
                                               hri_evsys_chintenset_reg_t data)
{
    2e02:	b480      	push	{r7}
    2e04:	b083      	sub	sp, #12
    2e06:	af00      	add	r7, sp, #0
    2e08:	6078      	str	r0, [r7, #4]
    2e0a:	460b      	mov	r3, r1
    2e0c:	70fb      	strb	r3, [r7, #3]
    2e0e:	4613      	mov	r3, r2
    2e10:	70bb      	strb	r3, [r7, #2]
	((Evsys *)hw)->Channel[submodule_index].CHINTENSET.reg = data;
    2e12:	78fb      	ldrb	r3, [r7, #3]
    2e14:	687a      	ldr	r2, [r7, #4]
    2e16:	3304      	adds	r3, #4
    2e18:	00db      	lsls	r3, r3, #3
    2e1a:	4413      	add	r3, r2
    2e1c:	78ba      	ldrb	r2, [r7, #2]
    2e1e:	715a      	strb	r2, [r3, #5]
	((Evsys *)hw)->Channel[submodule_index].CHINTENCLR.reg = ~data;
    2e20:	78fb      	ldrb	r3, [r7, #3]
    2e22:	78ba      	ldrb	r2, [r7, #2]
    2e24:	43d2      	mvns	r2, r2
    2e26:	b2d1      	uxtb	r1, r2
    2e28:	687a      	ldr	r2, [r7, #4]
    2e2a:	3304      	adds	r3, #4
    2e2c:	00db      	lsls	r3, r3, #3
    2e2e:	4413      	add	r3, r2
    2e30:	460a      	mov	r2, r1
    2e32:	711a      	strb	r2, [r3, #4]
}
    2e34:	bf00      	nop
    2e36:	370c      	adds	r7, #12
    2e38:	46bd      	mov	sp, r7
    2e3a:	f85d 7b04 	ldr.w	r7, [sp], #4
    2e3e:	4770      	bx	lr

00002e40 <hri_evsys_write_CHANNEL_reg>:
	return tmp;
}

static inline void hri_evsys_write_CHANNEL_reg(const void *const hw, uint8_t submodule_index,
                                               hri_evsys_channel_reg_t data)
{
    2e40:	b480      	push	{r7}
    2e42:	b085      	sub	sp, #20
    2e44:	af00      	add	r7, sp, #0
    2e46:	60f8      	str	r0, [r7, #12]
    2e48:	460b      	mov	r3, r1
    2e4a:	607a      	str	r2, [r7, #4]
    2e4c:	72fb      	strb	r3, [r7, #11]
	EVSYS_CRITICAL_SECTION_ENTER();
	((Evsys *)hw)->Channel[submodule_index].CHANNEL.reg = data;
    2e4e:	7afa      	ldrb	r2, [r7, #11]
    2e50:	68fb      	ldr	r3, [r7, #12]
    2e52:	3204      	adds	r2, #4
    2e54:	6879      	ldr	r1, [r7, #4]
    2e56:	f843 1032 	str.w	r1, [r3, r2, lsl #3]
	EVSYS_CRITICAL_SECTION_LEAVE();
}
    2e5a:	bf00      	nop
    2e5c:	3714      	adds	r7, #20
    2e5e:	46bd      	mov	sp, r7
    2e60:	f85d 7b04 	ldr.w	r7, [sp], #4
    2e64:	4770      	bx	lr
	...

00002e68 <_event_system_init>:

/**
 * \brief Initialize event system
 */
int32_t _event_system_init(void)
{
    2e68:	b580      	push	{r7, lr}
    2e6a:	b082      	sub	sp, #8
    2e6c:	af00      	add	r7, sp, #0
	uint8_t i;
	/* configure user multiplexers */
	for (i = 0; i < EVSYS_USERS; i++) {
    2e6e:	2300      	movs	r3, #0
    2e70:	71fb      	strb	r3, [r7, #7]
    2e72:	e00b      	b.n	2e8c <_event_system_init+0x24>
		hri_evsys_write_USER_reg(EVSYS, i, user_mux_confs[i]);
    2e74:	79fb      	ldrb	r3, [r7, #7]
    2e76:	4a18      	ldr	r2, [pc, #96]	; (2ed8 <_event_system_init+0x70>)
    2e78:	5cd3      	ldrb	r3, [r2, r3]
    2e7a:	461a      	mov	r2, r3
    2e7c:	79fb      	ldrb	r3, [r7, #7]
    2e7e:	4619      	mov	r1, r3
    2e80:	4816      	ldr	r0, [pc, #88]	; (2edc <_event_system_init+0x74>)
    2e82:	4b17      	ldr	r3, [pc, #92]	; (2ee0 <_event_system_init+0x78>)
    2e84:	4798      	blx	r3
	for (i = 0; i < EVSYS_USERS; i++) {
    2e86:	79fb      	ldrb	r3, [r7, #7]
    2e88:	3301      	adds	r3, #1
    2e8a:	71fb      	strb	r3, [r7, #7]
    2e8c:	79fb      	ldrb	r3, [r7, #7]
    2e8e:	2b42      	cmp	r3, #66	; 0x42
    2e90:	d9f0      	bls.n	2e74 <_event_system_init+0xc>
	}

	/* configure channels */
	for (i = 0; i < EVSYS_CHANNELS; i++) {
    2e92:	2300      	movs	r3, #0
    2e94:	71fb      	strb	r3, [r7, #7]
    2e96:	e016      	b.n	2ec6 <_event_system_init+0x5e>
		hri_evsys_write_CHANNEL_reg(EVSYS, i, channel_confs[i]);
    2e98:	79fb      	ldrb	r3, [r7, #7]
    2e9a:	4a12      	ldr	r2, [pc, #72]	; (2ee4 <_event_system_init+0x7c>)
    2e9c:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
    2ea0:	461a      	mov	r2, r3
    2ea2:	79fb      	ldrb	r3, [r7, #7]
    2ea4:	4619      	mov	r1, r3
    2ea6:	480d      	ldr	r0, [pc, #52]	; (2edc <_event_system_init+0x74>)
    2ea8:	4b0f      	ldr	r3, [pc, #60]	; (2ee8 <_event_system_init+0x80>)
    2eaa:	4798      	blx	r3
		hri_evsys_write_CHINTEN_reg(EVSYS, i, interrupt_cfg[i]);
    2eac:	79fb      	ldrb	r3, [r7, #7]
    2eae:	4a0f      	ldr	r2, [pc, #60]	; (2eec <_event_system_init+0x84>)
    2eb0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    2eb4:	b2da      	uxtb	r2, r3
    2eb6:	79fb      	ldrb	r3, [r7, #7]
    2eb8:	4619      	mov	r1, r3
    2eba:	4808      	ldr	r0, [pc, #32]	; (2edc <_event_system_init+0x74>)
    2ebc:	4b0c      	ldr	r3, [pc, #48]	; (2ef0 <_event_system_init+0x88>)
    2ebe:	4798      	blx	r3
	for (i = 0; i < EVSYS_CHANNELS; i++) {
    2ec0:	79fb      	ldrb	r3, [r7, #7]
    2ec2:	3301      	adds	r3, #1
    2ec4:	71fb      	strb	r3, [r7, #7]
    2ec6:	79fb      	ldrb	r3, [r7, #7]
    2ec8:	2b1f      	cmp	r3, #31
    2eca:	d9e5      	bls.n	2e98 <_event_system_init+0x30>
	}

	return ERR_NONE;
    2ecc:	2300      	movs	r3, #0
}
    2ece:	4618      	mov	r0, r3
    2ed0:	3708      	adds	r7, #8
    2ed2:	46bd      	mov	sp, r7
    2ed4:	bd80      	pop	{r7, pc}
    2ed6:	bf00      	nop
    2ed8:	00005cd0 	.word	0x00005cd0
    2edc:	4100e000 	.word	0x4100e000
    2ee0:	00002ddd 	.word	0x00002ddd
    2ee4:	00005d14 	.word	0x00005d14
    2ee8:	00002e41 	.word	0x00002e41
    2eec:	00005d54 	.word	0x00005d54
    2ef0:	00002e03 	.word	0x00002e03

00002ef4 <hri_gclk_wait_for_sync>:
{
    2ef4:	b480      	push	{r7}
    2ef6:	b083      	sub	sp, #12
    2ef8:	af00      	add	r7, sp, #0
    2efa:	6078      	str	r0, [r7, #4]
    2efc:	6039      	str	r1, [r7, #0]
	while (((Gclk *)hw)->SYNCBUSY.reg & reg) {
    2efe:	bf00      	nop
    2f00:	687b      	ldr	r3, [r7, #4]
    2f02:	685a      	ldr	r2, [r3, #4]
    2f04:	683b      	ldr	r3, [r7, #0]
    2f06:	4013      	ands	r3, r2
    2f08:	2b00      	cmp	r3, #0
    2f0a:	d1f9      	bne.n	2f00 <hri_gclk_wait_for_sync+0xc>
}
    2f0c:	bf00      	nop
    2f0e:	370c      	adds	r7, #12
    2f10:	46bd      	mov	sp, r7
    2f12:	f85d 7b04 	ldr.w	r7, [sp], #4
    2f16:	4770      	bx	lr

00002f18 <hri_gclk_write_GENCTRL_reg>:
{
    2f18:	b580      	push	{r7, lr}
    2f1a:	b084      	sub	sp, #16
    2f1c:	af00      	add	r7, sp, #0
    2f1e:	60f8      	str	r0, [r7, #12]
    2f20:	460b      	mov	r3, r1
    2f22:	607a      	str	r2, [r7, #4]
    2f24:	72fb      	strb	r3, [r7, #11]
	((Gclk *)hw)->GENCTRL[index].reg = data;
    2f26:	7afa      	ldrb	r2, [r7, #11]
    2f28:	68fb      	ldr	r3, [r7, #12]
    2f2a:	3208      	adds	r2, #8
    2f2c:	6879      	ldr	r1, [r7, #4]
    2f2e:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
	hri_gclk_wait_for_sync(hw, GCLK_SYNCBUSY_MASK);
    2f32:	f643 71fd 	movw	r1, #16381	; 0x3ffd
    2f36:	68f8      	ldr	r0, [r7, #12]
    2f38:	4b02      	ldr	r3, [pc, #8]	; (2f44 <hri_gclk_write_GENCTRL_reg+0x2c>)
    2f3a:	4798      	blx	r3
}
    2f3c:	bf00      	nop
    2f3e:	3710      	adds	r7, #16
    2f40:	46bd      	mov	sp, r7
    2f42:	bd80      	pop	{r7, pc}
    2f44:	00002ef5 	.word	0x00002ef5

00002f48 <_gclk_init_generators_by_fref>:
	        | (CONF_GCLK_GENERATOR_11_CONFIG << GCLK_GENCTRL_GENEN_Pos) | CONF_GCLK_GEN_11_SOURCE);
#endif
}

void _gclk_init_generators_by_fref(uint32_t bm)
{
    2f48:	b580      	push	{r7, lr}
    2f4a:	b082      	sub	sp, #8
    2f4c:	af00      	add	r7, sp, #0
    2f4e:	6078      	str	r0, [r7, #4]

#if CONF_GCLK_GENERATOR_0_CONFIG == 1
	if (bm & (1ul << 0)) {
    2f50:	687b      	ldr	r3, [r7, #4]
    2f52:	f003 0301 	and.w	r3, r3, #1
    2f56:	2b00      	cmp	r3, #0
    2f58:	d004      	beq.n	2f64 <_gclk_init_generators_by_fref+0x1c>
		hri_gclk_write_GENCTRL_reg(
    2f5a:	4a13      	ldr	r2, [pc, #76]	; (2fa8 <_gclk_init_generators_by_fref+0x60>)
    2f5c:	2100      	movs	r1, #0
    2f5e:	4813      	ldr	r0, [pc, #76]	; (2fac <_gclk_init_generators_by_fref+0x64>)
    2f60:	4b13      	ldr	r3, [pc, #76]	; (2fb0 <_gclk_init_generators_by_fref+0x68>)
    2f62:	4798      	blx	r3
		        | (CONF_GCLK_GENERATOR_0_CONFIG << GCLK_GENCTRL_GENEN_Pos) | CONF_GCLK_GEN_0_SOURCE);
	}
#endif

#if CONF_GCLK_GENERATOR_1_CONFIG == 1
	if (bm & (1ul << 1)) {
    2f64:	687b      	ldr	r3, [r7, #4]
    2f66:	f003 0302 	and.w	r3, r3, #2
    2f6a:	2b00      	cmp	r3, #0
    2f6c:	d004      	beq.n	2f78 <_gclk_init_generators_by_fref+0x30>
		hri_gclk_write_GENCTRL_reg(
    2f6e:	4a11      	ldr	r2, [pc, #68]	; (2fb4 <_gclk_init_generators_by_fref+0x6c>)
    2f70:	2101      	movs	r1, #1
    2f72:	480e      	ldr	r0, [pc, #56]	; (2fac <_gclk_init_generators_by_fref+0x64>)
    2f74:	4b0e      	ldr	r3, [pc, #56]	; (2fb0 <_gclk_init_generators_by_fref+0x68>)
    2f76:	4798      	blx	r3
		        | (CONF_GCLK_GENERATOR_1_CONFIG << GCLK_GENCTRL_GENEN_Pos) | CONF_GCLK_GEN_1_SOURCE);
	}
#endif

#if CONF_GCLK_GENERATOR_2_CONFIG == 1
	if (bm & (1ul << 2)) {
    2f78:	687b      	ldr	r3, [r7, #4]
    2f7a:	f003 0304 	and.w	r3, r3, #4
    2f7e:	2b00      	cmp	r3, #0
    2f80:	d004      	beq.n	2f8c <_gclk_init_generators_by_fref+0x44>
		hri_gclk_write_GENCTRL_reg(
    2f82:	4a0d      	ldr	r2, [pc, #52]	; (2fb8 <_gclk_init_generators_by_fref+0x70>)
    2f84:	2102      	movs	r1, #2
    2f86:	4809      	ldr	r0, [pc, #36]	; (2fac <_gclk_init_generators_by_fref+0x64>)
    2f88:	4b09      	ldr	r3, [pc, #36]	; (2fb0 <_gclk_init_generators_by_fref+0x68>)
    2f8a:	4798      	blx	r3
		        | (CONF_GCLK_GENERATOR_2_CONFIG << GCLK_GENCTRL_GENEN_Pos) | CONF_GCLK_GEN_2_SOURCE);
	}
#endif

#if CONF_GCLK_GENERATOR_3_CONFIG == 1
	if (bm & (1ul << 3)) {
    2f8c:	687b      	ldr	r3, [r7, #4]
    2f8e:	f003 0308 	and.w	r3, r3, #8
    2f92:	2b00      	cmp	r3, #0
    2f94:	d004      	beq.n	2fa0 <_gclk_init_generators_by_fref+0x58>
		hri_gclk_write_GENCTRL_reg(
    2f96:	4a09      	ldr	r2, [pc, #36]	; (2fbc <_gclk_init_generators_by_fref+0x74>)
    2f98:	2103      	movs	r1, #3
    2f9a:	4804      	ldr	r0, [pc, #16]	; (2fac <_gclk_init_generators_by_fref+0x64>)
    2f9c:	4b04      	ldr	r3, [pc, #16]	; (2fb0 <_gclk_init_generators_by_fref+0x68>)
    2f9e:	4798      	blx	r3
		        | (CONF_GCLK_GEN_11_DIVSEL << GCLK_GENCTRL_DIVSEL_Pos) | (CONF_GCLK_GEN_11_OE << GCLK_GENCTRL_OE_Pos)
		        | (CONF_GCLK_GEN_11_OOV << GCLK_GENCTRL_OOV_Pos) | (CONF_GCLK_GEN_11_IDC << GCLK_GENCTRL_IDC_Pos)
		        | (CONF_GCLK_GENERATOR_11_CONFIG << GCLK_GENCTRL_GENEN_Pos) | CONF_GCLK_GEN_11_SOURCE);
	}
#endif
}
    2fa0:	bf00      	nop
    2fa2:	3708      	adds	r7, #8
    2fa4:	46bd      	mov	sp, r7
    2fa6:	bd80      	pop	{r7, pc}
    2fa8:	00012107 	.word	0x00012107
    2fac:	40001c00 	.word	0x40001c00
    2fb0:	00002f19 	.word	0x00002f19
    2fb4:	00022108 	.word	0x00022108
    2fb8:	000c2101 	.word	0x000c2101
    2fbc:	00012108 	.word	0x00012108

00002fc0 <hri_mclk_write_CPUDIV_reg>:
{
    2fc0:	b480      	push	{r7}
    2fc2:	b083      	sub	sp, #12
    2fc4:	af00      	add	r7, sp, #0
    2fc6:	6078      	str	r0, [r7, #4]
    2fc8:	460b      	mov	r3, r1
    2fca:	70fb      	strb	r3, [r7, #3]
	((Mclk *)hw)->CPUDIV.reg = data;
    2fcc:	687b      	ldr	r3, [r7, #4]
    2fce:	78fa      	ldrb	r2, [r7, #3]
    2fd0:	715a      	strb	r2, [r3, #5]
}
    2fd2:	bf00      	nop
    2fd4:	370c      	adds	r7, #12
    2fd6:	46bd      	mov	sp, r7
    2fd8:	f85d 7b04 	ldr.w	r7, [sp], #4
    2fdc:	4770      	bx	lr
	...

00002fe0 <_mclk_init>:

/**
 * \brief Initialize master clock generator
 */
void _mclk_init(void)
{
    2fe0:	b580      	push	{r7, lr}
    2fe2:	b082      	sub	sp, #8
    2fe4:	af00      	add	r7, sp, #0
	void *hw = (void *)MCLK;
    2fe6:	4b05      	ldr	r3, [pc, #20]	; (2ffc <_mclk_init+0x1c>)
    2fe8:	607b      	str	r3, [r7, #4]
	hri_mclk_write_CPUDIV_reg(hw, MCLK_CPUDIV_DIV(CONF_MCLK_CPUDIV));
    2fea:	2101      	movs	r1, #1
    2fec:	6878      	ldr	r0, [r7, #4]
    2fee:	4b04      	ldr	r3, [pc, #16]	; (3000 <_mclk_init+0x20>)
    2ff0:	4798      	blx	r3
}
    2ff2:	bf00      	nop
    2ff4:	3708      	adds	r7, #8
    2ff6:	46bd      	mov	sp, r7
    2ff8:	bd80      	pop	{r7, pc}
    2ffa:	bf00      	nop
    2ffc:	40000800 	.word	0x40000800
    3000:	00002fc1 	.word	0x00002fc1

00003004 <hri_osc32kctrl_write_RTCCTRL_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_osc32kctrl_write_RTCCTRL_reg(const void *const hw, hri_osc32kctrl_rtcctrl_reg_t data)
{
    3004:	b480      	push	{r7}
    3006:	b083      	sub	sp, #12
    3008:	af00      	add	r7, sp, #0
    300a:	6078      	str	r0, [r7, #4]
    300c:	460b      	mov	r3, r1
    300e:	70fb      	strb	r3, [r7, #3]
	OSC32KCTRL_CRITICAL_SECTION_ENTER();
	((Osc32kctrl *)hw)->RTCCTRL.reg = data;
    3010:	687b      	ldr	r3, [r7, #4]
    3012:	78fa      	ldrb	r2, [r7, #3]
    3014:	741a      	strb	r2, [r3, #16]
	OSC32KCTRL_CRITICAL_SECTION_LEAVE();
}
    3016:	bf00      	nop
    3018:	370c      	adds	r7, #12
    301a:	46bd      	mov	sp, r7
    301c:	f85d 7b04 	ldr.w	r7, [sp], #4
    3020:	4770      	bx	lr

00003022 <hri_osc32kctrl_read_OSCULP32K_CALIB_bf>:
	((Osc32kctrl *)hw)->OSCULP32K.reg ^= OSC32KCTRL_OSCULP32K_CALIB(mask);
	OSC32KCTRL_CRITICAL_SECTION_LEAVE();
}

static inline hri_osc32kctrl_osculp32k_reg_t hri_osc32kctrl_read_OSCULP32K_CALIB_bf(const void *const hw)
{
    3022:	b480      	push	{r7}
    3024:	b085      	sub	sp, #20
    3026:	af00      	add	r7, sp, #0
    3028:	6078      	str	r0, [r7, #4]
	uint32_t tmp;
	tmp = ((Osc32kctrl *)hw)->OSCULP32K.reg;
    302a:	687b      	ldr	r3, [r7, #4]
    302c:	69db      	ldr	r3, [r3, #28]
    302e:	60fb      	str	r3, [r7, #12]
	tmp = (tmp & OSC32KCTRL_OSCULP32K_CALIB_Msk) >> OSC32KCTRL_OSCULP32K_CALIB_Pos;
    3030:	68fb      	ldr	r3, [r7, #12]
    3032:	0a1b      	lsrs	r3, r3, #8
    3034:	f003 033f 	and.w	r3, r3, #63	; 0x3f
    3038:	60fb      	str	r3, [r7, #12]
	return tmp;
    303a:	68fb      	ldr	r3, [r7, #12]
}
    303c:	4618      	mov	r0, r3
    303e:	3714      	adds	r7, #20
    3040:	46bd      	mov	sp, r7
    3042:	f85d 7b04 	ldr.w	r7, [sp], #4
    3046:	4770      	bx	lr

00003048 <hri_osc32kctrl_write_OSCULP32K_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_osc32kctrl_write_OSCULP32K_reg(const void *const hw, hri_osc32kctrl_osculp32k_reg_t data)
{
    3048:	b480      	push	{r7}
    304a:	b083      	sub	sp, #12
    304c:	af00      	add	r7, sp, #0
    304e:	6078      	str	r0, [r7, #4]
    3050:	6039      	str	r1, [r7, #0]
	OSC32KCTRL_CRITICAL_SECTION_ENTER();
	((Osc32kctrl *)hw)->OSCULP32K.reg = data;
    3052:	687b      	ldr	r3, [r7, #4]
    3054:	683a      	ldr	r2, [r7, #0]
    3056:	61da      	str	r2, [r3, #28]
	OSC32KCTRL_CRITICAL_SECTION_LEAVE();
}
    3058:	bf00      	nop
    305a:	370c      	adds	r7, #12
    305c:	46bd      	mov	sp, r7
    305e:	f85d 7b04 	ldr.w	r7, [sp], #4
    3062:	4770      	bx	lr

00003064 <_osc32kctrl_init_sources>:

/**
 * \brief Initialize 32 kHz clock sources
 */
void _osc32kctrl_init_sources(void)
{
    3064:	b580      	push	{r7, lr}
    3066:	b082      	sub	sp, #8
    3068:	af00      	add	r7, sp, #0
	void *   hw    = (void *)OSC32KCTRL;
    306a:	4b0c      	ldr	r3, [pc, #48]	; (309c <_osc32kctrl_init_sources+0x38>)
    306c:	607b      	str	r3, [r7, #4]
	uint16_t calib = 0;
    306e:	2300      	movs	r3, #0
    3070:	807b      	strh	r3, [r7, #2]

	hri_osc32kctrl_write_EVCTRL_reg(hw, (CONF_XOSC32K_CFDEO << OSC32KCTRL_EVCTRL_CFDEO_Pos));
#endif

#if CONF_OSCULP32K_CONFIG == 1
	calib = hri_osc32kctrl_read_OSCULP32K_CALIB_bf(hw);
    3072:	6878      	ldr	r0, [r7, #4]
    3074:	4b0a      	ldr	r3, [pc, #40]	; (30a0 <_osc32kctrl_init_sources+0x3c>)
    3076:	4798      	blx	r3
    3078:	4603      	mov	r3, r0
    307a:	807b      	strh	r3, [r7, #2]
	hri_osc32kctrl_write_OSCULP32K_reg(hw,
#if CONF_OSCULP32K_CALIB_ENABLE == 1
	                                   OSC32KCTRL_OSCULP32K_CALIB(CONF_OSCULP32K_CALIB)
#else
	                                   OSC32KCTRL_OSCULP32K_CALIB(calib)
    307c:	887b      	ldrh	r3, [r7, #2]
    307e:	021b      	lsls	r3, r3, #8
	hri_osc32kctrl_write_OSCULP32K_reg(hw,
    3080:	f403 537c 	and.w	r3, r3, #16128	; 0x3f00
    3084:	4619      	mov	r1, r3
    3086:	6878      	ldr	r0, [r7, #4]
    3088:	4b06      	ldr	r3, [pc, #24]	; (30a4 <_osc32kctrl_init_sources+0x40>)
    308a:	4798      	blx	r3
	while (!hri_osc32kctrl_get_STATUS_XOSC32KRDY_bit(hw))
		;
#endif
#endif

	hri_osc32kctrl_write_RTCCTRL_reg(hw, OSC32KCTRL_RTCCTRL_RTCSEL(CONF_RTCCTRL));
    308c:	2101      	movs	r1, #1
    308e:	6878      	ldr	r0, [r7, #4]
    3090:	4b05      	ldr	r3, [pc, #20]	; (30a8 <_osc32kctrl_init_sources+0x44>)
    3092:	4798      	blx	r3
	(void)calib;
}
    3094:	bf00      	nop
    3096:	3708      	adds	r7, #8
    3098:	46bd      	mov	sp, r7
    309a:	bd80      	pop	{r7, pc}
    309c:	40001400 	.word	0x40001400
    30a0:	00003023 	.word	0x00003023
    30a4:	00003049 	.word	0x00003049
    30a8:	00003005 	.word	0x00003005

000030ac <hri_gclk_write_PCHCTRL_reg>:
{
    30ac:	b480      	push	{r7}
    30ae:	b085      	sub	sp, #20
    30b0:	af00      	add	r7, sp, #0
    30b2:	60f8      	str	r0, [r7, #12]
    30b4:	460b      	mov	r3, r1
    30b6:	607a      	str	r2, [r7, #4]
    30b8:	72fb      	strb	r3, [r7, #11]
	((Gclk *)hw)->PCHCTRL[index].reg = data;
    30ba:	7afa      	ldrb	r2, [r7, #11]
    30bc:	68fb      	ldr	r3, [r7, #12]
    30be:	3220      	adds	r2, #32
    30c0:	6879      	ldr	r1, [r7, #4]
    30c2:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
    30c6:	bf00      	nop
    30c8:	3714      	adds	r7, #20
    30ca:	46bd      	mov	sp, r7
    30cc:	f85d 7b04 	ldr.w	r7, [sp], #4
    30d0:	4770      	bx	lr

000030d2 <hri_oscctrl_wait_for_sync>:
	return ((OscctrlDpll *)hw)->DPLLSYNCBUSY.reg & reg;
}

static inline void hri_oscctrl_wait_for_sync(const void *const hw, uint8_t submodule_index,
                                             hri_oscctrl_dpllsyncbusy_reg_t reg)
{
    30d2:	b480      	push	{r7}
    30d4:	b085      	sub	sp, #20
    30d6:	af00      	add	r7, sp, #0
    30d8:	60f8      	str	r0, [r7, #12]
    30da:	460b      	mov	r3, r1
    30dc:	607a      	str	r2, [r7, #4]
    30de:	72fb      	strb	r3, [r7, #11]
	while (((Oscctrl *)hw)->Dpll[submodule_index].DPLLSYNCBUSY.reg & reg) {
    30e0:	bf00      	nop
    30e2:	7afa      	ldrb	r2, [r7, #11]
    30e4:	68f9      	ldr	r1, [r7, #12]
    30e6:	4613      	mov	r3, r2
    30e8:	009b      	lsls	r3, r3, #2
    30ea:	4413      	add	r3, r2
    30ec:	009b      	lsls	r3, r3, #2
    30ee:	440b      	add	r3, r1
    30f0:	333c      	adds	r3, #60	; 0x3c
    30f2:	681a      	ldr	r2, [r3, #0]
    30f4:	687b      	ldr	r3, [r7, #4]
    30f6:	4013      	ands	r3, r2
    30f8:	2b00      	cmp	r3, #0
    30fa:	d1f2      	bne.n	30e2 <hri_oscctrl_wait_for_sync+0x10>
	};
}
    30fc:	bf00      	nop
    30fe:	3714      	adds	r7, #20
    3100:	46bd      	mov	sp, r7
    3102:	f85d 7b04 	ldr.w	r7, [sp], #4
    3106:	4770      	bx	lr

00003108 <hri_oscctrl_get_DPLLSTATUS_LOCK_bit>:
{
	return ((Oscctrl *)hw)->Dpll[submodule_index].DPLLSYNCBUSY.reg;
}

static inline bool hri_oscctrl_get_DPLLSTATUS_LOCK_bit(const void *const hw, uint8_t submodule_index)
{
    3108:	b480      	push	{r7}
    310a:	b083      	sub	sp, #12
    310c:	af00      	add	r7, sp, #0
    310e:	6078      	str	r0, [r7, #4]
    3110:	460b      	mov	r3, r1
    3112:	70fb      	strb	r3, [r7, #3]
	return (((Oscctrl *)hw)->Dpll[submodule_index].DPLLSTATUS.reg & OSCCTRL_DPLLSTATUS_LOCK)
    3114:	78fa      	ldrb	r2, [r7, #3]
    3116:	6879      	ldr	r1, [r7, #4]
    3118:	4613      	mov	r3, r2
    311a:	009b      	lsls	r3, r3, #2
    311c:	4413      	add	r3, r2
    311e:	009b      	lsls	r3, r3, #2
    3120:	440b      	add	r3, r1
    3122:	3340      	adds	r3, #64	; 0x40
    3124:	681b      	ldr	r3, [r3, #0]
	       >> OSCCTRL_DPLLSTATUS_LOCK_Pos;
    3126:	f003 0301 	and.w	r3, r3, #1
    312a:	2b00      	cmp	r3, #0
    312c:	bf14      	ite	ne
    312e:	2301      	movne	r3, #1
    3130:	2300      	moveq	r3, #0
    3132:	b2db      	uxtb	r3, r3
}
    3134:	4618      	mov	r0, r3
    3136:	370c      	adds	r7, #12
    3138:	46bd      	mov	sp, r7
    313a:	f85d 7b04 	ldr.w	r7, [sp], #4
    313e:	4770      	bx	lr

00003140 <hri_oscctrl_get_DPLLSTATUS_CLKRDY_bit>:

static inline bool hri_oscctrl_get_DPLLSTATUS_CLKRDY_bit(const void *const hw, uint8_t submodule_index)
{
    3140:	b480      	push	{r7}
    3142:	b083      	sub	sp, #12
    3144:	af00      	add	r7, sp, #0
    3146:	6078      	str	r0, [r7, #4]
    3148:	460b      	mov	r3, r1
    314a:	70fb      	strb	r3, [r7, #3]
	return (((Oscctrl *)hw)->Dpll[submodule_index].DPLLSTATUS.reg & OSCCTRL_DPLLSTATUS_CLKRDY)
    314c:	78fa      	ldrb	r2, [r7, #3]
    314e:	6879      	ldr	r1, [r7, #4]
    3150:	4613      	mov	r3, r2
    3152:	009b      	lsls	r3, r3, #2
    3154:	4413      	add	r3, r2
    3156:	009b      	lsls	r3, r3, #2
    3158:	440b      	add	r3, r1
    315a:	3340      	adds	r3, #64	; 0x40
    315c:	681b      	ldr	r3, [r3, #0]
	       >> OSCCTRL_DPLLSTATUS_CLKRDY_Pos;
    315e:	085b      	lsrs	r3, r3, #1
    3160:	f003 0301 	and.w	r3, r3, #1
    3164:	2b00      	cmp	r3, #0
    3166:	bf14      	ite	ne
    3168:	2301      	movne	r3, #1
    316a:	2300      	moveq	r3, #0
    316c:	b2db      	uxtb	r3, r3
}
    316e:	4618      	mov	r0, r3
    3170:	370c      	adds	r7, #12
    3172:	46bd      	mov	sp, r7
    3174:	f85d 7b04 	ldr.w	r7, [sp], #4
    3178:	4770      	bx	lr
	...

0000317c <hri_oscctrl_write_DPLLCTRLA_reg>:
	return tmp;
}

static inline void hri_oscctrl_write_DPLLCTRLA_reg(const void *const hw, uint8_t submodule_index,
                                                   hri_oscctrl_dpllctrla_reg_t data)
{
    317c:	b580      	push	{r7, lr}
    317e:	b082      	sub	sp, #8
    3180:	af00      	add	r7, sp, #0
    3182:	6078      	str	r0, [r7, #4]
    3184:	460b      	mov	r3, r1
    3186:	70fb      	strb	r3, [r7, #3]
    3188:	4613      	mov	r3, r2
    318a:	70bb      	strb	r3, [r7, #2]
	OSCCTRL_CRITICAL_SECTION_ENTER();
	((Oscctrl *)hw)->Dpll[submodule_index].DPLLCTRLA.reg = data;
    318c:	78fa      	ldrb	r2, [r7, #3]
    318e:	6879      	ldr	r1, [r7, #4]
    3190:	4613      	mov	r3, r2
    3192:	009b      	lsls	r3, r3, #2
    3194:	4413      	add	r3, r2
    3196:	009b      	lsls	r3, r3, #2
    3198:	440b      	add	r3, r1
    319a:	3330      	adds	r3, #48	; 0x30
    319c:	78ba      	ldrb	r2, [r7, #2]
    319e:	701a      	strb	r2, [r3, #0]
	hri_oscctrl_wait_for_sync(hw, submodule_index, OSCCTRL_DPLLSYNCBUSY_ENABLE);
    31a0:	78fb      	ldrb	r3, [r7, #3]
    31a2:	2202      	movs	r2, #2
    31a4:	4619      	mov	r1, r3
    31a6:	6878      	ldr	r0, [r7, #4]
    31a8:	4b02      	ldr	r3, [pc, #8]	; (31b4 <hri_oscctrl_write_DPLLCTRLA_reg+0x38>)
    31aa:	4798      	blx	r3
	OSCCTRL_CRITICAL_SECTION_LEAVE();
}
    31ac:	bf00      	nop
    31ae:	3708      	adds	r7, #8
    31b0:	46bd      	mov	sp, r7
    31b2:	bd80      	pop	{r7, pc}
    31b4:	000030d3 	.word	0x000030d3

000031b8 <hri_oscctrl_write_DPLLRATIO_reg>:
	return tmp;
}

static inline void hri_oscctrl_write_DPLLRATIO_reg(const void *const hw, uint8_t submodule_index,
                                                   hri_oscctrl_dpllratio_reg_t data)
{
    31b8:	b580      	push	{r7, lr}
    31ba:	b084      	sub	sp, #16
    31bc:	af00      	add	r7, sp, #0
    31be:	60f8      	str	r0, [r7, #12]
    31c0:	460b      	mov	r3, r1
    31c2:	607a      	str	r2, [r7, #4]
    31c4:	72fb      	strb	r3, [r7, #11]
	OSCCTRL_CRITICAL_SECTION_ENTER();
	((Oscctrl *)hw)->Dpll[submodule_index].DPLLRATIO.reg = data;
    31c6:	7afa      	ldrb	r2, [r7, #11]
    31c8:	68f9      	ldr	r1, [r7, #12]
    31ca:	4613      	mov	r3, r2
    31cc:	009b      	lsls	r3, r3, #2
    31ce:	4413      	add	r3, r2
    31d0:	009b      	lsls	r3, r3, #2
    31d2:	440b      	add	r3, r1
    31d4:	3334      	adds	r3, #52	; 0x34
    31d6:	687a      	ldr	r2, [r7, #4]
    31d8:	601a      	str	r2, [r3, #0]
	hri_oscctrl_wait_for_sync(hw, submodule_index, OSCCTRL_DPLLSYNCBUSY_MASK);
    31da:	7afb      	ldrb	r3, [r7, #11]
    31dc:	2206      	movs	r2, #6
    31de:	4619      	mov	r1, r3
    31e0:	68f8      	ldr	r0, [r7, #12]
    31e2:	4b03      	ldr	r3, [pc, #12]	; (31f0 <hri_oscctrl_write_DPLLRATIO_reg+0x38>)
    31e4:	4798      	blx	r3
	OSCCTRL_CRITICAL_SECTION_LEAVE();
}
    31e6:	bf00      	nop
    31e8:	3710      	adds	r7, #16
    31ea:	46bd      	mov	sp, r7
    31ec:	bd80      	pop	{r7, pc}
    31ee:	bf00      	nop
    31f0:	000030d3 	.word	0x000030d3

000031f4 <hri_oscctrl_write_DPLLCTRLB_reg>:
	return tmp;
}

static inline void hri_oscctrl_write_DPLLCTRLB_reg(const void *const hw, uint8_t submodule_index,
                                                   hri_oscctrl_dpllctrlb_reg_t data)
{
    31f4:	b480      	push	{r7}
    31f6:	b085      	sub	sp, #20
    31f8:	af00      	add	r7, sp, #0
    31fa:	60f8      	str	r0, [r7, #12]
    31fc:	460b      	mov	r3, r1
    31fe:	607a      	str	r2, [r7, #4]
    3200:	72fb      	strb	r3, [r7, #11]
	OSCCTRL_CRITICAL_SECTION_ENTER();
	((Oscctrl *)hw)->Dpll[submodule_index].DPLLCTRLB.reg = data;
    3202:	7afa      	ldrb	r2, [r7, #11]
    3204:	68f9      	ldr	r1, [r7, #12]
    3206:	4613      	mov	r3, r2
    3208:	009b      	lsls	r3, r3, #2
    320a:	4413      	add	r3, r2
    320c:	009b      	lsls	r3, r3, #2
    320e:	440b      	add	r3, r1
    3210:	3338      	adds	r3, #56	; 0x38
    3212:	687a      	ldr	r2, [r7, #4]
    3214:	601a      	str	r2, [r3, #0]
	OSCCTRL_CRITICAL_SECTION_LEAVE();
}
    3216:	bf00      	nop
    3218:	3714      	adds	r7, #20
    321a:	46bd      	mov	sp, r7
    321c:	f85d 7b04 	ldr.w	r7, [sp], #4
    3220:	4770      	bx	lr

00003222 <hri_oscctrl_get_STATUS_XOSCRDY1_bit>:
{
	return (((Oscctrl *)hw)->STATUS.reg & OSCCTRL_STATUS_XOSCRDY0) >> OSCCTRL_STATUS_XOSCRDY0_Pos;
}

static inline bool hri_oscctrl_get_STATUS_XOSCRDY1_bit(const void *const hw)
{
    3222:	b480      	push	{r7}
    3224:	b083      	sub	sp, #12
    3226:	af00      	add	r7, sp, #0
    3228:	6078      	str	r0, [r7, #4]
	return (((Oscctrl *)hw)->STATUS.reg & OSCCTRL_STATUS_XOSCRDY1) >> OSCCTRL_STATUS_XOSCRDY1_Pos;
    322a:	687b      	ldr	r3, [r7, #4]
    322c:	691b      	ldr	r3, [r3, #16]
    322e:	085b      	lsrs	r3, r3, #1
    3230:	f003 0301 	and.w	r3, r3, #1
    3234:	2b00      	cmp	r3, #0
    3236:	bf14      	ite	ne
    3238:	2301      	movne	r3, #1
    323a:	2300      	moveq	r3, #0
    323c:	b2db      	uxtb	r3, r3
}
    323e:	4618      	mov	r0, r3
    3240:	370c      	adds	r7, #12
    3242:	46bd      	mov	sp, r7
    3244:	f85d 7b04 	ldr.w	r7, [sp], #4
    3248:	4770      	bx	lr

0000324a <hri_oscctrl_write_XOSCCTRL_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_oscctrl_write_XOSCCTRL_reg(const void *const hw, uint8_t index, hri_oscctrl_xoscctrl_reg_t data)
{
    324a:	b480      	push	{r7}
    324c:	b085      	sub	sp, #20
    324e:	af00      	add	r7, sp, #0
    3250:	60f8      	str	r0, [r7, #12]
    3252:	460b      	mov	r3, r1
    3254:	607a      	str	r2, [r7, #4]
    3256:	72fb      	strb	r3, [r7, #11]
	OSCCTRL_CRITICAL_SECTION_ENTER();
	((Oscctrl *)hw)->XOSCCTRL[index].reg = data;
    3258:	7afb      	ldrb	r3, [r7, #11]
    325a:	68fa      	ldr	r2, [r7, #12]
    325c:	3304      	adds	r3, #4
    325e:	009b      	lsls	r3, r3, #2
    3260:	4413      	add	r3, r2
    3262:	687a      	ldr	r2, [r7, #4]
    3264:	605a      	str	r2, [r3, #4]
	OSCCTRL_CRITICAL_SECTION_LEAVE();
}
    3266:	bf00      	nop
    3268:	3714      	adds	r7, #20
    326a:	46bd      	mov	sp, r7
    326c:	f85d 7b04 	ldr.w	r7, [sp], #4
    3270:	4770      	bx	lr
	...

00003274 <_oscctrl_init_sources>:

/**
 * \brief Initialize clock sources
 */
void _oscctrl_init_sources(void)
{
    3274:	b580      	push	{r7, lr}
    3276:	b082      	sub	sp, #8
    3278:	af00      	add	r7, sp, #0
	void *hw = (void *)OSCCTRL;
    327a:	4b0a      	ldr	r3, [pc, #40]	; (32a4 <_oscctrl_init_sources+0x30>)
    327c:	607b      	str	r3, [r7, #4]
	hri_oscctrl_set_XOSCCTRL_ONDEMAND_bit(hw, 0);
#endif
#endif

#if CONF_XOSC1_CONFIG == 1
	hri_oscctrl_write_XOSCCTRL_reg(
    327e:	4a0a      	ldr	r2, [pc, #40]	; (32a8 <_oscctrl_init_sources+0x34>)
    3280:	2101      	movs	r1, #1
    3282:	6878      	ldr	r0, [r7, #4]
    3284:	4b09      	ldr	r3, [pc, #36]	; (32ac <_oscctrl_init_sources+0x38>)
    3286:	4798      	blx	r3
	        | (CONF_XOSC1_XTALEN << OSCCTRL_XOSCCTRL_XTALEN_Pos) | (CONF_XOSC1_ENABLE << OSCCTRL_XOSCCTRL_ENABLE_Pos));
#endif

#if CONF_XOSC1_CONFIG == 1
#if CONF_XOSC1_ENABLE == 1
	while (!hri_oscctrl_get_STATUS_XOSCRDY1_bit(hw))
    3288:	bf00      	nop
    328a:	6878      	ldr	r0, [r7, #4]
    328c:	4b08      	ldr	r3, [pc, #32]	; (32b0 <_oscctrl_init_sources+0x3c>)
    328e:	4798      	blx	r3
    3290:	4603      	mov	r3, r0
    3292:	f083 0301 	eor.w	r3, r3, #1
    3296:	b2db      	uxtb	r3, r3
    3298:	2b00      	cmp	r3, #0
    329a:	d1f6      	bne.n	328a <_oscctrl_init_sources+0x16>
	hri_oscctrl_set_XOSCCTRL_ONDEMAND_bit(hw, 1);
#endif
#endif

	(void)hw;
}
    329c:	bf00      	nop
    329e:	3708      	adds	r7, #8
    32a0:	46bd      	mov	sp, r7
    32a2:	bd80      	pop	{r7, pc}
    32a4:	40001000 	.word	0x40001000
    32a8:	03002646 	.word	0x03002646
    32ac:	0000324b 	.word	0x0000324b
    32b0:	00003223 	.word	0x00003223

000032b4 <_oscctrl_init_referenced_generators>:

void _oscctrl_init_referenced_generators(void)
{
    32b4:	b580      	push	{r7, lr}
    32b6:	b082      	sub	sp, #8
    32b8:	af00      	add	r7, sp, #0
	void *hw = (void *)OSCCTRL;
    32ba:	4b2d      	ldr	r3, [pc, #180]	; (3370 <_oscctrl_init_referenced_generators+0xbc>)
    32bc:	607b      	str	r3, [r7, #4]
		;
#endif

#if CONF_FDPLL0_CONFIG == 1
#if CONF_FDPLL0_REFCLK == 0
	hri_gclk_write_PCHCTRL_reg(
    32be:	2242      	movs	r2, #66	; 0x42
    32c0:	2101      	movs	r1, #1
    32c2:	482c      	ldr	r0, [pc, #176]	; (3374 <_oscctrl_init_referenced_generators+0xc0>)
    32c4:	4b2c      	ldr	r3, [pc, #176]	; (3378 <_oscctrl_init_referenced_generators+0xc4>)
    32c6:	4798      	blx	r3
	    GCLK, OSCCTRL_GCLK_ID_FDPLL0, (1 << GCLK_PCHCTRL_CHEN_Pos) | GCLK_PCHCTRL_GEN(CONF_FDPLL0_GCLK));
#endif
	hri_oscctrl_write_DPLLRATIO_reg(
    32c8:	2277      	movs	r2, #119	; 0x77
    32ca:	2100      	movs	r1, #0
    32cc:	6878      	ldr	r0, [r7, #4]
    32ce:	4b2b      	ldr	r3, [pc, #172]	; (337c <_oscctrl_init_referenced_generators+0xc8>)
    32d0:	4798      	blx	r3
	    hw, 0, OSCCTRL_DPLLRATIO_LDRFRAC(CONF_FDPLL0_LDRFRAC) | OSCCTRL_DPLLRATIO_LDR(CONF_FDPLL0_LDR));
	hri_oscctrl_write_DPLLCTRLB_reg(
    32d2:	f44f 3284 	mov.w	r2, #67584	; 0x10800
    32d6:	2100      	movs	r1, #0
    32d8:	6878      	ldr	r0, [r7, #4]
    32da:	4b29      	ldr	r3, [pc, #164]	; (3380 <_oscctrl_init_referenced_generators+0xcc>)
    32dc:	4798      	blx	r3
	    OSCCTRL_DPLLCTRLB_DIV(CONF_FDPLL0_DIV) | (CONF_FDPLL0_DCOEN << OSCCTRL_DPLLCTRLB_DCOEN_Pos)
	        | OSCCTRL_DPLLCTRLB_DCOFILTER(CONF_FDPLL0_DCOFILTER)
	        | (CONF_FDPLL0_LBYPASS << OSCCTRL_DPLLCTRLB_LBYPASS_Pos) | OSCCTRL_DPLLCTRLB_LTIME(CONF_FDPLL0_LTIME)
	        | OSCCTRL_DPLLCTRLB_REFCLK(CONF_FDPLL0_REFCLK) | (CONF_FDPLL0_WUF << OSCCTRL_DPLLCTRLB_WUF_Pos)
	        | OSCCTRL_DPLLCTRLB_FILTER(CONF_FDPLL0_FILTER));
	hri_oscctrl_write_DPLLCTRLA_reg(hw,
    32de:	2202      	movs	r2, #2
    32e0:	2100      	movs	r1, #0
    32e2:	6878      	ldr	r0, [r7, #4]
    32e4:	4b27      	ldr	r3, [pc, #156]	; (3384 <_oscctrl_init_referenced_generators+0xd0>)
    32e6:	4798      	blx	r3
	                                    | (CONF_FDPLL0_ENABLE << OSCCTRL_DPLLCTRLA_ENABLE_Pos));
#endif

#if CONF_FDPLL1_CONFIG == 1
#if CONF_FDPLL1_REFCLK == 0
	hri_gclk_write_PCHCTRL_reg(
    32e8:	2242      	movs	r2, #66	; 0x42
    32ea:	2102      	movs	r1, #2
    32ec:	4821      	ldr	r0, [pc, #132]	; (3374 <_oscctrl_init_referenced_generators+0xc0>)
    32ee:	4b22      	ldr	r3, [pc, #136]	; (3378 <_oscctrl_init_referenced_generators+0xc4>)
    32f0:	4798      	blx	r3
	    GCLK, OSCCTRL_GCLK_ID_FDPLL1, (1 << GCLK_PCHCTRL_CHEN_Pos) | GCLK_PCHCTRL_GEN(CONF_FDPLL1_GCLK));
#endif
	hri_oscctrl_write_DPLLRATIO_reg(
    32f2:	222f      	movs	r2, #47	; 0x2f
    32f4:	2101      	movs	r1, #1
    32f6:	6878      	ldr	r0, [r7, #4]
    32f8:	4b20      	ldr	r3, [pc, #128]	; (337c <_oscctrl_init_referenced_generators+0xc8>)
    32fa:	4798      	blx	r3
	    hw, 1, OSCCTRL_DPLLRATIO_LDRFRAC(CONF_FDPLL1_LDRFRAC) | OSCCTRL_DPLLRATIO_LDR(CONF_FDPLL1_LDR));
	hri_oscctrl_write_DPLLCTRLB_reg(
    32fc:	f44f 6200 	mov.w	r2, #2048	; 0x800
    3300:	2101      	movs	r1, #1
    3302:	6878      	ldr	r0, [r7, #4]
    3304:	4b1e      	ldr	r3, [pc, #120]	; (3380 <_oscctrl_init_referenced_generators+0xcc>)
    3306:	4798      	blx	r3
	    OSCCTRL_DPLLCTRLB_DIV(CONF_FDPLL1_DIV) | (CONF_FDPLL1_DCOEN << OSCCTRL_DPLLCTRLB_DCOEN_Pos)
	        | OSCCTRL_DPLLCTRLB_DCOFILTER(CONF_FDPLL1_DCOFILTER)
	        | (CONF_FDPLL1_LBYPASS << OSCCTRL_DPLLCTRLB_LBYPASS_Pos) | OSCCTRL_DPLLCTRLB_LTIME(CONF_FDPLL1_LTIME)
	        | OSCCTRL_DPLLCTRLB_REFCLK(CONF_FDPLL1_REFCLK) | (CONF_FDPLL1_WUF << OSCCTRL_DPLLCTRLB_WUF_Pos)
	        | OSCCTRL_DPLLCTRLB_FILTER(CONF_FDPLL1_FILTER));
	hri_oscctrl_write_DPLLCTRLA_reg(hw,
    3308:	2202      	movs	r2, #2
    330a:	2101      	movs	r1, #1
    330c:	6878      	ldr	r0, [r7, #4]
    330e:	4b1d      	ldr	r3, [pc, #116]	; (3384 <_oscctrl_init_referenced_generators+0xd0>)
    3310:	4798      	blx	r3
#endif
#endif

#if CONF_FDPLL0_CONFIG == 1
#if CONF_FDPLL0_ENABLE == 1
	while (!(hri_oscctrl_get_DPLLSTATUS_LOCK_bit(hw, 0) || hri_oscctrl_get_DPLLSTATUS_CLKRDY_bit(hw, 0)))
    3312:	bf00      	nop
    3314:	2100      	movs	r1, #0
    3316:	6878      	ldr	r0, [r7, #4]
    3318:	4b1b      	ldr	r3, [pc, #108]	; (3388 <_oscctrl_init_referenced_generators+0xd4>)
    331a:	4798      	blx	r3
    331c:	4603      	mov	r3, r0
    331e:	f083 0301 	eor.w	r3, r3, #1
    3322:	b2db      	uxtb	r3, r3
    3324:	2b00      	cmp	r3, #0
    3326:	d009      	beq.n	333c <_oscctrl_init_referenced_generators+0x88>
    3328:	2100      	movs	r1, #0
    332a:	6878      	ldr	r0, [r7, #4]
    332c:	4b17      	ldr	r3, [pc, #92]	; (338c <_oscctrl_init_referenced_generators+0xd8>)
    332e:	4798      	blx	r3
    3330:	4603      	mov	r3, r0
    3332:	f083 0301 	eor.w	r3, r3, #1
    3336:	b2db      	uxtb	r3, r3
    3338:	2b00      	cmp	r3, #0
    333a:	d1eb      	bne.n	3314 <_oscctrl_init_referenced_generators+0x60>
#endif
#endif

#if CONF_FDPLL1_CONFIG == 1
#if CONF_FDPLL1_ENABLE == 1
	while (!(hri_oscctrl_get_DPLLSTATUS_LOCK_bit(hw, 1) || hri_oscctrl_get_DPLLSTATUS_CLKRDY_bit(hw, 1)))
    333c:	bf00      	nop
    333e:	2101      	movs	r1, #1
    3340:	6878      	ldr	r0, [r7, #4]
    3342:	4b11      	ldr	r3, [pc, #68]	; (3388 <_oscctrl_init_referenced_generators+0xd4>)
    3344:	4798      	blx	r3
    3346:	4603      	mov	r3, r0
    3348:	f083 0301 	eor.w	r3, r3, #1
    334c:	b2db      	uxtb	r3, r3
    334e:	2b00      	cmp	r3, #0
    3350:	d009      	beq.n	3366 <_oscctrl_init_referenced_generators+0xb2>
    3352:	2101      	movs	r1, #1
    3354:	6878      	ldr	r0, [r7, #4]
    3356:	4b0d      	ldr	r3, [pc, #52]	; (338c <_oscctrl_init_referenced_generators+0xd8>)
    3358:	4798      	blx	r3
    335a:	4603      	mov	r3, r0
    335c:	f083 0301 	eor.w	r3, r3, #1
    3360:	b2db      	uxtb	r3, r3
    3362:	2b00      	cmp	r3, #0
    3364:	d1eb      	bne.n	333e <_oscctrl_init_referenced_generators+0x8a>
	hri_gclk_write_GENCTRL_SRC_bf(GCLK, 0, CONF_GCLK_GEN_0_SOURCE);
	while (hri_gclk_get_SYNCBUSY_GENCTRL0_bit(GCLK))
		;
#endif
	(void)hw;
}
    3366:	bf00      	nop
    3368:	3708      	adds	r7, #8
    336a:	46bd      	mov	sp, r7
    336c:	bd80      	pop	{r7, pc}
    336e:	bf00      	nop
    3370:	40001000 	.word	0x40001000
    3374:	40001c00 	.word	0x40001c00
    3378:	000030ad 	.word	0x000030ad
    337c:	000031b9 	.word	0x000031b9
    3380:	000031f5 	.word	0x000031f5
    3384:	0000317d 	.word	0x0000317d
    3388:	00003109 	.word	0x00003109
    338c:	00003141 	.word	0x00003141

00003390 <hri_pcc_clear_IMR_DRDY_bit>:
		((Pcc *)hw)->IER.reg = PCC_IMR_DRDY;
	}
}

static inline void hri_pcc_clear_IMR_DRDY_bit(const void *const hw)
{
    3390:	b480      	push	{r7}
    3392:	b083      	sub	sp, #12
    3394:	af00      	add	r7, sp, #0
    3396:	6078      	str	r0, [r7, #4]
	((Pcc *)hw)->IDR.reg = PCC_IMR_DRDY;
    3398:	687b      	ldr	r3, [r7, #4]
    339a:	2201      	movs	r2, #1
    339c:	609a      	str	r2, [r3, #8]
}
    339e:	bf00      	nop
    33a0:	370c      	adds	r7, #12
    33a2:	46bd      	mov	sp, r7
    33a4:	f85d 7b04 	ldr.w	r7, [sp], #4
    33a8:	4770      	bx	lr

000033aa <hri_pcc_read_ISR_reg>:
	tmp &= mask;
	return tmp;
}

static inline hri_pcc_isr_reg_t hri_pcc_read_ISR_reg(const void *const hw)
{
    33aa:	b480      	push	{r7}
    33ac:	b083      	sub	sp, #12
    33ae:	af00      	add	r7, sp, #0
    33b0:	6078      	str	r0, [r7, #4]
	return ((Pcc *)hw)->ISR.reg;
    33b2:	687b      	ldr	r3, [r7, #4]
    33b4:	691b      	ldr	r3, [r3, #16]
}
    33b6:	4618      	mov	r0, r3
    33b8:	370c      	adds	r7, #12
    33ba:	46bd      	mov	sp, r7
    33bc:	f85d 7b04 	ldr.w	r7, [sp], #4
    33c0:	4770      	bx	lr

000033c2 <hri_pcc_set_MR_reg>:
{
	return ((Pcc *)hw)->WPSR.reg;
}

static inline void hri_pcc_set_MR_reg(const void *const hw, hri_pcc_mr_reg_t mask)
{
    33c2:	b480      	push	{r7}
    33c4:	b083      	sub	sp, #12
    33c6:	af00      	add	r7, sp, #0
    33c8:	6078      	str	r0, [r7, #4]
    33ca:	6039      	str	r1, [r7, #0]
	PCC_CRITICAL_SECTION_ENTER();
	((Pcc *)hw)->MR.reg |= mask;
    33cc:	687b      	ldr	r3, [r7, #4]
    33ce:	681a      	ldr	r2, [r3, #0]
    33d0:	683b      	ldr	r3, [r7, #0]
    33d2:	431a      	orrs	r2, r3
    33d4:	687b      	ldr	r3, [r7, #4]
    33d6:	601a      	str	r2, [r3, #0]
	PCC_CRITICAL_SECTION_LEAVE();
}
    33d8:	bf00      	nop
    33da:	370c      	adds	r7, #12
    33dc:	46bd      	mov	sp, r7
    33de:	f85d 7b04 	ldr.w	r7, [sp], #4
    33e2:	4770      	bx	lr

000033e4 <hri_pcc_write_MR_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_pcc_write_MR_reg(const void *const hw, hri_pcc_mr_reg_t data)
{
    33e4:	b480      	push	{r7}
    33e6:	b083      	sub	sp, #12
    33e8:	af00      	add	r7, sp, #0
    33ea:	6078      	str	r0, [r7, #4]
    33ec:	6039      	str	r1, [r7, #0]
	PCC_CRITICAL_SECTION_ENTER();
	((Pcc *)hw)->MR.reg = data;
    33ee:	687b      	ldr	r3, [r7, #4]
    33f0:	683a      	ldr	r2, [r7, #0]
    33f2:	601a      	str	r2, [r3, #0]
	PCC_CRITICAL_SECTION_LEAVE();
}
    33f4:	bf00      	nop
    33f6:	370c      	adds	r7, #12
    33f8:	46bd      	mov	sp, r7
    33fa:	f85d 7b04 	ldr.w	r7, [sp], #4
    33fe:	4770      	bx	lr

00003400 <_pcc_dma_transfer_done>:
/*!< Pointer to hpl device */
static struct _camera_async_device *_pcc_dev = NULL;

struct _dma_resource *resource;
static void           _pcc_dma_transfer_done(struct _dma_resource *resource)
{
    3400:	b580      	push	{r7, lr}
    3402:	b084      	sub	sp, #16
    3404:	af00      	add	r7, sp, #0
    3406:	6078      	str	r0, [r7, #4]
	struct _camera_async_device *dev = (struct _camera_async_device *)resource->back;
    3408:	687b      	ldr	r3, [r7, #4]
    340a:	689b      	ldr	r3, [r3, #8]
    340c:	60fb      	str	r3, [r7, #12]
	dev->capture_done(dev, 0);
    340e:	68fb      	ldr	r3, [r7, #12]
    3410:	681b      	ldr	r3, [r3, #0]
    3412:	2100      	movs	r1, #0
    3414:	68f8      	ldr	r0, [r7, #12]
    3416:	4798      	blx	r3
}
    3418:	bf00      	nop
    341a:	3710      	adds	r7, #16
    341c:	46bd      	mov	sp, r7
    341e:	bd80      	pop	{r7, pc}

00003420 <_camera_async_init>:

void _camera_async_init(struct _camera_async_device *const device, void *const hw)
{
    3420:	b580      	push	{r7, lr}
    3422:	b084      	sub	sp, #16
    3424:	af00      	add	r7, sp, #0
    3426:	6078      	str	r0, [r7, #4]
    3428:	6039      	str	r1, [r7, #0]
	uint32_t data = 0;
    342a:	2300      	movs	r3, #0
    342c:	60fb      	str	r3, [r7, #12]
	device->hw    = hw;
    342e:	687b      	ldr	r3, [r7, #4]
    3430:	683a      	ldr	r2, [r7, #0]
    3432:	60da      	str	r2, [r3, #12]

	data = PCC_MR_CID(0x3) | PCC_MR_ISIZE(CONF_PCC_ISIZE) | CONF_PCC_FRSTS << PCC_MR_FRSTS_Pos
    3434:	4b0d      	ldr	r3, [pc, #52]	; (346c <_camera_async_init+0x4c>)
    3436:	60fb      	str	r3, [r7, #12]
	       | CONF_PCC_HALFS << PCC_MR_HALFS_Pos | CONF_PCC_ALWYS << PCC_MR_ALWYS_Pos
	       | CONF_PCC_SCALE << PCC_MR_SCALE_Pos | PCC_MR_DSIZE(CONF_PCC_DSIZE);
	hri_pcc_write_MR_reg(device->hw, data);
    3438:	687b      	ldr	r3, [r7, #4]
    343a:	68db      	ldr	r3, [r3, #12]
    343c:	68f9      	ldr	r1, [r7, #12]
    343e:	4618      	mov	r0, r3
    3440:	4b0b      	ldr	r3, [pc, #44]	; (3470 <_camera_async_init+0x50>)
    3442:	4798      	blx	r3

	_pcc_dev = device;
    3444:	4a0b      	ldr	r2, [pc, #44]	; (3474 <_camera_async_init+0x54>)
    3446:	687b      	ldr	r3, [r7, #4]
    3448:	6013      	str	r3, [r2, #0]

	_dma_get_channel_resource(&resource, CONF_PCC_DMA_CHANNEL);
    344a:	2100      	movs	r1, #0
    344c:	480a      	ldr	r0, [pc, #40]	; (3478 <_camera_async_init+0x58>)
    344e:	4b0b      	ldr	r3, [pc, #44]	; (347c <_camera_async_init+0x5c>)
    3450:	4798      	blx	r3
	resource->back                 = device;
    3452:	4b09      	ldr	r3, [pc, #36]	; (3478 <_camera_async_init+0x58>)
    3454:	681b      	ldr	r3, [r3, #0]
    3456:	687a      	ldr	r2, [r7, #4]
    3458:	609a      	str	r2, [r3, #8]
	resource->dma_cb.transfer_done = _pcc_dma_transfer_done;
    345a:	4b07      	ldr	r3, [pc, #28]	; (3478 <_camera_async_init+0x58>)
    345c:	681b      	ldr	r3, [r3, #0]
    345e:	4a08      	ldr	r2, [pc, #32]	; (3480 <_camera_async_init+0x60>)
    3460:	601a      	str	r2, [r3, #0]
}
    3462:	bf00      	nop
    3464:	3710      	adds	r7, #16
    3466:	46bd      	mov	sp, r7
    3468:	bd80      	pop	{r7, pc}
    346a:	bf00      	nop
    346c:	c0000020 	.word	0xc0000020
    3470:	000033e5 	.word	0x000033e5
    3474:	20000aa4 	.word	0x20000aa4
    3478:	20026364 	.word	0x20026364
    347c:	000026a5 	.word	0x000026a5
    3480:	00003401 	.word	0x00003401

00003484 <_camera_async_enable>:
{
	_camera_async_disable(device->hw);
}

void _camera_async_enable(struct _camera_async_device *const device)
{
    3484:	b580      	push	{r7, lr}
    3486:	b082      	sub	sp, #8
    3488:	af00      	add	r7, sp, #0
    348a:	6078      	str	r0, [r7, #4]
	hri_pcc_set_MR_reg(device->hw, PCC_MR_PCEN);
    348c:	687b      	ldr	r3, [r7, #4]
    348e:	68db      	ldr	r3, [r3, #12]
    3490:	2101      	movs	r1, #1
    3492:	4618      	mov	r0, r3
    3494:	4b02      	ldr	r3, [pc, #8]	; (34a0 <_camera_async_enable+0x1c>)
    3496:	4798      	blx	r3
}
    3498:	bf00      	nop
    349a:	3708      	adds	r7, #8
    349c:	46bd      	mov	sp, r7
    349e:	bd80      	pop	{r7, pc}
    34a0:	000033c3 	.word	0x000033c3

000034a4 <_camera_async_disable>:

void _camera_async_disable(struct _camera_async_device *const device)
{
    34a4:	b580      	push	{r7, lr}
    34a6:	b082      	sub	sp, #8
    34a8:	af00      	add	r7, sp, #0
    34aa:	6078      	str	r0, [r7, #4]
	hri_pcc_write_MR_reg(device->hw, 0);
    34ac:	687b      	ldr	r3, [r7, #4]
    34ae:	68db      	ldr	r3, [r3, #12]
    34b0:	2100      	movs	r1, #0
    34b2:	4618      	mov	r0, r3
    34b4:	4b02      	ldr	r3, [pc, #8]	; (34c0 <_camera_async_disable+0x1c>)
    34b6:	4798      	blx	r3
}
    34b8:	bf00      	nop
    34ba:	3708      	adds	r7, #8
    34bc:	46bd      	mov	sp, r7
    34be:	bd80      	pop	{r7, pc}
    34c0:	000033e5 	.word	0x000033e5

000034c4 <_camera_async_capture_start>:

void _camera_async_capture_start(struct _camera_async_device *const device, uint32_t ch, uint32_t *buf)
{
    34c4:	b580      	push	{r7, lr}
    34c6:	b084      	sub	sp, #16
    34c8:	af00      	add	r7, sp, #0
    34ca:	60f8      	str	r0, [r7, #12]
    34cc:	60b9      	str	r1, [r7, #8]
    34ce:	607a      	str	r2, [r7, #4]
	if (ch > CAMERA_CHN_NUM_MAX) {
    34d0:	68bb      	ldr	r3, [r7, #8]
    34d2:	2b01      	cmp	r3, #1
    34d4:	d81d      	bhi.n	3512 <_camera_async_capture_start+0x4e>
		return;
	}
	_dma_set_irq_state(CONF_PCC_DMA_CHANNEL, DMA_TRANSFER_COMPLETE_CB, true);
    34d6:	2201      	movs	r2, #1
    34d8:	2100      	movs	r1, #0
    34da:	2000      	movs	r0, #0
    34dc:	4b0f      	ldr	r3, [pc, #60]	; (351c <_camera_async_capture_start+0x58>)
    34de:	4798      	blx	r3

	_dma_set_source_address(CONF_PCC_DMA_CHANNEL, (void *)&(((Pcc *)device->hw)->RHR.reg));
    34e0:	68fb      	ldr	r3, [r7, #12]
    34e2:	68db      	ldr	r3, [r3, #12]
    34e4:	3314      	adds	r3, #20
    34e6:	4619      	mov	r1, r3
    34e8:	2000      	movs	r0, #0
    34ea:	4b0d      	ldr	r3, [pc, #52]	; (3520 <_camera_async_capture_start+0x5c>)
    34ec:	4798      	blx	r3
	_dma_set_destination_address(CONF_PCC_DMA_CHANNEL, buf);
    34ee:	6879      	ldr	r1, [r7, #4]
    34f0:	2000      	movs	r0, #0
    34f2:	4b0c      	ldr	r3, [pc, #48]	; (3524 <_camera_async_capture_start+0x60>)
    34f4:	4798      	blx	r3
	_dma_srcinc_enable(CONF_PCC_DMA_CHANNEL, false);
    34f6:	2100      	movs	r1, #0
    34f8:	2000      	movs	r0, #0
    34fa:	4b0b      	ldr	r3, [pc, #44]	; (3528 <_camera_async_capture_start+0x64>)
    34fc:	4798      	blx	r3
	_dma_set_data_amount(CONF_PCC_DMA_CHANNEL, CONF_PCC_DMA_FRAME_SIZE);
    34fe:	f44f 4116 	mov.w	r1, #38400	; 0x9600
    3502:	2000      	movs	r0, #0
    3504:	4b09      	ldr	r3, [pc, #36]	; (352c <_camera_async_capture_start+0x68>)
    3506:	4798      	blx	r3
	_dma_enable_transaction(CONF_PCC_DMA_CHANNEL, false);
    3508:	2100      	movs	r1, #0
    350a:	2000      	movs	r0, #0
    350c:	4b08      	ldr	r3, [pc, #32]	; (3530 <_camera_async_capture_start+0x6c>)
    350e:	4798      	blx	r3
    3510:	e000      	b.n	3514 <_camera_async_capture_start+0x50>
		return;
    3512:	bf00      	nop
}
    3514:	3710      	adds	r7, #16
    3516:	46bd      	mov	sp, r7
    3518:	bd80      	pop	{r7, pc}
    351a:	bf00      	nop
    351c:	00002491 	.word	0x00002491
    3520:	0000250d 	.word	0x0000250d
    3524:	000024dd 	.word	0x000024dd
    3528:	0000253d 	.word	0x0000253d
    352c:	00002571 	.word	0x00002571
    3530:	00002649 	.word	0x00002649

00003534 <PCC_Handler>:

void PCC_Handler(void)
{
    3534:	b580      	push	{r7, lr}
    3536:	b082      	sub	sp, #8
    3538:	af00      	add	r7, sp, #0
	void *const       hw       = _pcc_dev->hw;
    353a:	4b11      	ldr	r3, [pc, #68]	; (3580 <PCC_Handler+0x4c>)
    353c:	681b      	ldr	r3, [r3, #0]
    353e:	68db      	ldr	r3, [r3, #12]
    3540:	607b      	str	r3, [r7, #4]
	volatile uint32_t int_mask = hri_pcc_read_ISR_reg(hw);
    3542:	6878      	ldr	r0, [r7, #4]
    3544:	4b0f      	ldr	r3, [pc, #60]	; (3584 <PCC_Handler+0x50>)
    3546:	4798      	blx	r3
    3548:	4603      	mov	r3, r0
    354a:	603b      	str	r3, [r7, #0]
	hri_pcc_clear_IMR_DRDY_bit(hw);
    354c:	6878      	ldr	r0, [r7, #4]
    354e:	4b0e      	ldr	r3, [pc, #56]	; (3588 <PCC_Handler+0x54>)
    3550:	4798      	blx	r3

	if (int_mask & PCC_ISR_DRDY) {
    3552:	683b      	ldr	r3, [r7, #0]
    3554:	f003 0301 	and.w	r3, r3, #1
    3558:	2b00      	cmp	r3, #0
    355a:	d00d      	beq.n	3578 <PCC_Handler+0x44>
		if (_pcc_dev->capture_done) {
    355c:	4b08      	ldr	r3, [pc, #32]	; (3580 <PCC_Handler+0x4c>)
    355e:	681b      	ldr	r3, [r3, #0]
    3560:	681b      	ldr	r3, [r3, #0]
    3562:	2b00      	cmp	r3, #0
    3564:	d009      	beq.n	357a <PCC_Handler+0x46>
			_pcc_dev->capture_done(_pcc_dev, 0);
    3566:	4b06      	ldr	r3, [pc, #24]	; (3580 <PCC_Handler+0x4c>)
    3568:	681b      	ldr	r3, [r3, #0]
    356a:	681b      	ldr	r3, [r3, #0]
    356c:	4a04      	ldr	r2, [pc, #16]	; (3580 <PCC_Handler+0x4c>)
    356e:	6812      	ldr	r2, [r2, #0]
    3570:	2100      	movs	r1, #0
    3572:	4610      	mov	r0, r2
    3574:	4798      	blx	r3
    3576:	e000      	b.n	357a <PCC_Handler+0x46>
		}
	} else {
		return;
    3578:	bf00      	nop
	}
}
    357a:	3708      	adds	r7, #8
    357c:	46bd      	mov	sp, r7
    357e:	bd80      	pop	{r7, pc}
    3580:	20000aa4 	.word	0x20000aa4
    3584:	000033ab 	.word	0x000033ab
    3588:	00003391 	.word	0x00003391

0000358c <hri_ramecc_read_INTFLAG_reg>:
	tmp &= mask;
	return tmp;
}

static inline hri_ramecc_intflag_reg_t hri_ramecc_read_INTFLAG_reg(const void *const hw)
{
    358c:	b480      	push	{r7}
    358e:	b083      	sub	sp, #12
    3590:	af00      	add	r7, sp, #0
    3592:	6078      	str	r0, [r7, #4]
	return ((Ramecc *)hw)->INTFLAG.reg;
    3594:	687b      	ldr	r3, [r7, #4]
    3596:	789b      	ldrb	r3, [r3, #2]
    3598:	b2db      	uxtb	r3, r3
}
    359a:	4618      	mov	r0, r3
    359c:	370c      	adds	r7, #12
    359e:	46bd      	mov	sp, r7
    35a0:	f85d 7b04 	ldr.w	r7, [sp], #4
    35a4:	4770      	bx	lr

000035a6 <hri_ramecc_read_ERRADDR_reg>:
	tmp &= mask;
	return tmp;
}

static inline hri_ramecc_erraddr_reg_t hri_ramecc_read_ERRADDR_reg(const void *const hw)
{
    35a6:	b480      	push	{r7}
    35a8:	b083      	sub	sp, #12
    35aa:	af00      	add	r7, sp, #0
    35ac:	6078      	str	r0, [r7, #4]
	return ((Ramecc *)hw)->ERRADDR.reg;
    35ae:	687b      	ldr	r3, [r7, #4]
    35b0:	685b      	ldr	r3, [r3, #4]
}
    35b2:	4618      	mov	r0, r3
    35b4:	370c      	adds	r7, #12
    35b6:	46bd      	mov	sp, r7
    35b8:	f85d 7b04 	ldr.w	r7, [sp], #4
    35bc:	4770      	bx	lr
	...

000035c0 <RAMECC_Handler>:

/**
 * \internal RAMECC interrupt handler
 */
void RAMECC_Handler(void)
{
    35c0:	b590      	push	{r4, r7, lr}
    35c2:	b083      	sub	sp, #12
    35c4:	af00      	add	r7, sp, #0
	struct _ramecc_device *dev      = (struct _ramecc_device *)&device;
    35c6:	4b17      	ldr	r3, [pc, #92]	; (3624 <RAMECC_Handler+0x64>)
    35c8:	607b      	str	r3, [r7, #4]
	volatile uint32_t      int_mask = hri_ramecc_read_INTFLAG_reg(RAMECC);
    35ca:	4817      	ldr	r0, [pc, #92]	; (3628 <RAMECC_Handler+0x68>)
    35cc:	4b17      	ldr	r3, [pc, #92]	; (362c <RAMECC_Handler+0x6c>)
    35ce:	4798      	blx	r3
    35d0:	4603      	mov	r3, r0
    35d2:	603b      	str	r3, [r7, #0]

	if (int_mask & RAMECC_INTFLAG_DUALE && dev->ramecc_cb.dual_bit_err) {
    35d4:	683b      	ldr	r3, [r7, #0]
    35d6:	f003 0302 	and.w	r3, r3, #2
    35da:	2b00      	cmp	r3, #0
    35dc:	d00c      	beq.n	35f8 <RAMECC_Handler+0x38>
    35de:	687b      	ldr	r3, [r7, #4]
    35e0:	681b      	ldr	r3, [r3, #0]
    35e2:	2b00      	cmp	r3, #0
    35e4:	d008      	beq.n	35f8 <RAMECC_Handler+0x38>
		dev->ramecc_cb.dual_bit_err((uint32_t)hri_ramecc_read_ERRADDR_reg(RAMECC));
    35e6:	687b      	ldr	r3, [r7, #4]
    35e8:	681c      	ldr	r4, [r3, #0]
    35ea:	480f      	ldr	r0, [pc, #60]	; (3628 <RAMECC_Handler+0x68>)
    35ec:	4b10      	ldr	r3, [pc, #64]	; (3630 <RAMECC_Handler+0x70>)
    35ee:	4798      	blx	r3
    35f0:	4603      	mov	r3, r0
    35f2:	4618      	mov	r0, r3
    35f4:	47a0      	blx	r4
    35f6:	e012      	b.n	361e <RAMECC_Handler+0x5e>
	} else if (int_mask & RAMECC_INTFLAG_SINGLEE && dev->ramecc_cb.single_bit_err) {
    35f8:	683b      	ldr	r3, [r7, #0]
    35fa:	f003 0301 	and.w	r3, r3, #1
    35fe:	2b00      	cmp	r3, #0
    3600:	d00c      	beq.n	361c <RAMECC_Handler+0x5c>
    3602:	687b      	ldr	r3, [r7, #4]
    3604:	685b      	ldr	r3, [r3, #4]
    3606:	2b00      	cmp	r3, #0
    3608:	d008      	beq.n	361c <RAMECC_Handler+0x5c>
		dev->ramecc_cb.single_bit_err((uint32_t)hri_ramecc_read_ERRADDR_reg(RAMECC));
    360a:	687b      	ldr	r3, [r7, #4]
    360c:	685c      	ldr	r4, [r3, #4]
    360e:	4806      	ldr	r0, [pc, #24]	; (3628 <RAMECC_Handler+0x68>)
    3610:	4b07      	ldr	r3, [pc, #28]	; (3630 <RAMECC_Handler+0x70>)
    3612:	4798      	blx	r3
    3614:	4603      	mov	r3, r0
    3616:	4618      	mov	r0, r3
    3618:	47a0      	blx	r4
    361a:	e000      	b.n	361e <RAMECC_Handler+0x5e>
	} else {
		return;
    361c:	bf00      	nop
	}
}
    361e:	370c      	adds	r7, #12
    3620:	46bd      	mov	sp, r7
    3622:	bd90      	pop	{r4, r7, pc}
    3624:	20026368 	.word	0x20026368
    3628:	41020000 	.word	0x41020000
    362c:	0000358d 	.word	0x0000358d
    3630:	000035a7 	.word	0x000035a7

00003634 <__NVIC_EnableIRQ>:
{
    3634:	b480      	push	{r7}
    3636:	b083      	sub	sp, #12
    3638:	af00      	add	r7, sp, #0
    363a:	4603      	mov	r3, r0
    363c:	80fb      	strh	r3, [r7, #6]
  if ((int32_t)(IRQn) >= 0)
    363e:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
    3642:	2b00      	cmp	r3, #0
    3644:	db0b      	blt.n	365e <__NVIC_EnableIRQ+0x2a>
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    3646:	4909      	ldr	r1, [pc, #36]	; (366c <__NVIC_EnableIRQ+0x38>)
    3648:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
    364c:	095b      	lsrs	r3, r3, #5
    364e:	88fa      	ldrh	r2, [r7, #6]
    3650:	f002 021f 	and.w	r2, r2, #31
    3654:	2001      	movs	r0, #1
    3656:	fa00 f202 	lsl.w	r2, r0, r2
    365a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    365e:	bf00      	nop
    3660:	370c      	adds	r7, #12
    3662:	46bd      	mov	sp, r7
    3664:	f85d 7b04 	ldr.w	r7, [sp], #4
    3668:	4770      	bx	lr
    366a:	bf00      	nop
    366c:	e000e100 	.word	0xe000e100

00003670 <__NVIC_DisableIRQ>:
{
    3670:	b480      	push	{r7}
    3672:	b083      	sub	sp, #12
    3674:	af00      	add	r7, sp, #0
    3676:	4603      	mov	r3, r0
    3678:	80fb      	strh	r3, [r7, #6]
  if ((int32_t)(IRQn) >= 0)
    367a:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
    367e:	2b00      	cmp	r3, #0
    3680:	db10      	blt.n	36a4 <__NVIC_DisableIRQ+0x34>
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    3682:	490b      	ldr	r1, [pc, #44]	; (36b0 <__NVIC_DisableIRQ+0x40>)
    3684:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
    3688:	095b      	lsrs	r3, r3, #5
    368a:	88fa      	ldrh	r2, [r7, #6]
    368c:	f002 021f 	and.w	r2, r2, #31
    3690:	2001      	movs	r0, #1
    3692:	fa00 f202 	lsl.w	r2, r0, r2
    3696:	3320      	adds	r3, #32
    3698:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  __ASM volatile ("dsb 0xF":::"memory");
    369c:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    36a0:	f3bf 8f6f 	isb	sy
}
    36a4:	bf00      	nop
    36a6:	370c      	adds	r7, #12
    36a8:	46bd      	mov	sp, r7
    36aa:	f85d 7b04 	ldr.w	r7, [sp], #4
    36ae:	4770      	bx	lr
    36b0:	e000e100 	.word	0xe000e100

000036b4 <__NVIC_ClearPendingIRQ>:
{
    36b4:	b480      	push	{r7}
    36b6:	b083      	sub	sp, #12
    36b8:	af00      	add	r7, sp, #0
    36ba:	4603      	mov	r3, r0
    36bc:	80fb      	strh	r3, [r7, #6]
  if ((int32_t)(IRQn) >= 0)
    36be:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
    36c2:	2b00      	cmp	r3, #0
    36c4:	db0c      	blt.n	36e0 <__NVIC_ClearPendingIRQ+0x2c>
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    36c6:	4909      	ldr	r1, [pc, #36]	; (36ec <__NVIC_ClearPendingIRQ+0x38>)
    36c8:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
    36cc:	095b      	lsrs	r3, r3, #5
    36ce:	88fa      	ldrh	r2, [r7, #6]
    36d0:	f002 021f 	and.w	r2, r2, #31
    36d4:	2001      	movs	r0, #1
    36d6:	fa00 f202 	lsl.w	r2, r0, r2
    36da:	3360      	adds	r3, #96	; 0x60
    36dc:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    36e0:	bf00      	nop
    36e2:	370c      	adds	r7, #12
    36e4:	46bd      	mov	sp, r7
    36e6:	f85d 7b04 	ldr.w	r7, [sp], #4
    36ea:	4770      	bx	lr
    36ec:	e000e100 	.word	0xe000e100

000036f0 <hri_sercomi2cm_wait_for_sync>:
typedef uint8_t  hri_sercomusart_intflag_reg_t;
typedef uint8_t  hri_sercomusart_rxerrcnt_reg_t;
typedef uint8_t  hri_sercomusart_rxpl_reg_t;

static inline void hri_sercomi2cm_wait_for_sync(const void *const hw, hri_sercomi2cm_syncbusy_reg_t reg)
{
    36f0:	b480      	push	{r7}
    36f2:	b083      	sub	sp, #12
    36f4:	af00      	add	r7, sp, #0
    36f6:	6078      	str	r0, [r7, #4]
    36f8:	6039      	str	r1, [r7, #0]
	while (((Sercom *)hw)->I2CM.SYNCBUSY.reg & reg) {
    36fa:	bf00      	nop
    36fc:	687b      	ldr	r3, [r7, #4]
    36fe:	69da      	ldr	r2, [r3, #28]
    3700:	683b      	ldr	r3, [r7, #0]
    3702:	4013      	ands	r3, r2
    3704:	2b00      	cmp	r3, #0
    3706:	d1f9      	bne.n	36fc <hri_sercomi2cm_wait_for_sync+0xc>
	};
}
    3708:	bf00      	nop
    370a:	370c      	adds	r7, #12
    370c:	46bd      	mov	sp, r7
    370e:	f85d 7b04 	ldr.w	r7, [sp], #4
    3712:	4770      	bx	lr

00003714 <hri_sercomi2cm_is_syncing>:

static inline bool hri_sercomi2cm_is_syncing(const void *const hw, hri_sercomi2cm_syncbusy_reg_t reg)
{
    3714:	b480      	push	{r7}
    3716:	b083      	sub	sp, #12
    3718:	af00      	add	r7, sp, #0
    371a:	6078      	str	r0, [r7, #4]
    371c:	6039      	str	r1, [r7, #0]
	return ((Sercom *)hw)->I2CM.SYNCBUSY.reg & reg;
    371e:	687b      	ldr	r3, [r7, #4]
    3720:	69da      	ldr	r2, [r3, #28]
    3722:	683b      	ldr	r3, [r7, #0]
    3724:	4013      	ands	r3, r2
    3726:	2b00      	cmp	r3, #0
    3728:	bf14      	ite	ne
    372a:	2301      	movne	r3, #1
    372c:	2300      	moveq	r3, #0
    372e:	b2db      	uxtb	r3, r3
}
    3730:	4618      	mov	r0, r3
    3732:	370c      	adds	r7, #12
    3734:	46bd      	mov	sp, r7
    3736:	f85d 7b04 	ldr.w	r7, [sp], #4
    373a:	4770      	bx	lr

0000373c <hri_sercomusart_wait_for_sync>:
{
	return ((Sercom *)hw)->SPI.SYNCBUSY.reg & reg;
}

static inline void hri_sercomusart_wait_for_sync(const void *const hw, hri_sercomusart_syncbusy_reg_t reg)
{
    373c:	b480      	push	{r7}
    373e:	b083      	sub	sp, #12
    3740:	af00      	add	r7, sp, #0
    3742:	6078      	str	r0, [r7, #4]
    3744:	6039      	str	r1, [r7, #0]
	while (((Sercom *)hw)->USART.SYNCBUSY.reg & reg) {
    3746:	bf00      	nop
    3748:	687b      	ldr	r3, [r7, #4]
    374a:	69da      	ldr	r2, [r3, #28]
    374c:	683b      	ldr	r3, [r7, #0]
    374e:	4013      	ands	r3, r2
    3750:	2b00      	cmp	r3, #0
    3752:	d1f9      	bne.n	3748 <hri_sercomusart_wait_for_sync+0xc>
	};
}
    3754:	bf00      	nop
    3756:	370c      	adds	r7, #12
    3758:	46bd      	mov	sp, r7
    375a:	f85d 7b04 	ldr.w	r7, [sp], #4
    375e:	4770      	bx	lr

00003760 <hri_sercomusart_is_syncing>:

static inline bool hri_sercomusart_is_syncing(const void *const hw, hri_sercomusart_syncbusy_reg_t reg)
{
    3760:	b480      	push	{r7}
    3762:	b083      	sub	sp, #12
    3764:	af00      	add	r7, sp, #0
    3766:	6078      	str	r0, [r7, #4]
    3768:	6039      	str	r1, [r7, #0]
	return ((Sercom *)hw)->USART.SYNCBUSY.reg & reg;
    376a:	687b      	ldr	r3, [r7, #4]
    376c:	69da      	ldr	r2, [r3, #28]
    376e:	683b      	ldr	r3, [r7, #0]
    3770:	4013      	ands	r3, r2
    3772:	2b00      	cmp	r3, #0
    3774:	bf14      	ite	ne
    3776:	2301      	movne	r3, #1
    3778:	2300      	moveq	r3, #0
    377a:	b2db      	uxtb	r3, r3
}
    377c:	4618      	mov	r0, r3
    377e:	370c      	adds	r7, #12
    3780:	46bd      	mov	sp, r7
    3782:	f85d 7b04 	ldr.w	r7, [sp], #4
    3786:	4770      	bx	lr

00003788 <hri_sercomi2cm_clear_interrupt_MB_bit>:
{
	return (((Sercom *)hw)->I2CM.INTFLAG.reg & SERCOM_I2CM_INTFLAG_MB) >> SERCOM_I2CM_INTFLAG_MB_Pos;
}

static inline void hri_sercomi2cm_clear_interrupt_MB_bit(const void *const hw)
{
    3788:	b480      	push	{r7}
    378a:	b083      	sub	sp, #12
    378c:	af00      	add	r7, sp, #0
    378e:	6078      	str	r0, [r7, #4]
	((Sercom *)hw)->I2CM.INTFLAG.reg = SERCOM_I2CM_INTFLAG_MB;
    3790:	687b      	ldr	r3, [r7, #4]
    3792:	2201      	movs	r2, #1
    3794:	761a      	strb	r2, [r3, #24]
}
    3796:	bf00      	nop
    3798:	370c      	adds	r7, #12
    379a:	46bd      	mov	sp, r7
    379c:	f85d 7b04 	ldr.w	r7, [sp], #4
    37a0:	4770      	bx	lr

000037a2 <hri_sercomi2cm_clear_interrupt_SB_bit>:
{
	return (((Sercom *)hw)->I2CM.INTFLAG.reg & SERCOM_I2CM_INTFLAG_SB) >> SERCOM_I2CM_INTFLAG_SB_Pos;
}

static inline void hri_sercomi2cm_clear_interrupt_SB_bit(const void *const hw)
{
    37a2:	b480      	push	{r7}
    37a4:	b083      	sub	sp, #12
    37a6:	af00      	add	r7, sp, #0
    37a8:	6078      	str	r0, [r7, #4]
	((Sercom *)hw)->I2CM.INTFLAG.reg = SERCOM_I2CM_INTFLAG_SB;
    37aa:	687b      	ldr	r3, [r7, #4]
    37ac:	2202      	movs	r2, #2
    37ae:	761a      	strb	r2, [r3, #24]
}
    37b0:	bf00      	nop
    37b2:	370c      	adds	r7, #12
    37b4:	46bd      	mov	sp, r7
    37b6:	f85d 7b04 	ldr.w	r7, [sp], #4
    37ba:	4770      	bx	lr

000037bc <hri_sercomi2cm_read_INTFLAG_reg>:
	tmp &= mask;
	return tmp;
}

static inline hri_sercomi2cm_intflag_reg_t hri_sercomi2cm_read_INTFLAG_reg(const void *const hw)
{
    37bc:	b480      	push	{r7}
    37be:	b083      	sub	sp, #12
    37c0:	af00      	add	r7, sp, #0
    37c2:	6078      	str	r0, [r7, #4]
	return ((Sercom *)hw)->I2CM.INTFLAG.reg;
    37c4:	687b      	ldr	r3, [r7, #4]
    37c6:	7e1b      	ldrb	r3, [r3, #24]
    37c8:	b2db      	uxtb	r3, r3
}
    37ca:	4618      	mov	r0, r3
    37cc:	370c      	adds	r7, #12
    37ce:	46bd      	mov	sp, r7
    37d0:	f85d 7b04 	ldr.w	r7, [sp], #4
    37d4:	4770      	bx	lr

000037d6 <hri_sercomusart_get_interrupt_DRE_bit>:
{
	((Sercom *)hw)->USART.INTFLAG.reg = SERCOM_USART_INTFLAG_ERROR;
}

static inline bool hri_sercomusart_get_interrupt_DRE_bit(const void *const hw)
{
    37d6:	b480      	push	{r7}
    37d8:	b083      	sub	sp, #12
    37da:	af00      	add	r7, sp, #0
    37dc:	6078      	str	r0, [r7, #4]
	return (((Sercom *)hw)->USART.INTFLAG.reg & SERCOM_USART_INTFLAG_DRE) >> SERCOM_USART_INTFLAG_DRE_Pos;
    37de:	687b      	ldr	r3, [r7, #4]
    37e0:	7e1b      	ldrb	r3, [r3, #24]
    37e2:	b2db      	uxtb	r3, r3
    37e4:	f003 0301 	and.w	r3, r3, #1
    37e8:	2b00      	cmp	r3, #0
    37ea:	bf14      	ite	ne
    37ec:	2301      	movne	r3, #1
    37ee:	2300      	moveq	r3, #0
    37f0:	b2db      	uxtb	r3, r3
}
    37f2:	4618      	mov	r0, r3
    37f4:	370c      	adds	r7, #12
    37f6:	46bd      	mov	sp, r7
    37f8:	f85d 7b04 	ldr.w	r7, [sp], #4
    37fc:	4770      	bx	lr

000037fe <hri_sercomusart_get_interrupt_TXC_bit>:
{
	((Sercom *)hw)->USART.INTFLAG.reg = SERCOM_USART_INTFLAG_DRE;
}

static inline bool hri_sercomusart_get_interrupt_TXC_bit(const void *const hw)
{
    37fe:	b480      	push	{r7}
    3800:	b083      	sub	sp, #12
    3802:	af00      	add	r7, sp, #0
    3804:	6078      	str	r0, [r7, #4]
	return (((Sercom *)hw)->USART.INTFLAG.reg & SERCOM_USART_INTFLAG_TXC) >> SERCOM_USART_INTFLAG_TXC_Pos;
    3806:	687b      	ldr	r3, [r7, #4]
    3808:	7e1b      	ldrb	r3, [r3, #24]
    380a:	b2db      	uxtb	r3, r3
    380c:	085b      	lsrs	r3, r3, #1
    380e:	f003 0301 	and.w	r3, r3, #1
    3812:	2b00      	cmp	r3, #0
    3814:	bf14      	ite	ne
    3816:	2301      	movne	r3, #1
    3818:	2300      	moveq	r3, #0
    381a:	b2db      	uxtb	r3, r3
}
    381c:	4618      	mov	r0, r3
    381e:	370c      	adds	r7, #12
    3820:	46bd      	mov	sp, r7
    3822:	f85d 7b04 	ldr.w	r7, [sp], #4
    3826:	4770      	bx	lr

00003828 <hri_sercomusart_get_interrupt_RXC_bit>:
{
	((Sercom *)hw)->USART.INTFLAG.reg = SERCOM_USART_INTFLAG_TXC;
}

static inline bool hri_sercomusart_get_interrupt_RXC_bit(const void *const hw)
{
    3828:	b480      	push	{r7}
    382a:	b083      	sub	sp, #12
    382c:	af00      	add	r7, sp, #0
    382e:	6078      	str	r0, [r7, #4]
	return (((Sercom *)hw)->USART.INTFLAG.reg & SERCOM_USART_INTFLAG_RXC) >> SERCOM_USART_INTFLAG_RXC_Pos;
    3830:	687b      	ldr	r3, [r7, #4]
    3832:	7e1b      	ldrb	r3, [r3, #24]
    3834:	b2db      	uxtb	r3, r3
    3836:	089b      	lsrs	r3, r3, #2
    3838:	f003 0301 	and.w	r3, r3, #1
    383c:	2b00      	cmp	r3, #0
    383e:	bf14      	ite	ne
    3840:	2301      	movne	r3, #1
    3842:	2300      	moveq	r3, #0
    3844:	b2db      	uxtb	r3, r3
}
    3846:	4618      	mov	r0, r3
    3848:	370c      	adds	r7, #12
    384a:	46bd      	mov	sp, r7
    384c:	f85d 7b04 	ldr.w	r7, [sp], #4
    3850:	4770      	bx	lr

00003852 <hri_sercomusart_get_interrupt_ERROR_bit>:
{
	((Sercom *)hw)->USART.INTFLAG.reg = SERCOM_USART_INTFLAG_RXBRK;
}

static inline bool hri_sercomusart_get_interrupt_ERROR_bit(const void *const hw)
{
    3852:	b480      	push	{r7}
    3854:	b083      	sub	sp, #12
    3856:	af00      	add	r7, sp, #0
    3858:	6078      	str	r0, [r7, #4]
	return (((Sercom *)hw)->USART.INTFLAG.reg & SERCOM_USART_INTFLAG_ERROR) >> SERCOM_USART_INTFLAG_ERROR_Pos;
    385a:	687b      	ldr	r3, [r7, #4]
    385c:	7e1b      	ldrb	r3, [r3, #24]
    385e:	b2db      	uxtb	r3, r3
    3860:	09db      	lsrs	r3, r3, #7
    3862:	f003 0301 	and.w	r3, r3, #1
    3866:	2b00      	cmp	r3, #0
    3868:	bf14      	ite	ne
    386a:	2301      	movne	r3, #1
    386c:	2300      	moveq	r3, #0
    386e:	b2db      	uxtb	r3, r3
}
    3870:	4618      	mov	r0, r3
    3872:	370c      	adds	r7, #12
    3874:	46bd      	mov	sp, r7
    3876:	f85d 7b04 	ldr.w	r7, [sp], #4
    387a:	4770      	bx	lr

0000387c <hri_sercomusart_clear_interrupt_ERROR_bit>:

static inline void hri_sercomusart_clear_interrupt_ERROR_bit(const void *const hw)
{
    387c:	b480      	push	{r7}
    387e:	b083      	sub	sp, #12
    3880:	af00      	add	r7, sp, #0
    3882:	6078      	str	r0, [r7, #4]
	((Sercom *)hw)->USART.INTFLAG.reg = SERCOM_USART_INTFLAG_ERROR;
    3884:	687b      	ldr	r3, [r7, #4]
    3886:	2280      	movs	r2, #128	; 0x80
    3888:	761a      	strb	r2, [r3, #24]
}
    388a:	bf00      	nop
    388c:	370c      	adds	r7, #12
    388e:	46bd      	mov	sp, r7
    3890:	f85d 7b04 	ldr.w	r7, [sp], #4
    3894:	4770      	bx	lr

00003896 <hri_sercomusart_set_INTEN_DRE_bit>:
{
	((Sercom *)hw)->SPI.INTENCLR.reg = mask;
}

static inline void hri_sercomusart_set_INTEN_DRE_bit(const void *const hw)
{
    3896:	b480      	push	{r7}
    3898:	b083      	sub	sp, #12
    389a:	af00      	add	r7, sp, #0
    389c:	6078      	str	r0, [r7, #4]
	((Sercom *)hw)->USART.INTENSET.reg = SERCOM_USART_INTENSET_DRE;
    389e:	687b      	ldr	r3, [r7, #4]
    38a0:	2201      	movs	r2, #1
    38a2:	759a      	strb	r2, [r3, #22]
}
    38a4:	bf00      	nop
    38a6:	370c      	adds	r7, #12
    38a8:	46bd      	mov	sp, r7
    38aa:	f85d 7b04 	ldr.w	r7, [sp], #4
    38ae:	4770      	bx	lr

000038b0 <hri_sercomusart_get_INTEN_DRE_bit>:

static inline bool hri_sercomusart_get_INTEN_DRE_bit(const void *const hw)
{
    38b0:	b480      	push	{r7}
    38b2:	b083      	sub	sp, #12
    38b4:	af00      	add	r7, sp, #0
    38b6:	6078      	str	r0, [r7, #4]
	return (((Sercom *)hw)->USART.INTENSET.reg & SERCOM_USART_INTENSET_DRE) >> SERCOM_USART_INTENSET_DRE_Pos;
    38b8:	687b      	ldr	r3, [r7, #4]
    38ba:	7d9b      	ldrb	r3, [r3, #22]
    38bc:	b2db      	uxtb	r3, r3
    38be:	f003 0301 	and.w	r3, r3, #1
    38c2:	2b00      	cmp	r3, #0
    38c4:	bf14      	ite	ne
    38c6:	2301      	movne	r3, #1
    38c8:	2300      	moveq	r3, #0
    38ca:	b2db      	uxtb	r3, r3
}
    38cc:	4618      	mov	r0, r3
    38ce:	370c      	adds	r7, #12
    38d0:	46bd      	mov	sp, r7
    38d2:	f85d 7b04 	ldr.w	r7, [sp], #4
    38d6:	4770      	bx	lr

000038d8 <hri_sercomusart_clear_INTEN_DRE_bit>:
		((Sercom *)hw)->USART.INTENSET.reg = SERCOM_USART_INTENSET_DRE;
	}
}

static inline void hri_sercomusart_clear_INTEN_DRE_bit(const void *const hw)
{
    38d8:	b480      	push	{r7}
    38da:	b083      	sub	sp, #12
    38dc:	af00      	add	r7, sp, #0
    38de:	6078      	str	r0, [r7, #4]
	((Sercom *)hw)->USART.INTENCLR.reg = SERCOM_USART_INTENSET_DRE;
    38e0:	687b      	ldr	r3, [r7, #4]
    38e2:	2201      	movs	r2, #1
    38e4:	751a      	strb	r2, [r3, #20]
}
    38e6:	bf00      	nop
    38e8:	370c      	adds	r7, #12
    38ea:	46bd      	mov	sp, r7
    38ec:	f85d 7b04 	ldr.w	r7, [sp], #4
    38f0:	4770      	bx	lr

000038f2 <hri_sercomusart_set_INTEN_TXC_bit>:

static inline void hri_sercomusart_set_INTEN_TXC_bit(const void *const hw)
{
    38f2:	b480      	push	{r7}
    38f4:	b083      	sub	sp, #12
    38f6:	af00      	add	r7, sp, #0
    38f8:	6078      	str	r0, [r7, #4]
	((Sercom *)hw)->USART.INTENSET.reg = SERCOM_USART_INTENSET_TXC;
    38fa:	687b      	ldr	r3, [r7, #4]
    38fc:	2202      	movs	r2, #2
    38fe:	759a      	strb	r2, [r3, #22]
}
    3900:	bf00      	nop
    3902:	370c      	adds	r7, #12
    3904:	46bd      	mov	sp, r7
    3906:	f85d 7b04 	ldr.w	r7, [sp], #4
    390a:	4770      	bx	lr

0000390c <hri_sercomusart_get_INTEN_TXC_bit>:

static inline bool hri_sercomusart_get_INTEN_TXC_bit(const void *const hw)
{
    390c:	b480      	push	{r7}
    390e:	b083      	sub	sp, #12
    3910:	af00      	add	r7, sp, #0
    3912:	6078      	str	r0, [r7, #4]
	return (((Sercom *)hw)->USART.INTENSET.reg & SERCOM_USART_INTENSET_TXC) >> SERCOM_USART_INTENSET_TXC_Pos;
    3914:	687b      	ldr	r3, [r7, #4]
    3916:	7d9b      	ldrb	r3, [r3, #22]
    3918:	b2db      	uxtb	r3, r3
    391a:	085b      	lsrs	r3, r3, #1
    391c:	f003 0301 	and.w	r3, r3, #1
    3920:	2b00      	cmp	r3, #0
    3922:	bf14      	ite	ne
    3924:	2301      	movne	r3, #1
    3926:	2300      	moveq	r3, #0
    3928:	b2db      	uxtb	r3, r3
}
    392a:	4618      	mov	r0, r3
    392c:	370c      	adds	r7, #12
    392e:	46bd      	mov	sp, r7
    3930:	f85d 7b04 	ldr.w	r7, [sp], #4
    3934:	4770      	bx	lr

00003936 <hri_sercomusart_clear_INTEN_TXC_bit>:
		((Sercom *)hw)->USART.INTENSET.reg = SERCOM_USART_INTENSET_TXC;
	}
}

static inline void hri_sercomusart_clear_INTEN_TXC_bit(const void *const hw)
{
    3936:	b480      	push	{r7}
    3938:	b083      	sub	sp, #12
    393a:	af00      	add	r7, sp, #0
    393c:	6078      	str	r0, [r7, #4]
	((Sercom *)hw)->USART.INTENCLR.reg = SERCOM_USART_INTENSET_TXC;
    393e:	687b      	ldr	r3, [r7, #4]
    3940:	2202      	movs	r2, #2
    3942:	751a      	strb	r2, [r3, #20]
}
    3944:	bf00      	nop
    3946:	370c      	adds	r7, #12
    3948:	46bd      	mov	sp, r7
    394a:	f85d 7b04 	ldr.w	r7, [sp], #4
    394e:	4770      	bx	lr

00003950 <hri_sercomi2cm_set_CTRLA_ENABLE_bit>:
	tmp = (tmp & SERCOM_I2CM_CTRLA_SWRST) >> SERCOM_I2CM_CTRLA_SWRST_Pos;
	return (bool)tmp;
}

static inline void hri_sercomi2cm_set_CTRLA_ENABLE_bit(const void *const hw)
{
    3950:	b580      	push	{r7, lr}
    3952:	b082      	sub	sp, #8
    3954:	af00      	add	r7, sp, #0
    3956:	6078      	str	r0, [r7, #4]
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->I2CM.CTRLA.reg |= SERCOM_I2CM_CTRLA_ENABLE;
    3958:	687b      	ldr	r3, [r7, #4]
    395a:	681b      	ldr	r3, [r3, #0]
    395c:	f043 0202 	orr.w	r2, r3, #2
    3960:	687b      	ldr	r3, [r7, #4]
    3962:	601a      	str	r2, [r3, #0]
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SWRST | SERCOM_I2CM_SYNCBUSY_ENABLE);
    3964:	2103      	movs	r1, #3
    3966:	6878      	ldr	r0, [r7, #4]
    3968:	4b02      	ldr	r3, [pc, #8]	; (3974 <hri_sercomi2cm_set_CTRLA_ENABLE_bit+0x24>)
    396a:	4798      	blx	r3
	SERCOM_CRITICAL_SECTION_LEAVE();
}
    396c:	bf00      	nop
    396e:	3708      	adds	r7, #8
    3970:	46bd      	mov	sp, r7
    3972:	bd80      	pop	{r7, pc}
    3974:	000036f1 	.word	0x000036f1

00003978 <hri_sercomi2cm_clear_CTRLA_ENABLE_bit>:
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SWRST | SERCOM_I2CM_SYNCBUSY_ENABLE);
	SERCOM_CRITICAL_SECTION_LEAVE();
}

static inline void hri_sercomi2cm_clear_CTRLA_ENABLE_bit(const void *const hw)
{
    3978:	b580      	push	{r7, lr}
    397a:	b082      	sub	sp, #8
    397c:	af00      	add	r7, sp, #0
    397e:	6078      	str	r0, [r7, #4]
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->I2CM.CTRLA.reg &= ~SERCOM_I2CM_CTRLA_ENABLE;
    3980:	687b      	ldr	r3, [r7, #4]
    3982:	681b      	ldr	r3, [r3, #0]
    3984:	f023 0202 	bic.w	r2, r3, #2
    3988:	687b      	ldr	r3, [r7, #4]
    398a:	601a      	str	r2, [r3, #0]
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SWRST | SERCOM_I2CM_SYNCBUSY_ENABLE);
    398c:	2103      	movs	r1, #3
    398e:	6878      	ldr	r0, [r7, #4]
    3990:	4b02      	ldr	r3, [pc, #8]	; (399c <hri_sercomi2cm_clear_CTRLA_ENABLE_bit+0x24>)
    3992:	4798      	blx	r3
	SERCOM_CRITICAL_SECTION_LEAVE();
}
    3994:	bf00      	nop
    3996:	3708      	adds	r7, #8
    3998:	46bd      	mov	sp, r7
    399a:	bd80      	pop	{r7, pc}
    399c:	000036f1 	.word	0x000036f1

000039a0 <hri_sercomi2cm_get_CTRLA_SCLSM_bit>:
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_MASK);
	SERCOM_CRITICAL_SECTION_LEAVE();
}

static inline bool hri_sercomi2cm_get_CTRLA_SCLSM_bit(const void *const hw)
{
    39a0:	b480      	push	{r7}
    39a2:	b085      	sub	sp, #20
    39a4:	af00      	add	r7, sp, #0
    39a6:	6078      	str	r0, [r7, #4]
	uint32_t tmp;
	tmp = ((Sercom *)hw)->I2CM.CTRLA.reg;
    39a8:	687b      	ldr	r3, [r7, #4]
    39aa:	681b      	ldr	r3, [r3, #0]
    39ac:	60fb      	str	r3, [r7, #12]
	tmp = (tmp & SERCOM_I2CM_CTRLA_SCLSM) >> SERCOM_I2CM_CTRLA_SCLSM_Pos;
    39ae:	68fb      	ldr	r3, [r7, #12]
    39b0:	0edb      	lsrs	r3, r3, #27
    39b2:	f003 0301 	and.w	r3, r3, #1
    39b6:	60fb      	str	r3, [r7, #12]
	return (bool)tmp;
    39b8:	68fb      	ldr	r3, [r7, #12]
    39ba:	2b00      	cmp	r3, #0
    39bc:	bf14      	ite	ne
    39be:	2301      	movne	r3, #1
    39c0:	2300      	moveq	r3, #0
    39c2:	b2db      	uxtb	r3, r3
}
    39c4:	4618      	mov	r0, r3
    39c6:	3714      	adds	r7, #20
    39c8:	46bd      	mov	sp, r7
    39ca:	f85d 7b04 	ldr.w	r7, [sp], #4
    39ce:	4770      	bx	lr

000039d0 <hri_sercomi2cm_get_CTRLA_reg>:
	SERCOM_CRITICAL_SECTION_LEAVE();
}

static inline hri_sercomi2cm_ctrla_reg_t hri_sercomi2cm_get_CTRLA_reg(const void *const          hw,
                                                                      hri_sercomi2cm_ctrla_reg_t mask)
{
    39d0:	b580      	push	{r7, lr}
    39d2:	b084      	sub	sp, #16
    39d4:	af00      	add	r7, sp, #0
    39d6:	6078      	str	r0, [r7, #4]
    39d8:	6039      	str	r1, [r7, #0]
	uint32_t tmp;
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SWRST | SERCOM_I2CM_SYNCBUSY_ENABLE);
    39da:	2103      	movs	r1, #3
    39dc:	6878      	ldr	r0, [r7, #4]
    39de:	4b07      	ldr	r3, [pc, #28]	; (39fc <hri_sercomi2cm_get_CTRLA_reg+0x2c>)
    39e0:	4798      	blx	r3
	tmp = ((Sercom *)hw)->I2CM.CTRLA.reg;
    39e2:	687b      	ldr	r3, [r7, #4]
    39e4:	681b      	ldr	r3, [r3, #0]
    39e6:	60fb      	str	r3, [r7, #12]
	tmp &= mask;
    39e8:	68fa      	ldr	r2, [r7, #12]
    39ea:	683b      	ldr	r3, [r7, #0]
    39ec:	4013      	ands	r3, r2
    39ee:	60fb      	str	r3, [r7, #12]
	return tmp;
    39f0:	68fb      	ldr	r3, [r7, #12]
}
    39f2:	4618      	mov	r0, r3
    39f4:	3710      	adds	r7, #16
    39f6:	46bd      	mov	sp, r7
    39f8:	bd80      	pop	{r7, pc}
    39fa:	bf00      	nop
    39fc:	000036f1 	.word	0x000036f1

00003a00 <hri_sercomi2cm_write_CTRLA_reg>:

static inline void hri_sercomi2cm_write_CTRLA_reg(const void *const hw, hri_sercomi2cm_ctrla_reg_t data)
{
    3a00:	b580      	push	{r7, lr}
    3a02:	b082      	sub	sp, #8
    3a04:	af00      	add	r7, sp, #0
    3a06:	6078      	str	r0, [r7, #4]
    3a08:	6039      	str	r1, [r7, #0]
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->I2CM.CTRLA.reg = data;
    3a0a:	687b      	ldr	r3, [r7, #4]
    3a0c:	683a      	ldr	r2, [r7, #0]
    3a0e:	601a      	str	r2, [r3, #0]
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SWRST | SERCOM_I2CM_SYNCBUSY_ENABLE);
    3a10:	2103      	movs	r1, #3
    3a12:	6878      	ldr	r0, [r7, #4]
    3a14:	4b02      	ldr	r3, [pc, #8]	; (3a20 <hri_sercomi2cm_write_CTRLA_reg+0x20>)
    3a16:	4798      	blx	r3
	SERCOM_CRITICAL_SECTION_LEAVE();
}
    3a18:	bf00      	nop
    3a1a:	3708      	adds	r7, #8
    3a1c:	46bd      	mov	sp, r7
    3a1e:	bd80      	pop	{r7, pc}
    3a20:	000036f1 	.word	0x000036f1

00003a24 <hri_sercomusart_set_CTRLA_ENABLE_bit>:
	tmp = (tmp & SERCOM_USART_CTRLA_SWRST) >> SERCOM_USART_CTRLA_SWRST_Pos;
	return (bool)tmp;
}

static inline void hri_sercomusart_set_CTRLA_ENABLE_bit(const void *const hw)
{
    3a24:	b580      	push	{r7, lr}
    3a26:	b082      	sub	sp, #8
    3a28:	af00      	add	r7, sp, #0
    3a2a:	6078      	str	r0, [r7, #4]
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->USART.CTRLA.reg |= SERCOM_USART_CTRLA_ENABLE;
    3a2c:	687b      	ldr	r3, [r7, #4]
    3a2e:	681b      	ldr	r3, [r3, #0]
    3a30:	f043 0202 	orr.w	r2, r3, #2
    3a34:	687b      	ldr	r3, [r7, #4]
    3a36:	601a      	str	r2, [r3, #0]
	hri_sercomusart_wait_for_sync(hw, SERCOM_USART_SYNCBUSY_SWRST | SERCOM_USART_SYNCBUSY_ENABLE);
    3a38:	2103      	movs	r1, #3
    3a3a:	6878      	ldr	r0, [r7, #4]
    3a3c:	4b02      	ldr	r3, [pc, #8]	; (3a48 <hri_sercomusart_set_CTRLA_ENABLE_bit+0x24>)
    3a3e:	4798      	blx	r3
	SERCOM_CRITICAL_SECTION_LEAVE();
}
    3a40:	bf00      	nop
    3a42:	3708      	adds	r7, #8
    3a44:	46bd      	mov	sp, r7
    3a46:	bd80      	pop	{r7, pc}
    3a48:	0000373d 	.word	0x0000373d

00003a4c <hri_sercomusart_clear_CTRLA_ENABLE_bit>:
	hri_sercomusart_wait_for_sync(hw, SERCOM_USART_SYNCBUSY_SWRST | SERCOM_USART_SYNCBUSY_ENABLE);
	SERCOM_CRITICAL_SECTION_LEAVE();
}

static inline void hri_sercomusart_clear_CTRLA_ENABLE_bit(const void *const hw)
{
    3a4c:	b580      	push	{r7, lr}
    3a4e:	b082      	sub	sp, #8
    3a50:	af00      	add	r7, sp, #0
    3a52:	6078      	str	r0, [r7, #4]
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->USART.CTRLA.reg &= ~SERCOM_USART_CTRLA_ENABLE;
    3a54:	687b      	ldr	r3, [r7, #4]
    3a56:	681b      	ldr	r3, [r3, #0]
    3a58:	f023 0202 	bic.w	r2, r3, #2
    3a5c:	687b      	ldr	r3, [r7, #4]
    3a5e:	601a      	str	r2, [r3, #0]
	hri_sercomusart_wait_for_sync(hw, SERCOM_USART_SYNCBUSY_SWRST | SERCOM_USART_SYNCBUSY_ENABLE);
    3a60:	2103      	movs	r1, #3
    3a62:	6878      	ldr	r0, [r7, #4]
    3a64:	4b02      	ldr	r3, [pc, #8]	; (3a70 <hri_sercomusart_clear_CTRLA_ENABLE_bit+0x24>)
    3a66:	4798      	blx	r3
	SERCOM_CRITICAL_SECTION_LEAVE();
}
    3a68:	bf00      	nop
    3a6a:	3708      	adds	r7, #8
    3a6c:	46bd      	mov	sp, r7
    3a6e:	bd80      	pop	{r7, pc}
    3a70:	0000373d 	.word	0x0000373d

00003a74 <hri_sercomusart_get_CTRLA_reg>:
	SERCOM_CRITICAL_SECTION_LEAVE();
}

static inline hri_sercomusart_ctrla_reg_t hri_sercomusart_get_CTRLA_reg(const void *const           hw,
                                                                        hri_sercomusart_ctrla_reg_t mask)
{
    3a74:	b580      	push	{r7, lr}
    3a76:	b084      	sub	sp, #16
    3a78:	af00      	add	r7, sp, #0
    3a7a:	6078      	str	r0, [r7, #4]
    3a7c:	6039      	str	r1, [r7, #0]
	uint32_t tmp;
	hri_sercomusart_wait_for_sync(hw, SERCOM_USART_SYNCBUSY_SWRST | SERCOM_USART_SYNCBUSY_ENABLE);
    3a7e:	2103      	movs	r1, #3
    3a80:	6878      	ldr	r0, [r7, #4]
    3a82:	4b07      	ldr	r3, [pc, #28]	; (3aa0 <hri_sercomusart_get_CTRLA_reg+0x2c>)
    3a84:	4798      	blx	r3
	tmp = ((Sercom *)hw)->USART.CTRLA.reg;
    3a86:	687b      	ldr	r3, [r7, #4]
    3a88:	681b      	ldr	r3, [r3, #0]
    3a8a:	60fb      	str	r3, [r7, #12]
	tmp &= mask;
    3a8c:	68fa      	ldr	r2, [r7, #12]
    3a8e:	683b      	ldr	r3, [r7, #0]
    3a90:	4013      	ands	r3, r2
    3a92:	60fb      	str	r3, [r7, #12]
	return tmp;
    3a94:	68fb      	ldr	r3, [r7, #12]
}
    3a96:	4618      	mov	r0, r3
    3a98:	3710      	adds	r7, #16
    3a9a:	46bd      	mov	sp, r7
    3a9c:	bd80      	pop	{r7, pc}
    3a9e:	bf00      	nop
    3aa0:	0000373d 	.word	0x0000373d

00003aa4 <hri_sercomusart_write_CTRLA_reg>:

static inline void hri_sercomusart_write_CTRLA_reg(const void *const hw, hri_sercomusart_ctrla_reg_t data)
{
    3aa4:	b580      	push	{r7, lr}
    3aa6:	b082      	sub	sp, #8
    3aa8:	af00      	add	r7, sp, #0
    3aaa:	6078      	str	r0, [r7, #4]
    3aac:	6039      	str	r1, [r7, #0]
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->USART.CTRLA.reg = data;
    3aae:	687b      	ldr	r3, [r7, #4]
    3ab0:	683a      	ldr	r2, [r7, #0]
    3ab2:	601a      	str	r2, [r3, #0]
	hri_sercomusart_wait_for_sync(hw, SERCOM_USART_SYNCBUSY_SWRST | SERCOM_USART_SYNCBUSY_ENABLE);
    3ab4:	2103      	movs	r1, #3
    3ab6:	6878      	ldr	r0, [r7, #4]
    3ab8:	4b02      	ldr	r3, [pc, #8]	; (3ac4 <hri_sercomusart_write_CTRLA_reg+0x20>)
    3aba:	4798      	blx	r3
	SERCOM_CRITICAL_SECTION_LEAVE();
}
    3abc:	bf00      	nop
    3abe:	3708      	adds	r7, #8
    3ac0:	46bd      	mov	sp, r7
    3ac2:	bd80      	pop	{r7, pc}
    3ac4:	0000373d 	.word	0x0000373d

00003ac8 <hri_sercomi2cm_set_CTRLB_SMEN_bit>:
	hri_sercomusart_wait_for_sync(hw, SERCOM_USART_SYNCBUSY_SWRST | SERCOM_USART_SYNCBUSY_ENABLE);
	return ((Sercom *)hw)->USART.CTRLA.reg;
}

static inline void hri_sercomi2cm_set_CTRLB_SMEN_bit(const void *const hw)
{
    3ac8:	b580      	push	{r7, lr}
    3aca:	b082      	sub	sp, #8
    3acc:	af00      	add	r7, sp, #0
    3ace:	6078      	str	r0, [r7, #4]
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->I2CM.CTRLB.reg |= SERCOM_I2CM_CTRLB_SMEN;
    3ad0:	687b      	ldr	r3, [r7, #4]
    3ad2:	685b      	ldr	r3, [r3, #4]
    3ad4:	f443 7280 	orr.w	r2, r3, #256	; 0x100
    3ad8:	687b      	ldr	r3, [r7, #4]
    3ada:	605a      	str	r2, [r3, #4]
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
    3adc:	2104      	movs	r1, #4
    3ade:	6878      	ldr	r0, [r7, #4]
    3ae0:	4b02      	ldr	r3, [pc, #8]	; (3aec <hri_sercomi2cm_set_CTRLB_SMEN_bit+0x24>)
    3ae2:	4798      	blx	r3
	SERCOM_CRITICAL_SECTION_LEAVE();
}
    3ae4:	bf00      	nop
    3ae6:	3708      	adds	r7, #8
    3ae8:	46bd      	mov	sp, r7
    3aea:	bd80      	pop	{r7, pc}
    3aec:	000036f1 	.word	0x000036f1

00003af0 <hri_sercomi2cm_clear_CTRLB_SMEN_bit>:
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
	SERCOM_CRITICAL_SECTION_LEAVE();
}

static inline void hri_sercomi2cm_clear_CTRLB_SMEN_bit(const void *const hw)
{
    3af0:	b580      	push	{r7, lr}
    3af2:	b082      	sub	sp, #8
    3af4:	af00      	add	r7, sp, #0
    3af6:	6078      	str	r0, [r7, #4]
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->I2CM.CTRLB.reg &= ~SERCOM_I2CM_CTRLB_SMEN;
    3af8:	687b      	ldr	r3, [r7, #4]
    3afa:	685b      	ldr	r3, [r3, #4]
    3afc:	f423 7280 	bic.w	r2, r3, #256	; 0x100
    3b00:	687b      	ldr	r3, [r7, #4]
    3b02:	605a      	str	r2, [r3, #4]
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
    3b04:	2104      	movs	r1, #4
    3b06:	6878      	ldr	r0, [r7, #4]
    3b08:	4b02      	ldr	r3, [pc, #8]	; (3b14 <hri_sercomi2cm_clear_CTRLB_SMEN_bit+0x24>)
    3b0a:	4798      	blx	r3
	SERCOM_CRITICAL_SECTION_LEAVE();
}
    3b0c:	bf00      	nop
    3b0e:	3708      	adds	r7, #8
    3b10:	46bd      	mov	sp, r7
    3b12:	bd80      	pop	{r7, pc}
    3b14:	000036f1 	.word	0x000036f1

00003b18 <hri_sercomi2cm_set_CTRLB_ACKACT_bit>:
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
	SERCOM_CRITICAL_SECTION_LEAVE();
}

static inline void hri_sercomi2cm_set_CTRLB_ACKACT_bit(const void *const hw)
{
    3b18:	b580      	push	{r7, lr}
    3b1a:	b082      	sub	sp, #8
    3b1c:	af00      	add	r7, sp, #0
    3b1e:	6078      	str	r0, [r7, #4]
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->I2CM.CTRLB.reg |= SERCOM_I2CM_CTRLB_ACKACT;
    3b20:	687b      	ldr	r3, [r7, #4]
    3b22:	685b      	ldr	r3, [r3, #4]
    3b24:	f443 2280 	orr.w	r2, r3, #262144	; 0x40000
    3b28:	687b      	ldr	r3, [r7, #4]
    3b2a:	605a      	str	r2, [r3, #4]
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
    3b2c:	2104      	movs	r1, #4
    3b2e:	6878      	ldr	r0, [r7, #4]
    3b30:	4b02      	ldr	r3, [pc, #8]	; (3b3c <hri_sercomi2cm_set_CTRLB_ACKACT_bit+0x24>)
    3b32:	4798      	blx	r3
	SERCOM_CRITICAL_SECTION_LEAVE();
}
    3b34:	bf00      	nop
    3b36:	3708      	adds	r7, #8
    3b38:	46bd      	mov	sp, r7
    3b3a:	bd80      	pop	{r7, pc}
    3b3c:	000036f1 	.word	0x000036f1

00003b40 <hri_sercomi2cm_clear_CTRLB_ACKACT_bit>:
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
	SERCOM_CRITICAL_SECTION_LEAVE();
}

static inline void hri_sercomi2cm_clear_CTRLB_ACKACT_bit(const void *const hw)
{
    3b40:	b580      	push	{r7, lr}
    3b42:	b082      	sub	sp, #8
    3b44:	af00      	add	r7, sp, #0
    3b46:	6078      	str	r0, [r7, #4]
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->I2CM.CTRLB.reg &= ~SERCOM_I2CM_CTRLB_ACKACT;
    3b48:	687b      	ldr	r3, [r7, #4]
    3b4a:	685b      	ldr	r3, [r3, #4]
    3b4c:	f423 2280 	bic.w	r2, r3, #262144	; 0x40000
    3b50:	687b      	ldr	r3, [r7, #4]
    3b52:	605a      	str	r2, [r3, #4]
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
    3b54:	2104      	movs	r1, #4
    3b56:	6878      	ldr	r0, [r7, #4]
    3b58:	4b02      	ldr	r3, [pc, #8]	; (3b64 <hri_sercomi2cm_clear_CTRLB_ACKACT_bit+0x24>)
    3b5a:	4798      	blx	r3
	SERCOM_CRITICAL_SECTION_LEAVE();
}
    3b5c:	bf00      	nop
    3b5e:	3708      	adds	r7, #8
    3b60:	46bd      	mov	sp, r7
    3b62:	bd80      	pop	{r7, pc}
    3b64:	000036f1 	.word	0x000036f1

00003b68 <hri_sercomi2cm_set_CTRLB_CMD_bf>:
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
	SERCOM_CRITICAL_SECTION_LEAVE();
}

static inline void hri_sercomi2cm_set_CTRLB_CMD_bf(const void *const hw, hri_sercomi2cm_ctrlb_reg_t mask)
{
    3b68:	b580      	push	{r7, lr}
    3b6a:	b082      	sub	sp, #8
    3b6c:	af00      	add	r7, sp, #0
    3b6e:	6078      	str	r0, [r7, #4]
    3b70:	6039      	str	r1, [r7, #0]
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->I2CM.CTRLB.reg |= SERCOM_I2CM_CTRLB_CMD(mask);
    3b72:	687b      	ldr	r3, [r7, #4]
    3b74:	685a      	ldr	r2, [r3, #4]
    3b76:	683b      	ldr	r3, [r7, #0]
    3b78:	041b      	lsls	r3, r3, #16
    3b7a:	f403 3340 	and.w	r3, r3, #196608	; 0x30000
    3b7e:	431a      	orrs	r2, r3
    3b80:	687b      	ldr	r3, [r7, #4]
    3b82:	605a      	str	r2, [r3, #4]
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
    3b84:	2104      	movs	r1, #4
    3b86:	6878      	ldr	r0, [r7, #4]
    3b88:	4b02      	ldr	r3, [pc, #8]	; (3b94 <hri_sercomi2cm_set_CTRLB_CMD_bf+0x2c>)
    3b8a:	4798      	blx	r3
	SERCOM_CRITICAL_SECTION_LEAVE();
}
    3b8c:	bf00      	nop
    3b8e:	3708      	adds	r7, #8
    3b90:	46bd      	mov	sp, r7
    3b92:	bd80      	pop	{r7, pc}
    3b94:	000036f1 	.word	0x000036f1

00003b98 <hri_sercomi2cm_write_CTRLB_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_sercomi2cm_write_CTRLB_reg(const void *const hw, hri_sercomi2cm_ctrlb_reg_t data)
{
    3b98:	b580      	push	{r7, lr}
    3b9a:	b082      	sub	sp, #8
    3b9c:	af00      	add	r7, sp, #0
    3b9e:	6078      	str	r0, [r7, #4]
    3ba0:	6039      	str	r1, [r7, #0]
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->I2CM.CTRLB.reg = data;
    3ba2:	687b      	ldr	r3, [r7, #4]
    3ba4:	683a      	ldr	r2, [r7, #0]
    3ba6:	605a      	str	r2, [r3, #4]
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
    3ba8:	2104      	movs	r1, #4
    3baa:	6878      	ldr	r0, [r7, #4]
    3bac:	4b02      	ldr	r3, [pc, #8]	; (3bb8 <hri_sercomi2cm_write_CTRLB_reg+0x20>)
    3bae:	4798      	blx	r3
	SERCOM_CRITICAL_SECTION_LEAVE();
}
    3bb0:	bf00      	nop
    3bb2:	3708      	adds	r7, #8
    3bb4:	46bd      	mov	sp, r7
    3bb6:	bd80      	pop	{r7, pc}
    3bb8:	000036f1 	.word	0x000036f1

00003bbc <hri_sercomusart_write_CTRLB_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_sercomusart_write_CTRLB_reg(const void *const hw, hri_sercomusart_ctrlb_reg_t data)
{
    3bbc:	b580      	push	{r7, lr}
    3bbe:	b082      	sub	sp, #8
    3bc0:	af00      	add	r7, sp, #0
    3bc2:	6078      	str	r0, [r7, #4]
    3bc4:	6039      	str	r1, [r7, #0]
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->USART.CTRLB.reg = data;
    3bc6:	687b      	ldr	r3, [r7, #4]
    3bc8:	683a      	ldr	r2, [r7, #0]
    3bca:	605a      	str	r2, [r3, #4]
	hri_sercomusart_wait_for_sync(hw, SERCOM_USART_SYNCBUSY_MASK);
    3bcc:	211f      	movs	r1, #31
    3bce:	6878      	ldr	r0, [r7, #4]
    3bd0:	4b02      	ldr	r3, [pc, #8]	; (3bdc <hri_sercomusart_write_CTRLB_reg+0x20>)
    3bd2:	4798      	blx	r3
	SERCOM_CRITICAL_SECTION_LEAVE();
}
    3bd4:	bf00      	nop
    3bd6:	3708      	adds	r7, #8
    3bd8:	46bd      	mov	sp, r7
    3bda:	bd80      	pop	{r7, pc}
    3bdc:	0000373d 	.word	0x0000373d

00003be0 <hri_sercomusart_write_CTRLC_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_sercomusart_write_CTRLC_reg(const void *const hw, hri_sercomusart_ctrlc_reg_t data)
{
    3be0:	b480      	push	{r7}
    3be2:	b083      	sub	sp, #12
    3be4:	af00      	add	r7, sp, #0
    3be6:	6078      	str	r0, [r7, #4]
    3be8:	6039      	str	r1, [r7, #0]
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->USART.CTRLC.reg = data;
    3bea:	687b      	ldr	r3, [r7, #4]
    3bec:	683a      	ldr	r2, [r7, #0]
    3bee:	609a      	str	r2, [r3, #8]
	SERCOM_CRITICAL_SECTION_LEAVE();
}
    3bf0:	bf00      	nop
    3bf2:	370c      	adds	r7, #12
    3bf4:	46bd      	mov	sp, r7
    3bf6:	f85d 7b04 	ldr.w	r7, [sp], #4
    3bfa:	4770      	bx	lr

00003bfc <hri_sercomi2cm_write_BAUD_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_sercomi2cm_write_BAUD_reg(const void *const hw, hri_sercomi2cm_baud_reg_t data)
{
    3bfc:	b480      	push	{r7}
    3bfe:	b083      	sub	sp, #12
    3c00:	af00      	add	r7, sp, #0
    3c02:	6078      	str	r0, [r7, #4]
    3c04:	6039      	str	r1, [r7, #0]
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->I2CM.BAUD.reg = data;
    3c06:	687b      	ldr	r3, [r7, #4]
    3c08:	683a      	ldr	r2, [r7, #0]
    3c0a:	60da      	str	r2, [r3, #12]
	SERCOM_CRITICAL_SECTION_LEAVE();
}
    3c0c:	bf00      	nop
    3c0e:	370c      	adds	r7, #12
    3c10:	46bd      	mov	sp, r7
    3c12:	f85d 7b04 	ldr.w	r7, [sp], #4
    3c16:	4770      	bx	lr

00003c18 <hri_sercomusart_write_BAUD_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_sercomusart_write_BAUD_reg(const void *const hw, hri_sercomusart_baud_reg_t data)
{
    3c18:	b480      	push	{r7}
    3c1a:	b083      	sub	sp, #12
    3c1c:	af00      	add	r7, sp, #0
    3c1e:	6078      	str	r0, [r7, #4]
    3c20:	460b      	mov	r3, r1
    3c22:	807b      	strh	r3, [r7, #2]
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->USART.BAUD.reg = data;
    3c24:	687b      	ldr	r3, [r7, #4]
    3c26:	887a      	ldrh	r2, [r7, #2]
    3c28:	819a      	strh	r2, [r3, #12]
	SERCOM_CRITICAL_SECTION_LEAVE();
}
    3c2a:	bf00      	nop
    3c2c:	370c      	adds	r7, #12
    3c2e:	46bd      	mov	sp, r7
    3c30:	f85d 7b04 	ldr.w	r7, [sp], #4
    3c34:	4770      	bx	lr

00003c36 <hri_sercomusart_write_RXPL_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_sercomusart_write_RXPL_reg(const void *const hw, hri_sercomusart_rxpl_reg_t data)
{
    3c36:	b480      	push	{r7}
    3c38:	b083      	sub	sp, #12
    3c3a:	af00      	add	r7, sp, #0
    3c3c:	6078      	str	r0, [r7, #4]
    3c3e:	460b      	mov	r3, r1
    3c40:	70fb      	strb	r3, [r7, #3]
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->USART.RXPL.reg = data;
    3c42:	687b      	ldr	r3, [r7, #4]
    3c44:	78fa      	ldrb	r2, [r7, #3]
    3c46:	739a      	strb	r2, [r3, #14]
	SERCOM_CRITICAL_SECTION_LEAVE();
}
    3c48:	bf00      	nop
    3c4a:	370c      	adds	r7, #12
    3c4c:	46bd      	mov	sp, r7
    3c4e:	f85d 7b04 	ldr.w	r7, [sp], #4
    3c52:	4770      	bx	lr

00003c54 <hri_sercomi2cm_write_ADDR_HS_bit>:
	tmp = (tmp & SERCOM_I2CM_ADDR_HS) >> SERCOM_I2CM_ADDR_HS_Pos;
	return (bool)tmp;
}

static inline void hri_sercomi2cm_write_ADDR_HS_bit(const void *const hw, bool value)
{
    3c54:	b580      	push	{r7, lr}
    3c56:	b084      	sub	sp, #16
    3c58:	af00      	add	r7, sp, #0
    3c5a:	6078      	str	r0, [r7, #4]
    3c5c:	460b      	mov	r3, r1
    3c5e:	70fb      	strb	r3, [r7, #3]
	uint32_t tmp;
	SERCOM_CRITICAL_SECTION_ENTER();
	tmp = ((Sercom *)hw)->I2CM.ADDR.reg;
    3c60:	687b      	ldr	r3, [r7, #4]
    3c62:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    3c64:	60fb      	str	r3, [r7, #12]
	tmp &= ~SERCOM_I2CM_ADDR_HS;
    3c66:	68fb      	ldr	r3, [r7, #12]
    3c68:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
    3c6c:	60fb      	str	r3, [r7, #12]
	tmp |= value << SERCOM_I2CM_ADDR_HS_Pos;
    3c6e:	78fb      	ldrb	r3, [r7, #3]
    3c70:	039b      	lsls	r3, r3, #14
    3c72:	461a      	mov	r2, r3
    3c74:	68fb      	ldr	r3, [r7, #12]
    3c76:	4313      	orrs	r3, r2
    3c78:	60fb      	str	r3, [r7, #12]
	((Sercom *)hw)->I2CM.ADDR.reg = tmp;
    3c7a:	687b      	ldr	r3, [r7, #4]
    3c7c:	68fa      	ldr	r2, [r7, #12]
    3c7e:	625a      	str	r2, [r3, #36]	; 0x24
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
    3c80:	2104      	movs	r1, #4
    3c82:	6878      	ldr	r0, [r7, #4]
    3c84:	4b02      	ldr	r3, [pc, #8]	; (3c90 <hri_sercomi2cm_write_ADDR_HS_bit+0x3c>)
    3c86:	4798      	blx	r3
	SERCOM_CRITICAL_SECTION_LEAVE();
}
    3c88:	bf00      	nop
    3c8a:	3710      	adds	r7, #16
    3c8c:	46bd      	mov	sp, r7
    3c8e:	bd80      	pop	{r7, pc}
    3c90:	000036f1 	.word	0x000036f1

00003c94 <hri_sercomi2cm_write_ADDR_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_sercomi2cm_write_ADDR_reg(const void *const hw, hri_sercomi2cm_addr_reg_t data)
{
    3c94:	b580      	push	{r7, lr}
    3c96:	b082      	sub	sp, #8
    3c98:	af00      	add	r7, sp, #0
    3c9a:	6078      	str	r0, [r7, #4]
    3c9c:	6039      	str	r1, [r7, #0]
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->I2CM.ADDR.reg = data;
    3c9e:	687b      	ldr	r3, [r7, #4]
    3ca0:	683a      	ldr	r2, [r7, #0]
    3ca2:	625a      	str	r2, [r3, #36]	; 0x24
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
    3ca4:	2104      	movs	r1, #4
    3ca6:	6878      	ldr	r0, [r7, #4]
    3ca8:	4b02      	ldr	r3, [pc, #8]	; (3cb4 <hri_sercomi2cm_write_ADDR_reg+0x20>)
    3caa:	4798      	blx	r3
	SERCOM_CRITICAL_SECTION_LEAVE();
}
    3cac:	bf00      	nop
    3cae:	3708      	adds	r7, #8
    3cb0:	46bd      	mov	sp, r7
    3cb2:	bd80      	pop	{r7, pc}
    3cb4:	000036f1 	.word	0x000036f1

00003cb8 <hri_sercomi2cm_read_ADDR_reg>:
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
	SERCOM_CRITICAL_SECTION_LEAVE();
}

static inline hri_sercomi2cm_addr_reg_t hri_sercomi2cm_read_ADDR_reg(const void *const hw)
{
    3cb8:	b580      	push	{r7, lr}
    3cba:	b082      	sub	sp, #8
    3cbc:	af00      	add	r7, sp, #0
    3cbe:	6078      	str	r0, [r7, #4]
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
    3cc0:	2104      	movs	r1, #4
    3cc2:	6878      	ldr	r0, [r7, #4]
    3cc4:	4b03      	ldr	r3, [pc, #12]	; (3cd4 <hri_sercomi2cm_read_ADDR_reg+0x1c>)
    3cc6:	4798      	blx	r3
	return ((Sercom *)hw)->I2CM.ADDR.reg;
    3cc8:	687b      	ldr	r3, [r7, #4]
    3cca:	6a5b      	ldr	r3, [r3, #36]	; 0x24
}
    3ccc:	4618      	mov	r0, r3
    3cce:	3708      	adds	r7, #8
    3cd0:	46bd      	mov	sp, r7
    3cd2:	bd80      	pop	{r7, pc}
    3cd4:	000036f1 	.word	0x000036f1

00003cd8 <hri_sercomi2cm_write_DATA_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_sercomi2cm_write_DATA_reg(const void *const hw, hri_sercomi2cm_data_reg_t data)
{
    3cd8:	b580      	push	{r7, lr}
    3cda:	b082      	sub	sp, #8
    3cdc:	af00      	add	r7, sp, #0
    3cde:	6078      	str	r0, [r7, #4]
    3ce0:	6039      	str	r1, [r7, #0]
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->I2CM.DATA.reg = data;
    3ce2:	687b      	ldr	r3, [r7, #4]
    3ce4:	683a      	ldr	r2, [r7, #0]
    3ce6:	629a      	str	r2, [r3, #40]	; 0x28
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
    3ce8:	2104      	movs	r1, #4
    3cea:	6878      	ldr	r0, [r7, #4]
    3cec:	4b02      	ldr	r3, [pc, #8]	; (3cf8 <hri_sercomi2cm_write_DATA_reg+0x20>)
    3cee:	4798      	blx	r3
	SERCOM_CRITICAL_SECTION_LEAVE();
}
    3cf0:	bf00      	nop
    3cf2:	3708      	adds	r7, #8
    3cf4:	46bd      	mov	sp, r7
    3cf6:	bd80      	pop	{r7, pc}
    3cf8:	000036f1 	.word	0x000036f1

00003cfc <hri_sercomi2cm_read_DATA_reg>:
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
	SERCOM_CRITICAL_SECTION_LEAVE();
}

static inline hri_sercomi2cm_data_reg_t hri_sercomi2cm_read_DATA_reg(const void *const hw)
{
    3cfc:	b580      	push	{r7, lr}
    3cfe:	b082      	sub	sp, #8
    3d00:	af00      	add	r7, sp, #0
    3d02:	6078      	str	r0, [r7, #4]
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
    3d04:	2104      	movs	r1, #4
    3d06:	6878      	ldr	r0, [r7, #4]
    3d08:	4b03      	ldr	r3, [pc, #12]	; (3d18 <hri_sercomi2cm_read_DATA_reg+0x1c>)
    3d0a:	4798      	blx	r3
	return ((Sercom *)hw)->I2CM.DATA.reg;
    3d0c:	687b      	ldr	r3, [r7, #4]
    3d0e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
}
    3d10:	4618      	mov	r0, r3
    3d12:	3708      	adds	r7, #8
    3d14:	46bd      	mov	sp, r7
    3d16:	bd80      	pop	{r7, pc}
    3d18:	000036f1 	.word	0x000036f1

00003d1c <hri_sercomusart_write_DATA_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_sercomusart_write_DATA_reg(const void *const hw, hri_sercomusart_data_reg_t data)
{
    3d1c:	b480      	push	{r7}
    3d1e:	b083      	sub	sp, #12
    3d20:	af00      	add	r7, sp, #0
    3d22:	6078      	str	r0, [r7, #4]
    3d24:	6039      	str	r1, [r7, #0]
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->USART.DATA.reg = data;
    3d26:	687b      	ldr	r3, [r7, #4]
    3d28:	683a      	ldr	r2, [r7, #0]
    3d2a:	629a      	str	r2, [r3, #40]	; 0x28
	SERCOM_CRITICAL_SECTION_LEAVE();
}
    3d2c:	bf00      	nop
    3d2e:	370c      	adds	r7, #12
    3d30:	46bd      	mov	sp, r7
    3d32:	f85d 7b04 	ldr.w	r7, [sp], #4
    3d36:	4770      	bx	lr

00003d38 <hri_sercomusart_read_DATA_reg>:
	((Sercom *)hw)->USART.DATA.reg ^= mask;
	SERCOM_CRITICAL_SECTION_LEAVE();
}

static inline hri_sercomusart_data_reg_t hri_sercomusart_read_DATA_reg(const void *const hw)
{
    3d38:	b480      	push	{r7}
    3d3a:	b083      	sub	sp, #12
    3d3c:	af00      	add	r7, sp, #0
    3d3e:	6078      	str	r0, [r7, #4]
	return ((Sercom *)hw)->USART.DATA.reg;
    3d40:	687b      	ldr	r3, [r7, #4]
    3d42:	6a9b      	ldr	r3, [r3, #40]	; 0x28
}
    3d44:	4618      	mov	r0, r3
    3d46:	370c      	adds	r7, #12
    3d48:	46bd      	mov	sp, r7
    3d4a:	f85d 7b04 	ldr.w	r7, [sp], #4
    3d4e:	4770      	bx	lr

00003d50 <hri_sercomusart_write_DBGCTRL_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_sercomusart_write_DBGCTRL_reg(const void *const hw, hri_sercomusart_dbgctrl_reg_t data)
{
    3d50:	b480      	push	{r7}
    3d52:	b083      	sub	sp, #12
    3d54:	af00      	add	r7, sp, #0
    3d56:	6078      	str	r0, [r7, #4]
    3d58:	460b      	mov	r3, r1
    3d5a:	70fb      	strb	r3, [r7, #3]
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->USART.DBGCTRL.reg = data;
    3d5c:	687b      	ldr	r3, [r7, #4]
    3d5e:	78fa      	ldrb	r2, [r7, #3]
    3d60:	f883 2030 	strb.w	r2, [r3, #48]	; 0x30
	SERCOM_CRITICAL_SECTION_LEAVE();
}
    3d64:	bf00      	nop
    3d66:	370c      	adds	r7, #12
    3d68:	46bd      	mov	sp, r7
    3d6a:	f85d 7b04 	ldr.w	r7, [sp], #4
    3d6e:	4770      	bx	lr

00003d70 <hri_sercomusart_clear_STATUS_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_sercomusart_clear_STATUS_reg(const void *const hw, hri_sercomusart_status_reg_t mask)
{
    3d70:	b480      	push	{r7}
    3d72:	b083      	sub	sp, #12
    3d74:	af00      	add	r7, sp, #0
    3d76:	6078      	str	r0, [r7, #4]
    3d78:	460b      	mov	r3, r1
    3d7a:	807b      	strh	r3, [r7, #2]
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->USART.STATUS.reg = mask;
    3d7c:	687b      	ldr	r3, [r7, #4]
    3d7e:	887a      	ldrh	r2, [r7, #2]
    3d80:	835a      	strh	r2, [r3, #26]
	SERCOM_CRITICAL_SECTION_LEAVE();
}
    3d82:	bf00      	nop
    3d84:	370c      	adds	r7, #12
    3d86:	46bd      	mov	sp, r7
    3d88:	f85d 7b04 	ldr.w	r7, [sp], #4
    3d8c:	4770      	bx	lr

00003d8e <hri_sercomusart_read_STATUS_reg>:

static inline hri_sercomusart_status_reg_t hri_sercomusart_read_STATUS_reg(const void *const hw)
{
    3d8e:	b480      	push	{r7}
    3d90:	b083      	sub	sp, #12
    3d92:	af00      	add	r7, sp, #0
    3d94:	6078      	str	r0, [r7, #4]
	return ((Sercom *)hw)->USART.STATUS.reg;
    3d96:	687b      	ldr	r3, [r7, #4]
    3d98:	8b5b      	ldrh	r3, [r3, #26]
    3d9a:	b29b      	uxth	r3, r3
}
    3d9c:	4618      	mov	r0, r3
    3d9e:	370c      	adds	r7, #12
    3da0:	46bd      	mov	sp, r7
    3da2:	f85d 7b04 	ldr.w	r7, [sp], #4
    3da6:	4770      	bx	lr

00003da8 <hri_sercomi2cm_read_STATUS_BUSSTATE_bf>:
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
	SERCOM_CRITICAL_SECTION_LEAVE();
}

static inline hri_sercomi2cm_status_reg_t hri_sercomi2cm_read_STATUS_BUSSTATE_bf(const void *const hw)
{
    3da8:	b580      	push	{r7, lr}
    3daa:	b082      	sub	sp, #8
    3dac:	af00      	add	r7, sp, #0
    3dae:	6078      	str	r0, [r7, #4]
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
    3db0:	2104      	movs	r1, #4
    3db2:	6878      	ldr	r0, [r7, #4]
    3db4:	4b06      	ldr	r3, [pc, #24]	; (3dd0 <hri_sercomi2cm_read_STATUS_BUSSTATE_bf+0x28>)
    3db6:	4798      	blx	r3
	return (((Sercom *)hw)->I2CM.STATUS.reg & SERCOM_I2CM_STATUS_BUSSTATE_Msk) >> SERCOM_I2CM_STATUS_BUSSTATE_Pos;
    3db8:	687b      	ldr	r3, [r7, #4]
    3dba:	8b5b      	ldrh	r3, [r3, #26]
    3dbc:	b29b      	uxth	r3, r3
    3dbe:	091b      	lsrs	r3, r3, #4
    3dc0:	b29b      	uxth	r3, r3
    3dc2:	f003 0303 	and.w	r3, r3, #3
    3dc6:	b29b      	uxth	r3, r3
}
    3dc8:	4618      	mov	r0, r3
    3dca:	3708      	adds	r7, #8
    3dcc:	46bd      	mov	sp, r7
    3dce:	bd80      	pop	{r7, pc}
    3dd0:	000036f1 	.word	0x000036f1

00003dd4 <hri_sercomi2cm_read_STATUS_reg>:
{
	((Sercom *)hw)->I2CM.STATUS.reg |= mask;
}

static inline hri_sercomi2cm_status_reg_t hri_sercomi2cm_read_STATUS_reg(const void *const hw)
{
    3dd4:	b580      	push	{r7, lr}
    3dd6:	b082      	sub	sp, #8
    3dd8:	af00      	add	r7, sp, #0
    3dda:	6078      	str	r0, [r7, #4]
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
    3ddc:	2104      	movs	r1, #4
    3dde:	6878      	ldr	r0, [r7, #4]
    3de0:	4b04      	ldr	r3, [pc, #16]	; (3df4 <hri_sercomi2cm_read_STATUS_reg+0x20>)
    3de2:	4798      	blx	r3
	return ((Sercom *)hw)->I2CM.STATUS.reg;
    3de4:	687b      	ldr	r3, [r7, #4]
    3de6:	8b5b      	ldrh	r3, [r3, #26]
    3de8:	b29b      	uxth	r3, r3
}
    3dea:	4618      	mov	r0, r3
    3dec:	3708      	adds	r7, #8
    3dee:	46bd      	mov	sp, r7
    3df0:	bd80      	pop	{r7, pc}
    3df2:	bf00      	nop
    3df4:	000036f1 	.word	0x000036f1

00003df8 <hri_sercomi2cm_clear_STATUS_reg>:
{
	((Sercom *)hw)->I2CM.STATUS.reg ^= mask;
}

static inline void hri_sercomi2cm_clear_STATUS_reg(const void *const hw, hri_sercomi2cm_status_reg_t mask)
{
    3df8:	b580      	push	{r7, lr}
    3dfa:	b082      	sub	sp, #8
    3dfc:	af00      	add	r7, sp, #0
    3dfe:	6078      	str	r0, [r7, #4]
    3e00:	460b      	mov	r3, r1
    3e02:	807b      	strh	r3, [r7, #2]
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->I2CM.STATUS.reg = mask;
    3e04:	687b      	ldr	r3, [r7, #4]
    3e06:	887a      	ldrh	r2, [r7, #2]
    3e08:	835a      	strh	r2, [r3, #26]
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
    3e0a:	2104      	movs	r1, #4
    3e0c:	6878      	ldr	r0, [r7, #4]
    3e0e:	4b03      	ldr	r3, [pc, #12]	; (3e1c <hri_sercomi2cm_clear_STATUS_reg+0x24>)
    3e10:	4798      	blx	r3
	SERCOM_CRITICAL_SECTION_LEAVE();
}
    3e12:	bf00      	nop
    3e14:	3708      	adds	r7, #8
    3e16:	46bd      	mov	sp, r7
    3e18:	bd80      	pop	{r7, pc}
    3e1a:	bf00      	nop
    3e1c:	000036f1 	.word	0x000036f1

00003e20 <_usart_async_init>:

/**
 * \brief Initialize asynchronous SERCOM USART
 */
int32_t _usart_async_init(struct _usart_async_device *const device, void *const hw)
{
    3e20:	b580      	push	{r7, lr}
    3e22:	b086      	sub	sp, #24
    3e24:	af00      	add	r7, sp, #0
    3e26:	6078      	str	r0, [r7, #4]
    3e28:	6039      	str	r1, [r7, #0]
	int32_t init_status;

	ASSERT(device);
    3e2a:	687b      	ldr	r3, [r7, #4]
    3e2c:	2b00      	cmp	r3, #0
    3e2e:	bf14      	ite	ne
    3e30:	2301      	movne	r3, #1
    3e32:	2300      	moveq	r3, #0
    3e34:	b2db      	uxtb	r3, r3
    3e36:	22cb      	movs	r2, #203	; 0xcb
    3e38:	491c      	ldr	r1, [pc, #112]	; (3eac <_usart_async_init+0x8c>)
    3e3a:	4618      	mov	r0, r3
    3e3c:	4b1c      	ldr	r3, [pc, #112]	; (3eb0 <_usart_async_init+0x90>)
    3e3e:	4798      	blx	r3

	init_status = _usart_init(hw);
    3e40:	6838      	ldr	r0, [r7, #0]
    3e42:	4b1c      	ldr	r3, [pc, #112]	; (3eb4 <_usart_async_init+0x94>)
    3e44:	4798      	blx	r3
    3e46:	60f8      	str	r0, [r7, #12]
	if (init_status) {
    3e48:	68fb      	ldr	r3, [r7, #12]
    3e4a:	2b00      	cmp	r3, #0
    3e4c:	d001      	beq.n	3e52 <_usart_async_init+0x32>
		return init_status;
    3e4e:	68fb      	ldr	r3, [r7, #12]
    3e50:	e027      	b.n	3ea2 <_usart_async_init+0x82>
	}
	device->hw = hw;
    3e52:	687b      	ldr	r3, [r7, #4]
    3e54:	683a      	ldr	r2, [r7, #0]
    3e56:	619a      	str	r2, [r3, #24]
	_sercom_init_irq_param(hw, (void *)device);
    3e58:	6879      	ldr	r1, [r7, #4]
    3e5a:	6838      	ldr	r0, [r7, #0]
    3e5c:	4b16      	ldr	r3, [pc, #88]	; (3eb8 <_usart_async_init+0x98>)
    3e5e:	4798      	blx	r3
	uint8_t irq = _sercom_get_irq_num(hw);
    3e60:	6838      	ldr	r0, [r7, #0]
    3e62:	4b16      	ldr	r3, [pc, #88]	; (3ebc <_usart_async_init+0x9c>)
    3e64:	4798      	blx	r3
    3e66:	4603      	mov	r3, r0
    3e68:	75fb      	strb	r3, [r7, #23]
	for (uint32_t i = 0; i < 4; i++) {
    3e6a:	2300      	movs	r3, #0
    3e6c:	613b      	str	r3, [r7, #16]
    3e6e:	e014      	b.n	3e9a <_usart_async_init+0x7a>
		NVIC_DisableIRQ((IRQn_Type)irq);
    3e70:	7dfb      	ldrb	r3, [r7, #23]
    3e72:	b21b      	sxth	r3, r3
    3e74:	4618      	mov	r0, r3
    3e76:	4b12      	ldr	r3, [pc, #72]	; (3ec0 <_usart_async_init+0xa0>)
    3e78:	4798      	blx	r3
		NVIC_ClearPendingIRQ((IRQn_Type)irq);
    3e7a:	7dfb      	ldrb	r3, [r7, #23]
    3e7c:	b21b      	sxth	r3, r3
    3e7e:	4618      	mov	r0, r3
    3e80:	4b10      	ldr	r3, [pc, #64]	; (3ec4 <_usart_async_init+0xa4>)
    3e82:	4798      	blx	r3
		NVIC_EnableIRQ((IRQn_Type)irq);
    3e84:	7dfb      	ldrb	r3, [r7, #23]
    3e86:	b21b      	sxth	r3, r3
    3e88:	4618      	mov	r0, r3
    3e8a:	4b0f      	ldr	r3, [pc, #60]	; (3ec8 <_usart_async_init+0xa8>)
    3e8c:	4798      	blx	r3
		irq++;
    3e8e:	7dfb      	ldrb	r3, [r7, #23]
    3e90:	3301      	adds	r3, #1
    3e92:	75fb      	strb	r3, [r7, #23]
	for (uint32_t i = 0; i < 4; i++) {
    3e94:	693b      	ldr	r3, [r7, #16]
    3e96:	3301      	adds	r3, #1
    3e98:	613b      	str	r3, [r7, #16]
    3e9a:	693b      	ldr	r3, [r7, #16]
    3e9c:	2b03      	cmp	r3, #3
    3e9e:	d9e7      	bls.n	3e70 <_usart_async_init+0x50>
	}
	return ERR_NONE;
    3ea0:	2300      	movs	r3, #0
}
    3ea2:	4618      	mov	r0, r3
    3ea4:	3718      	adds	r7, #24
    3ea6:	46bd      	mov	sp, r7
    3ea8:	bd80      	pop	{r7, pc}
    3eaa:	bf00      	nop
    3eac:	00005dd4 	.word	0x00005dd4
    3eb0:	00001849 	.word	0x00001849
    3eb4:	00004161 	.word	0x00004161
    3eb8:	00004135 	.word	0x00004135
    3ebc:	000045d5 	.word	0x000045d5
    3ec0:	00003671 	.word	0x00003671
    3ec4:	000036b5 	.word	0x000036b5
    3ec8:	00003635 	.word	0x00003635

00003ecc <_usart_async_enable>:

/**
 * \brief Enable SERCOM module
 */
void _usart_async_enable(struct _usart_async_device *const device)
{
    3ecc:	b580      	push	{r7, lr}
    3ece:	b082      	sub	sp, #8
    3ed0:	af00      	add	r7, sp, #0
    3ed2:	6078      	str	r0, [r7, #4]
	hri_sercomusart_set_CTRLA_ENABLE_bit(device->hw);
    3ed4:	687b      	ldr	r3, [r7, #4]
    3ed6:	699b      	ldr	r3, [r3, #24]
    3ed8:	4618      	mov	r0, r3
    3eda:	4b03      	ldr	r3, [pc, #12]	; (3ee8 <_usart_async_enable+0x1c>)
    3edc:	4798      	blx	r3
}
    3ede:	bf00      	nop
    3ee0:	3708      	adds	r7, #8
    3ee2:	46bd      	mov	sp, r7
    3ee4:	bd80      	pop	{r7, pc}
    3ee6:	bf00      	nop
    3ee8:	00003a25 	.word	0x00003a25

00003eec <_usart_async_write_byte>:

/**
 * \brief Write a byte to the given SERCOM USART instance
 */
void _usart_async_write_byte(struct _usart_async_device *const device, uint8_t data)
{
    3eec:	b580      	push	{r7, lr}
    3eee:	b082      	sub	sp, #8
    3ef0:	af00      	add	r7, sp, #0
    3ef2:	6078      	str	r0, [r7, #4]
    3ef4:	460b      	mov	r3, r1
    3ef6:	70fb      	strb	r3, [r7, #3]
	hri_sercomusart_write_DATA_reg(device->hw, data);
    3ef8:	687b      	ldr	r3, [r7, #4]
    3efa:	699b      	ldr	r3, [r3, #24]
    3efc:	78fa      	ldrb	r2, [r7, #3]
    3efe:	4611      	mov	r1, r2
    3f00:	4618      	mov	r0, r3
    3f02:	4b03      	ldr	r3, [pc, #12]	; (3f10 <_usart_async_write_byte+0x24>)
    3f04:	4798      	blx	r3
}
    3f06:	bf00      	nop
    3f08:	3708      	adds	r7, #8
    3f0a:	46bd      	mov	sp, r7
    3f0c:	bd80      	pop	{r7, pc}
    3f0e:	bf00      	nop
    3f10:	00003d1d 	.word	0x00003d1d

00003f14 <_usart_async_is_byte_sent>:

/**
 * \brief Check if USART is ready to send next byte
 */
bool _usart_async_is_byte_sent(const struct _usart_async_device *const device)
{
    3f14:	b580      	push	{r7, lr}
    3f16:	b082      	sub	sp, #8
    3f18:	af00      	add	r7, sp, #0
    3f1a:	6078      	str	r0, [r7, #4]
	return hri_sercomusart_get_interrupt_DRE_bit(device->hw);
    3f1c:	687b      	ldr	r3, [r7, #4]
    3f1e:	699b      	ldr	r3, [r3, #24]
    3f20:	4618      	mov	r0, r3
    3f22:	4b03      	ldr	r3, [pc, #12]	; (3f30 <_usart_async_is_byte_sent+0x1c>)
    3f24:	4798      	blx	r3
    3f26:	4603      	mov	r3, r0
}
    3f28:	4618      	mov	r0, r3
    3f2a:	3708      	adds	r7, #8
    3f2c:	46bd      	mov	sp, r7
    3f2e:	bd80      	pop	{r7, pc}
    3f30:	000037d7 	.word	0x000037d7

00003f34 <_usart_async_enable_byte_sent_irq>:

/**
 * \brief Enable data register empty interrupt
 */
void _usart_async_enable_byte_sent_irq(struct _usart_async_device *const device)
{
    3f34:	b580      	push	{r7, lr}
    3f36:	b082      	sub	sp, #8
    3f38:	af00      	add	r7, sp, #0
    3f3a:	6078      	str	r0, [r7, #4]
	hri_sercomusart_set_INTEN_DRE_bit(device->hw);
    3f3c:	687b      	ldr	r3, [r7, #4]
    3f3e:	699b      	ldr	r3, [r3, #24]
    3f40:	4618      	mov	r0, r3
    3f42:	4b03      	ldr	r3, [pc, #12]	; (3f50 <_usart_async_enable_byte_sent_irq+0x1c>)
    3f44:	4798      	blx	r3
}
    3f46:	bf00      	nop
    3f48:	3708      	adds	r7, #8
    3f4a:	46bd      	mov	sp, r7
    3f4c:	bd80      	pop	{r7, pc}
    3f4e:	bf00      	nop
    3f50:	00003897 	.word	0x00003897

00003f54 <_usart_async_enable_tx_done_irq>:

/**
 * \brief Enable transmission complete interrupt
 */
void _usart_async_enable_tx_done_irq(struct _usart_async_device *const device)
{
    3f54:	b580      	push	{r7, lr}
    3f56:	b082      	sub	sp, #8
    3f58:	af00      	add	r7, sp, #0
    3f5a:	6078      	str	r0, [r7, #4]
	hri_sercomusart_set_INTEN_TXC_bit(device->hw);
    3f5c:	687b      	ldr	r3, [r7, #4]
    3f5e:	699b      	ldr	r3, [r3, #24]
    3f60:	4618      	mov	r0, r3
    3f62:	4b03      	ldr	r3, [pc, #12]	; (3f70 <_usart_async_enable_tx_done_irq+0x1c>)
    3f64:	4798      	blx	r3
}
    3f66:	bf00      	nop
    3f68:	3708      	adds	r7, #8
    3f6a:	46bd      	mov	sp, r7
    3f6c:	bd80      	pop	{r7, pc}
    3f6e:	bf00      	nop
    3f70:	000038f3 	.word	0x000038f3

00003f74 <_sercom_get_hardware_index>:

/**
 * \brief Retrieve ordinal number of the given sercom hardware instance
 */
static uint8_t _sercom_get_hardware_index(const void *const hw)
{
    3f74:	b4b0      	push	{r4, r5, r7}
    3f76:	b08d      	sub	sp, #52	; 0x34
    3f78:	af00      	add	r7, sp, #0
    3f7a:	6078      	str	r0, [r7, #4]
	Sercom *const sercom_modules[] = SERCOM_INSTS;
    3f7c:	4b13      	ldr	r3, [pc, #76]	; (3fcc <_sercom_get_hardware_index+0x58>)
    3f7e:	f107 040c 	add.w	r4, r7, #12
    3f82:	461d      	mov	r5, r3
    3f84:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
    3f86:	c40f      	stmia	r4!, {r0, r1, r2, r3}
    3f88:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
    3f8c:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
	/* Find index for SERCOM instance. */
	for (uint32_t i = 0; i < SERCOM_INST_NUM; i++) {
    3f90:	2300      	movs	r3, #0
    3f92:	62fb      	str	r3, [r7, #44]	; 0x2c
    3f94:	e010      	b.n	3fb8 <_sercom_get_hardware_index+0x44>
		if ((uint32_t)hw == (uint32_t)sercom_modules[i]) {
    3f96:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    3f98:	009b      	lsls	r3, r3, #2
    3f9a:	f107 0230 	add.w	r2, r7, #48	; 0x30
    3f9e:	4413      	add	r3, r2
    3fa0:	f853 3c24 	ldr.w	r3, [r3, #-36]
    3fa4:	461a      	mov	r2, r3
    3fa6:	687b      	ldr	r3, [r7, #4]
    3fa8:	429a      	cmp	r2, r3
    3faa:	d102      	bne.n	3fb2 <_sercom_get_hardware_index+0x3e>
			return i;
    3fac:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    3fae:	b2db      	uxtb	r3, r3
    3fb0:	e006      	b.n	3fc0 <_sercom_get_hardware_index+0x4c>
	for (uint32_t i = 0; i < SERCOM_INST_NUM; i++) {
    3fb2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    3fb4:	3301      	adds	r3, #1
    3fb6:	62fb      	str	r3, [r7, #44]	; 0x2c
    3fb8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    3fba:	2b07      	cmp	r3, #7
    3fbc:	d9eb      	bls.n	3f96 <_sercom_get_hardware_index+0x22>
		}
	}
	return 0;
    3fbe:	2300      	movs	r3, #0
}
    3fc0:	4618      	mov	r0, r3
    3fc2:	3734      	adds	r7, #52	; 0x34
    3fc4:	46bd      	mov	sp, r7
    3fc6:	bcb0      	pop	{r4, r5, r7}
    3fc8:	4770      	bx	lr
    3fca:	bf00      	nop
    3fcc:	00005df0 	.word	0x00005df0

00003fd0 <_sercom_usart_interrupt_handler>:
 * \internal Sercom interrupt handler
 *
 * \param[in] p The pointer to interrupt parameter
 */
static void _sercom_usart_interrupt_handler(struct _usart_async_device *device)
{
    3fd0:	b590      	push	{r4, r7, lr}
    3fd2:	b085      	sub	sp, #20
    3fd4:	af00      	add	r7, sp, #0
    3fd6:	6078      	str	r0, [r7, #4]
	void *hw = device->hw;
    3fd8:	687b      	ldr	r3, [r7, #4]
    3fda:	699b      	ldr	r3, [r3, #24]
    3fdc:	60fb      	str	r3, [r7, #12]

	if (hri_sercomusart_get_interrupt_DRE_bit(hw) && hri_sercomusart_get_INTEN_DRE_bit(hw)) {
    3fde:	68f8      	ldr	r0, [r7, #12]
    3fe0:	4b2f      	ldr	r3, [pc, #188]	; (40a0 <_sercom_usart_interrupt_handler+0xd0>)
    3fe2:	4798      	blx	r3
    3fe4:	4603      	mov	r3, r0
    3fe6:	2b00      	cmp	r3, #0
    3fe8:	d00d      	beq.n	4006 <_sercom_usart_interrupt_handler+0x36>
    3fea:	68f8      	ldr	r0, [r7, #12]
    3fec:	4b2d      	ldr	r3, [pc, #180]	; (40a4 <_sercom_usart_interrupt_handler+0xd4>)
    3fee:	4798      	blx	r3
    3ff0:	4603      	mov	r3, r0
    3ff2:	2b00      	cmp	r3, #0
    3ff4:	d007      	beq.n	4006 <_sercom_usart_interrupt_handler+0x36>
		hri_sercomusart_clear_INTEN_DRE_bit(hw);
    3ff6:	68f8      	ldr	r0, [r7, #12]
    3ff8:	4b2b      	ldr	r3, [pc, #172]	; (40a8 <_sercom_usart_interrupt_handler+0xd8>)
    3ffa:	4798      	blx	r3
		device->usart_cb.tx_byte_sent(device);
    3ffc:	687b      	ldr	r3, [r7, #4]
    3ffe:	681b      	ldr	r3, [r3, #0]
    4000:	6878      	ldr	r0, [r7, #4]
    4002:	4798      	blx	r3
    4004:	e049      	b.n	409a <_sercom_usart_interrupt_handler+0xca>
	} else if (hri_sercomusart_get_interrupt_TXC_bit(hw) && hri_sercomusart_get_INTEN_TXC_bit(hw)) {
    4006:	68f8      	ldr	r0, [r7, #12]
    4008:	4b28      	ldr	r3, [pc, #160]	; (40ac <_sercom_usart_interrupt_handler+0xdc>)
    400a:	4798      	blx	r3
    400c:	4603      	mov	r3, r0
    400e:	2b00      	cmp	r3, #0
    4010:	d00d      	beq.n	402e <_sercom_usart_interrupt_handler+0x5e>
    4012:	68f8      	ldr	r0, [r7, #12]
    4014:	4b26      	ldr	r3, [pc, #152]	; (40b0 <_sercom_usart_interrupt_handler+0xe0>)
    4016:	4798      	blx	r3
    4018:	4603      	mov	r3, r0
    401a:	2b00      	cmp	r3, #0
    401c:	d007      	beq.n	402e <_sercom_usart_interrupt_handler+0x5e>
		hri_sercomusart_clear_INTEN_TXC_bit(hw);
    401e:	68f8      	ldr	r0, [r7, #12]
    4020:	4b24      	ldr	r3, [pc, #144]	; (40b4 <_sercom_usart_interrupt_handler+0xe4>)
    4022:	4798      	blx	r3
		device->usart_cb.tx_done_cb(device);
    4024:	687b      	ldr	r3, [r7, #4]
    4026:	689b      	ldr	r3, [r3, #8]
    4028:	6878      	ldr	r0, [r7, #4]
    402a:	4798      	blx	r3
    402c:	e035      	b.n	409a <_sercom_usart_interrupt_handler+0xca>
	} else if (hri_sercomusart_get_interrupt_RXC_bit(hw)) {
    402e:	68f8      	ldr	r0, [r7, #12]
    4030:	4b21      	ldr	r3, [pc, #132]	; (40b8 <_sercom_usart_interrupt_handler+0xe8>)
    4032:	4798      	blx	r3
    4034:	4603      	mov	r3, r0
    4036:	2b00      	cmp	r3, #0
    4038:	d017      	beq.n	406a <_sercom_usart_interrupt_handler+0x9a>
		if (hri_sercomusart_read_STATUS_reg(hw)
    403a:	68f8      	ldr	r0, [r7, #12]
    403c:	4b1f      	ldr	r3, [pc, #124]	; (40bc <_sercom_usart_interrupt_handler+0xec>)
    403e:	4798      	blx	r3
    4040:	4603      	mov	r3, r0
		    & (SERCOM_USART_STATUS_PERR | SERCOM_USART_STATUS_FERR | SERCOM_USART_STATUS_BUFOVF
    4042:	f003 0337 	and.w	r3, r3, #55	; 0x37
		if (hri_sercomusart_read_STATUS_reg(hw)
    4046:	2b00      	cmp	r3, #0
    4048:	d004      	beq.n	4054 <_sercom_usart_interrupt_handler+0x84>
		       | SERCOM_USART_STATUS_ISF | SERCOM_USART_STATUS_COLL)) {
			hri_sercomusart_clear_STATUS_reg(hw, SERCOM_USART_STATUS_MASK);
    404a:	21ff      	movs	r1, #255	; 0xff
    404c:	68f8      	ldr	r0, [r7, #12]
    404e:	4b1c      	ldr	r3, [pc, #112]	; (40c0 <_sercom_usart_interrupt_handler+0xf0>)
    4050:	4798      	blx	r3
			return;
    4052:	e022      	b.n	409a <_sercom_usart_interrupt_handler+0xca>
		}

		device->usart_cb.rx_done_cb(device, hri_sercomusart_read_DATA_reg(hw));
    4054:	687b      	ldr	r3, [r7, #4]
    4056:	685c      	ldr	r4, [r3, #4]
    4058:	68f8      	ldr	r0, [r7, #12]
    405a:	4b1a      	ldr	r3, [pc, #104]	; (40c4 <_sercom_usart_interrupt_handler+0xf4>)
    405c:	4798      	blx	r3
    405e:	4603      	mov	r3, r0
    4060:	b2db      	uxtb	r3, r3
    4062:	4619      	mov	r1, r3
    4064:	6878      	ldr	r0, [r7, #4]
    4066:	47a0      	blx	r4
    4068:	e017      	b.n	409a <_sercom_usart_interrupt_handler+0xca>
	} else if (hri_sercomusart_get_interrupt_ERROR_bit(hw)) {
    406a:	68f8      	ldr	r0, [r7, #12]
    406c:	4b16      	ldr	r3, [pc, #88]	; (40c8 <_sercom_usart_interrupt_handler+0xf8>)
    406e:	4798      	blx	r3
    4070:	4603      	mov	r3, r0
    4072:	2b00      	cmp	r3, #0
    4074:	d011      	beq.n	409a <_sercom_usart_interrupt_handler+0xca>
		uint32_t status;

		hri_sercomusart_clear_interrupt_ERROR_bit(hw);
    4076:	68f8      	ldr	r0, [r7, #12]
    4078:	4b14      	ldr	r3, [pc, #80]	; (40cc <_sercom_usart_interrupt_handler+0xfc>)
    407a:	4798      	blx	r3
		device->usart_cb.error_cb(device);
    407c:	687b      	ldr	r3, [r7, #4]
    407e:	68db      	ldr	r3, [r3, #12]
    4080:	6878      	ldr	r0, [r7, #4]
    4082:	4798      	blx	r3
		status = hri_sercomusart_read_STATUS_reg(hw);
    4084:	68f8      	ldr	r0, [r7, #12]
    4086:	4b0d      	ldr	r3, [pc, #52]	; (40bc <_sercom_usart_interrupt_handler+0xec>)
    4088:	4798      	blx	r3
    408a:	4603      	mov	r3, r0
    408c:	60bb      	str	r3, [r7, #8]
		hri_sercomusart_clear_STATUS_reg(hw, status);
    408e:	68bb      	ldr	r3, [r7, #8]
    4090:	b29b      	uxth	r3, r3
    4092:	4619      	mov	r1, r3
    4094:	68f8      	ldr	r0, [r7, #12]
    4096:	4b0a      	ldr	r3, [pc, #40]	; (40c0 <_sercom_usart_interrupt_handler+0xf0>)
    4098:	4798      	blx	r3
	}
}
    409a:	3714      	adds	r7, #20
    409c:	46bd      	mov	sp, r7
    409e:	bd90      	pop	{r4, r7, pc}
    40a0:	000037d7 	.word	0x000037d7
    40a4:	000038b1 	.word	0x000038b1
    40a8:	000038d9 	.word	0x000038d9
    40ac:	000037ff 	.word	0x000037ff
    40b0:	0000390d 	.word	0x0000390d
    40b4:	00003937 	.word	0x00003937
    40b8:	00003829 	.word	0x00003829
    40bc:	00003d8f 	.word	0x00003d8f
    40c0:	00003d71 	.word	0x00003d71
    40c4:	00003d39 	.word	0x00003d39
    40c8:	00003853 	.word	0x00003853
    40cc:	0000387d 	.word	0x0000387d

000040d0 <_get_sercom_index>:
 * \param[in] hw The pointer to hardware instance

 * \return The ordinal number of the given sercom hardware instance
 */
static uint8_t _get_sercom_index(const void *const hw)
{
    40d0:	b580      	push	{r7, lr}
    40d2:	b084      	sub	sp, #16
    40d4:	af00      	add	r7, sp, #0
    40d6:	6078      	str	r0, [r7, #4]
	uint8_t sercom_offset = _sercom_get_hardware_index(hw);
    40d8:	6878      	ldr	r0, [r7, #4]
    40da:	4b12      	ldr	r3, [pc, #72]	; (4124 <_get_sercom_index+0x54>)
    40dc:	4798      	blx	r3
    40de:	4603      	mov	r3, r0
    40e0:	73bb      	strb	r3, [r7, #14]
	uint8_t i;

	for (i = 0; i < ARRAY_SIZE(_usarts); i++) {
    40e2:	2300      	movs	r3, #0
    40e4:	73fb      	strb	r3, [r7, #15]
    40e6:	e00f      	b.n	4108 <_get_sercom_index+0x38>
		if (_usarts[i].number == sercom_offset) {
    40e8:	7bfa      	ldrb	r2, [r7, #15]
    40ea:	490f      	ldr	r1, [pc, #60]	; (4128 <_get_sercom_index+0x58>)
    40ec:	4613      	mov	r3, r2
    40ee:	005b      	lsls	r3, r3, #1
    40f0:	4413      	add	r3, r2
    40f2:	00db      	lsls	r3, r3, #3
    40f4:	440b      	add	r3, r1
    40f6:	781b      	ldrb	r3, [r3, #0]
    40f8:	7bba      	ldrb	r2, [r7, #14]
    40fa:	429a      	cmp	r2, r3
    40fc:	d101      	bne.n	4102 <_get_sercom_index+0x32>
			return i;
    40fe:	7bfb      	ldrb	r3, [r7, #15]
    4100:	e00c      	b.n	411c <_get_sercom_index+0x4c>
	for (i = 0; i < ARRAY_SIZE(_usarts); i++) {
    4102:	7bfb      	ldrb	r3, [r7, #15]
    4104:	3301      	adds	r3, #1
    4106:	73fb      	strb	r3, [r7, #15]
    4108:	7bfb      	ldrb	r3, [r7, #15]
    410a:	2b00      	cmp	r3, #0
    410c:	d0ec      	beq.n	40e8 <_get_sercom_index+0x18>
		}
	}

	ASSERT(false);
    410e:	f240 226b 	movw	r2, #619	; 0x26b
    4112:	4906      	ldr	r1, [pc, #24]	; (412c <_get_sercom_index+0x5c>)
    4114:	2000      	movs	r0, #0
    4116:	4b06      	ldr	r3, [pc, #24]	; (4130 <_get_sercom_index+0x60>)
    4118:	4798      	blx	r3
	return 0;
    411a:	2300      	movs	r3, #0
}
    411c:	4618      	mov	r0, r3
    411e:	3710      	adds	r7, #16
    4120:	46bd      	mov	sp, r7
    4122:	bd80      	pop	{r7, pc}
    4124:	00003f75 	.word	0x00003f75
    4128:	20000000 	.word	0x20000000
    412c:	00005dd4 	.word	0x00005dd4
    4130:	00001849 	.word	0x00001849

00004134 <_sercom_init_irq_param>:

/**
 * \brief Init irq param with the given sercom hardware instance
 */
static void _sercom_init_irq_param(const void *const hw, void *dev)
{
    4134:	b480      	push	{r7}
    4136:	b083      	sub	sp, #12
    4138:	af00      	add	r7, sp, #0
    413a:	6078      	str	r0, [r7, #4]
    413c:	6039      	str	r1, [r7, #0]

	if (hw == SERCOM1) {
    413e:	687b      	ldr	r3, [r7, #4]
    4140:	4a05      	ldr	r2, [pc, #20]	; (4158 <_sercom_init_irq_param+0x24>)
    4142:	4293      	cmp	r3, r2
    4144:	d102      	bne.n	414c <_sercom_init_irq_param+0x18>
		_sercom1_dev = (struct _usart_async_device *)dev;
    4146:	4a05      	ldr	r2, [pc, #20]	; (415c <_sercom_init_irq_param+0x28>)
    4148:	683b      	ldr	r3, [r7, #0]
    414a:	6013      	str	r3, [r2, #0]
	}
}
    414c:	bf00      	nop
    414e:	370c      	adds	r7, #12
    4150:	46bd      	mov	sp, r7
    4152:	f85d 7b04 	ldr.w	r7, [sp], #4
    4156:	4770      	bx	lr
    4158:	40003400 	.word	0x40003400
    415c:	20000aa8 	.word	0x20000aa8

00004160 <_usart_init>:
 * \param[in] hw The pointer to hardware instance
 *
 * \return The status of initialization
 */
static int32_t _usart_init(void *const hw)
{
    4160:	b580      	push	{r7, lr}
    4162:	b084      	sub	sp, #16
    4164:	af00      	add	r7, sp, #0
    4166:	6078      	str	r0, [r7, #4]
	uint8_t i = _get_sercom_index(hw);
    4168:	6878      	ldr	r0, [r7, #4]
    416a:	4b61      	ldr	r3, [pc, #388]	; (42f0 <_usart_init+0x190>)
    416c:	4798      	blx	r3
    416e:	4603      	mov	r3, r0
    4170:	73fb      	strb	r3, [r7, #15]

	if (!hri_sercomusart_is_syncing(hw, SERCOM_USART_SYNCBUSY_SWRST)) {
    4172:	2101      	movs	r1, #1
    4174:	6878      	ldr	r0, [r7, #4]
    4176:	4b5f      	ldr	r3, [pc, #380]	; (42f4 <_usart_init+0x194>)
    4178:	4798      	blx	r3
    417a:	4603      	mov	r3, r0
    417c:	f083 0301 	eor.w	r3, r3, #1
    4180:	b2db      	uxtb	r3, r3
    4182:	2b00      	cmp	r3, #0
    4184:	d020      	beq.n	41c8 <_usart_init+0x68>
		uint32_t mode = _usarts[i].ctrl_a & SERCOM_USART_CTRLA_MODE_Msk;
    4186:	7bfa      	ldrb	r2, [r7, #15]
    4188:	495b      	ldr	r1, [pc, #364]	; (42f8 <_usart_init+0x198>)
    418a:	4613      	mov	r3, r2
    418c:	005b      	lsls	r3, r3, #1
    418e:	4413      	add	r3, r2
    4190:	00db      	lsls	r3, r3, #3
    4192:	440b      	add	r3, r1
    4194:	3304      	adds	r3, #4
    4196:	681b      	ldr	r3, [r3, #0]
    4198:	f003 031c 	and.w	r3, r3, #28
    419c:	60bb      	str	r3, [r7, #8]
		if (hri_sercomusart_get_CTRLA_reg(hw, SERCOM_USART_CTRLA_ENABLE)) {
    419e:	2102      	movs	r1, #2
    41a0:	6878      	ldr	r0, [r7, #4]
    41a2:	4b56      	ldr	r3, [pc, #344]	; (42fc <_usart_init+0x19c>)
    41a4:	4798      	blx	r3
    41a6:	4603      	mov	r3, r0
    41a8:	2b00      	cmp	r3, #0
    41aa:	d006      	beq.n	41ba <_usart_init+0x5a>
			hri_sercomusart_clear_CTRLA_ENABLE_bit(hw);
    41ac:	6878      	ldr	r0, [r7, #4]
    41ae:	4b54      	ldr	r3, [pc, #336]	; (4300 <_usart_init+0x1a0>)
    41b0:	4798      	blx	r3
			hri_sercomusart_wait_for_sync(hw, SERCOM_USART_SYNCBUSY_ENABLE);
    41b2:	2102      	movs	r1, #2
    41b4:	6878      	ldr	r0, [r7, #4]
    41b6:	4b53      	ldr	r3, [pc, #332]	; (4304 <_usart_init+0x1a4>)
    41b8:	4798      	blx	r3
		}
		hri_sercomusart_write_CTRLA_reg(hw, SERCOM_USART_CTRLA_SWRST | mode);
    41ba:	68bb      	ldr	r3, [r7, #8]
    41bc:	f043 0301 	orr.w	r3, r3, #1
    41c0:	4619      	mov	r1, r3
    41c2:	6878      	ldr	r0, [r7, #4]
    41c4:	4b50      	ldr	r3, [pc, #320]	; (4308 <_usart_init+0x1a8>)
    41c6:	4798      	blx	r3
	}
	hri_sercomusart_wait_for_sync(hw, SERCOM_USART_SYNCBUSY_SWRST);
    41c8:	2101      	movs	r1, #1
    41ca:	6878      	ldr	r0, [r7, #4]
    41cc:	4b4d      	ldr	r3, [pc, #308]	; (4304 <_usart_init+0x1a4>)
    41ce:	4798      	blx	r3

	hri_sercomusart_write_CTRLA_reg(hw, _usarts[i].ctrl_a);
    41d0:	7bfa      	ldrb	r2, [r7, #15]
    41d2:	4949      	ldr	r1, [pc, #292]	; (42f8 <_usart_init+0x198>)
    41d4:	4613      	mov	r3, r2
    41d6:	005b      	lsls	r3, r3, #1
    41d8:	4413      	add	r3, r2
    41da:	00db      	lsls	r3, r3, #3
    41dc:	440b      	add	r3, r1
    41de:	3304      	adds	r3, #4
    41e0:	681b      	ldr	r3, [r3, #0]
    41e2:	4619      	mov	r1, r3
    41e4:	6878      	ldr	r0, [r7, #4]
    41e6:	4b48      	ldr	r3, [pc, #288]	; (4308 <_usart_init+0x1a8>)
    41e8:	4798      	blx	r3
	hri_sercomusart_write_CTRLB_reg(hw, _usarts[i].ctrl_b);
    41ea:	7bfa      	ldrb	r2, [r7, #15]
    41ec:	4942      	ldr	r1, [pc, #264]	; (42f8 <_usart_init+0x198>)
    41ee:	4613      	mov	r3, r2
    41f0:	005b      	lsls	r3, r3, #1
    41f2:	4413      	add	r3, r2
    41f4:	00db      	lsls	r3, r3, #3
    41f6:	440b      	add	r3, r1
    41f8:	3308      	adds	r3, #8
    41fa:	681b      	ldr	r3, [r3, #0]
    41fc:	4619      	mov	r1, r3
    41fe:	6878      	ldr	r0, [r7, #4]
    4200:	4b42      	ldr	r3, [pc, #264]	; (430c <_usart_init+0x1ac>)
    4202:	4798      	blx	r3
	hri_sercomusart_write_CTRLC_reg(hw, _usarts[i].ctrl_c);
    4204:	7bfa      	ldrb	r2, [r7, #15]
    4206:	493c      	ldr	r1, [pc, #240]	; (42f8 <_usart_init+0x198>)
    4208:	4613      	mov	r3, r2
    420a:	005b      	lsls	r3, r3, #1
    420c:	4413      	add	r3, r2
    420e:	00db      	lsls	r3, r3, #3
    4210:	440b      	add	r3, r1
    4212:	330c      	adds	r3, #12
    4214:	681b      	ldr	r3, [r3, #0]
    4216:	4619      	mov	r1, r3
    4218:	6878      	ldr	r0, [r7, #4]
    421a:	4b3d      	ldr	r3, [pc, #244]	; (4310 <_usart_init+0x1b0>)
    421c:	4798      	blx	r3
	if ((_usarts[i].ctrl_a & SERCOM_USART_CTRLA_SAMPR(0x1)) || (_usarts[i].ctrl_a & SERCOM_USART_CTRLA_SAMPR(0x3))) {
    421e:	7bfa      	ldrb	r2, [r7, #15]
    4220:	4935      	ldr	r1, [pc, #212]	; (42f8 <_usart_init+0x198>)
    4222:	4613      	mov	r3, r2
    4224:	005b      	lsls	r3, r3, #1
    4226:	4413      	add	r3, r2
    4228:	00db      	lsls	r3, r3, #3
    422a:	440b      	add	r3, r1
    422c:	3304      	adds	r3, #4
    422e:	681b      	ldr	r3, [r3, #0]
    4230:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
    4234:	2b00      	cmp	r3, #0
    4236:	d10c      	bne.n	4252 <_usart_init+0xf2>
    4238:	7bfa      	ldrb	r2, [r7, #15]
    423a:	492f      	ldr	r1, [pc, #188]	; (42f8 <_usart_init+0x198>)
    423c:	4613      	mov	r3, r2
    423e:	005b      	lsls	r3, r3, #1
    4240:	4413      	add	r3, r2
    4242:	00db      	lsls	r3, r3, #3
    4244:	440b      	add	r3, r1
    4246:	3304      	adds	r3, #4
    4248:	681b      	ldr	r3, [r3, #0]
    424a:	f403 43c0 	and.w	r3, r3, #24576	; 0x6000
    424e:	2b00      	cmp	r3, #0
    4250:	d022      	beq.n	4298 <_usart_init+0x138>
		((Sercom *)hw)->USART.BAUD.FRAC.BAUD = _usarts[i].baud;
    4252:	7bfa      	ldrb	r2, [r7, #15]
    4254:	4928      	ldr	r1, [pc, #160]	; (42f8 <_usart_init+0x198>)
    4256:	4613      	mov	r3, r2
    4258:	005b      	lsls	r3, r3, #1
    425a:	4413      	add	r3, r2
    425c:	00db      	lsls	r3, r3, #3
    425e:	440b      	add	r3, r1
    4260:	3310      	adds	r3, #16
    4262:	881b      	ldrh	r3, [r3, #0]
    4264:	f3c3 030c 	ubfx	r3, r3, #0, #13
    4268:	b299      	uxth	r1, r3
    426a:	687a      	ldr	r2, [r7, #4]
    426c:	8993      	ldrh	r3, [r2, #12]
    426e:	f361 030c 	bfi	r3, r1, #0, #13
    4272:	8193      	strh	r3, [r2, #12]
		((Sercom *)hw)->USART.BAUD.FRAC.FP   = _usarts[i].fractional;
    4274:	7bfa      	ldrb	r2, [r7, #15]
    4276:	4920      	ldr	r1, [pc, #128]	; (42f8 <_usart_init+0x198>)
    4278:	4613      	mov	r3, r2
    427a:	005b      	lsls	r3, r3, #1
    427c:	4413      	add	r3, r2
    427e:	00db      	lsls	r3, r3, #3
    4280:	440b      	add	r3, r1
    4282:	3312      	adds	r3, #18
    4284:	781b      	ldrb	r3, [r3, #0]
    4286:	f003 0307 	and.w	r3, r3, #7
    428a:	b2d9      	uxtb	r1, r3
    428c:	687a      	ldr	r2, [r7, #4]
    428e:	8993      	ldrh	r3, [r2, #12]
    4290:	f361 334f 	bfi	r3, r1, #13, #3
    4294:	8193      	strh	r3, [r2, #12]
    4296:	e00c      	b.n	42b2 <_usart_init+0x152>
	} else {
		hri_sercomusart_write_BAUD_reg(hw, _usarts[i].baud);
    4298:	7bfa      	ldrb	r2, [r7, #15]
    429a:	4917      	ldr	r1, [pc, #92]	; (42f8 <_usart_init+0x198>)
    429c:	4613      	mov	r3, r2
    429e:	005b      	lsls	r3, r3, #1
    42a0:	4413      	add	r3, r2
    42a2:	00db      	lsls	r3, r3, #3
    42a4:	440b      	add	r3, r1
    42a6:	3310      	adds	r3, #16
    42a8:	881b      	ldrh	r3, [r3, #0]
    42aa:	4619      	mov	r1, r3
    42ac:	6878      	ldr	r0, [r7, #4]
    42ae:	4b19      	ldr	r3, [pc, #100]	; (4314 <_usart_init+0x1b4>)
    42b0:	4798      	blx	r3
	}

	hri_sercomusart_write_RXPL_reg(hw, _usarts[i].rxpl);
    42b2:	7bfa      	ldrb	r2, [r7, #15]
    42b4:	4910      	ldr	r1, [pc, #64]	; (42f8 <_usart_init+0x198>)
    42b6:	4613      	mov	r3, r2
    42b8:	005b      	lsls	r3, r3, #1
    42ba:	4413      	add	r3, r2
    42bc:	00db      	lsls	r3, r3, #3
    42be:	440b      	add	r3, r1
    42c0:	3313      	adds	r3, #19
    42c2:	781b      	ldrb	r3, [r3, #0]
    42c4:	4619      	mov	r1, r3
    42c6:	6878      	ldr	r0, [r7, #4]
    42c8:	4b13      	ldr	r3, [pc, #76]	; (4318 <_usart_init+0x1b8>)
    42ca:	4798      	blx	r3
	hri_sercomusart_write_DBGCTRL_reg(hw, _usarts[i].debug_ctrl);
    42cc:	7bfa      	ldrb	r2, [r7, #15]
    42ce:	490a      	ldr	r1, [pc, #40]	; (42f8 <_usart_init+0x198>)
    42d0:	4613      	mov	r3, r2
    42d2:	005b      	lsls	r3, r3, #1
    42d4:	4413      	add	r3, r2
    42d6:	00db      	lsls	r3, r3, #3
    42d8:	440b      	add	r3, r1
    42da:	3314      	adds	r3, #20
    42dc:	781b      	ldrb	r3, [r3, #0]
    42de:	4619      	mov	r1, r3
    42e0:	6878      	ldr	r0, [r7, #4]
    42e2:	4b0e      	ldr	r3, [pc, #56]	; (431c <_usart_init+0x1bc>)
    42e4:	4798      	blx	r3

	return ERR_NONE;
    42e6:	2300      	movs	r3, #0
}
    42e8:	4618      	mov	r0, r3
    42ea:	3710      	adds	r7, #16
    42ec:	46bd      	mov	sp, r7
    42ee:	bd80      	pop	{r7, pc}
    42f0:	000040d1 	.word	0x000040d1
    42f4:	00003761 	.word	0x00003761
    42f8:	20000000 	.word	0x20000000
    42fc:	00003a75 	.word	0x00003a75
    4300:	00003a4d 	.word	0x00003a4d
    4304:	0000373d 	.word	0x0000373d
    4308:	00003aa5 	.word	0x00003aa5
    430c:	00003bbd 	.word	0x00003bbd
    4310:	00003be1 	.word	0x00003be1
    4314:	00003c19 	.word	0x00003c19
    4318:	00003c37 	.word	0x00003c37
    431c:	00003d51 	.word	0x00003d51

00004320 <_get_i2cm_index>:
 * \param[in] hw The pointer to hardware instance

 * \return The ordinal number of the given sercom hardware instance
 */
static int8_t _get_i2cm_index(const void *const hw)
{
    4320:	b580      	push	{r7, lr}
    4322:	b084      	sub	sp, #16
    4324:	af00      	add	r7, sp, #0
    4326:	6078      	str	r0, [r7, #4]
	uint8_t sercom_offset = _sercom_get_hardware_index(hw);
    4328:	6878      	ldr	r0, [r7, #4]
    432a:	4b13      	ldr	r3, [pc, #76]	; (4378 <_get_i2cm_index+0x58>)
    432c:	4798      	blx	r3
    432e:	4603      	mov	r3, r0
    4330:	73bb      	strb	r3, [r7, #14]
	uint8_t i;

	for (i = 0; i < ARRAY_SIZE(_i2cms); i++) {
    4332:	2300      	movs	r3, #0
    4334:	73fb      	strb	r3, [r7, #15]
    4336:	e010      	b.n	435a <_get_i2cm_index+0x3a>
		if (_i2cms[i].number == sercom_offset) {
    4338:	7bfa      	ldrb	r2, [r7, #15]
    433a:	4910      	ldr	r1, [pc, #64]	; (437c <_get_i2cm_index+0x5c>)
    433c:	4613      	mov	r3, r2
    433e:	005b      	lsls	r3, r3, #1
    4340:	4413      	add	r3, r2
    4342:	00db      	lsls	r3, r3, #3
    4344:	440b      	add	r3, r1
    4346:	781b      	ldrb	r3, [r3, #0]
    4348:	7bba      	ldrb	r2, [r7, #14]
    434a:	429a      	cmp	r2, r3
    434c:	d102      	bne.n	4354 <_get_i2cm_index+0x34>
			return i;
    434e:	f997 300f 	ldrsb.w	r3, [r7, #15]
    4352:	e00d      	b.n	4370 <_get_i2cm_index+0x50>
	for (i = 0; i < ARRAY_SIZE(_i2cms); i++) {
    4354:	7bfb      	ldrb	r3, [r7, #15]
    4356:	3301      	adds	r3, #1
    4358:	73fb      	strb	r3, [r7, #15]
    435a:	7bfb      	ldrb	r3, [r7, #15]
    435c:	2b00      	cmp	r3, #0
    435e:	d0eb      	beq.n	4338 <_get_i2cm_index+0x18>
		}
	}

	ASSERT(false);
    4360:	f240 32ce 	movw	r2, #974	; 0x3ce
    4364:	4906      	ldr	r1, [pc, #24]	; (4380 <_get_i2cm_index+0x60>)
    4366:	2000      	movs	r0, #0
    4368:	4b06      	ldr	r3, [pc, #24]	; (4384 <_get_i2cm_index+0x64>)
    436a:	4798      	blx	r3
	return -1;
    436c:	f04f 33ff 	mov.w	r3, #4294967295
}
    4370:	4618      	mov	r0, r3
    4372:	3710      	adds	r7, #16
    4374:	46bd      	mov	sp, r7
    4376:	bd80      	pop	{r7, pc}
    4378:	00003f75 	.word	0x00003f75
    437c:	20000018 	.word	0x20000018
    4380:	00005dd4 	.word	0x00005dd4
    4384:	00001849 	.word	0x00001849

00004388 <_sercom_i2c_send_stop>:

static inline void _sercom_i2c_send_stop(void *const hw)
{
    4388:	b580      	push	{r7, lr}
    438a:	b082      	sub	sp, #8
    438c:	af00      	add	r7, sp, #0
    438e:	6078      	str	r0, [r7, #4]
	hri_sercomi2cm_set_CTRLB_CMD_bf(hw, CMD_STOP);
    4390:	2103      	movs	r1, #3
    4392:	6878      	ldr	r0, [r7, #4]
    4394:	4b02      	ldr	r3, [pc, #8]	; (43a0 <_sercom_i2c_send_stop+0x18>)
    4396:	4798      	blx	r3
}
    4398:	bf00      	nop
    439a:	3708      	adds	r7, #8
    439c:	46bd      	mov	sp, r7
    439e:	bd80      	pop	{r7, pc}
    43a0:	00003b69 	.word	0x00003b69

000043a4 <_sercom_i2c_sync_analyse_flags>:

/**
 * \brief SERCOM I2CM analyze hardware status and transfer next byte
 */
static inline int32_t _sercom_i2c_sync_analyse_flags(void *const hw, uint32_t flags, struct _i2c_m_msg *const msg)
{
    43a4:	b590      	push	{r4, r7, lr}
    43a6:	b087      	sub	sp, #28
    43a8:	af00      	add	r7, sp, #0
    43aa:	60f8      	str	r0, [r7, #12]
    43ac:	60b9      	str	r1, [r7, #8]
    43ae:	607a      	str	r2, [r7, #4]
	int      sclsm  = hri_sercomi2cm_get_CTRLA_SCLSM_bit(hw);
    43b0:	68f8      	ldr	r0, [r7, #12]
    43b2:	4b7d      	ldr	r3, [pc, #500]	; (45a8 <_sercom_i2c_sync_analyse_flags+0x204>)
    43b4:	4798      	blx	r3
    43b6:	4603      	mov	r3, r0
    43b8:	617b      	str	r3, [r7, #20]
	uint16_t status = hri_sercomi2cm_read_STATUS_reg(hw);
    43ba:	68f8      	ldr	r0, [r7, #12]
    43bc:	4b7b      	ldr	r3, [pc, #492]	; (45ac <_sercom_i2c_sync_analyse_flags+0x208>)
    43be:	4798      	blx	r3
    43c0:	4603      	mov	r3, r0
    43c2:	827b      	strh	r3, [r7, #18]

	if (flags & MB_FLAG) {
    43c4:	68bb      	ldr	r3, [r7, #8]
    43c6:	f003 0301 	and.w	r3, r3, #1
    43ca:	2b00      	cmp	r3, #0
    43cc:	f000 8095 	beq.w	44fa <_sercom_i2c_sync_analyse_flags+0x156>
		/* tx error */
		if (status & SERCOM_I2CM_STATUS_ARBLOST) {
    43d0:	8a7b      	ldrh	r3, [r7, #18]
    43d2:	f003 0302 	and.w	r3, r3, #2
    43d6:	2b00      	cmp	r3, #0
    43d8:	d01d      	beq.n	4416 <_sercom_i2c_sync_analyse_flags+0x72>
			hri_sercomi2cm_clear_interrupt_MB_bit(hw);
    43da:	68f8      	ldr	r0, [r7, #12]
    43dc:	4b74      	ldr	r3, [pc, #464]	; (45b0 <_sercom_i2c_sync_analyse_flags+0x20c>)
    43de:	4798      	blx	r3
			msg->flags |= I2C_M_FAIL;
    43e0:	687b      	ldr	r3, [r7, #4]
    43e2:	885b      	ldrh	r3, [r3, #2]
    43e4:	b29b      	uxth	r3, r3
    43e6:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
    43ea:	b29a      	uxth	r2, r3
    43ec:	687b      	ldr	r3, [r7, #4]
    43ee:	805a      	strh	r2, [r3, #2]
			msg->flags &= ~I2C_M_BUSY;
    43f0:	687b      	ldr	r3, [r7, #4]
    43f2:	885b      	ldrh	r3, [r3, #2]
    43f4:	b29b      	uxth	r3, r3
    43f6:	f423 7380 	bic.w	r3, r3, #256	; 0x100
    43fa:	b29a      	uxth	r2, r3
    43fc:	687b      	ldr	r3, [r7, #4]
    43fe:	805a      	strh	r2, [r3, #2]

			if (status & SERCOM_I2CM_STATUS_BUSERR) {
    4400:	8a7b      	ldrh	r3, [r7, #18]
    4402:	f003 0301 	and.w	r3, r3, #1
    4406:	2b00      	cmp	r3, #0
    4408:	d002      	beq.n	4410 <_sercom_i2c_sync_analyse_flags+0x6c>
				return I2C_ERR_BUS;
    440a:	f06f 0304 	mvn.w	r3, #4
    440e:	e0c6      	b.n	459e <_sercom_i2c_sync_analyse_flags+0x1fa>
			}

			return I2C_ERR_BAD_ADDRESS;
    4410:	f06f 0303 	mvn.w	r3, #3
    4414:	e0c3      	b.n	459e <_sercom_i2c_sync_analyse_flags+0x1fa>
		} else {
			if (status & SERCOM_I2CM_STATUS_RXNACK) {
    4416:	8a7b      	ldrh	r3, [r7, #18]
    4418:	f003 0304 	and.w	r3, r3, #4
    441c:	2b00      	cmp	r3, #0
    441e:	d01f      	beq.n	4460 <_sercom_i2c_sync_analyse_flags+0xbc>

				/* Slave rejects to receive more data */
				if (msg->len > 0) {
    4420:	687b      	ldr	r3, [r7, #4]
    4422:	685b      	ldr	r3, [r3, #4]
    4424:	2b00      	cmp	r3, #0
    4426:	dd07      	ble.n	4438 <_sercom_i2c_sync_analyse_flags+0x94>
					msg->flags |= I2C_M_FAIL;
    4428:	687b      	ldr	r3, [r7, #4]
    442a:	885b      	ldrh	r3, [r3, #2]
    442c:	b29b      	uxth	r3, r3
    442e:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
    4432:	b29a      	uxth	r2, r3
    4434:	687b      	ldr	r3, [r7, #4]
    4436:	805a      	strh	r2, [r3, #2]
				}

				if (msg->flags & I2C_M_STOP) {
    4438:	687b      	ldr	r3, [r7, #4]
    443a:	885b      	ldrh	r3, [r3, #2]
    443c:	b29b      	uxth	r3, r3
    443e:	b21b      	sxth	r3, r3
    4440:	2b00      	cmp	r3, #0
    4442:	da02      	bge.n	444a <_sercom_i2c_sync_analyse_flags+0xa6>
					_sercom_i2c_send_stop(hw);
    4444:	68f8      	ldr	r0, [r7, #12]
    4446:	4b5b      	ldr	r3, [pc, #364]	; (45b4 <_sercom_i2c_sync_analyse_flags+0x210>)
    4448:	4798      	blx	r3
				}

				msg->flags &= ~I2C_M_BUSY;
    444a:	687b      	ldr	r3, [r7, #4]
    444c:	885b      	ldrh	r3, [r3, #2]
    444e:	b29b      	uxth	r3, r3
    4450:	f423 7380 	bic.w	r3, r3, #256	; 0x100
    4454:	b29a      	uxth	r2, r3
    4456:	687b      	ldr	r3, [r7, #4]
    4458:	805a      	strh	r2, [r3, #2]

				return I2C_NACK;
    445a:	f06f 0301 	mvn.w	r3, #1
    445e:	e09e      	b.n	459e <_sercom_i2c_sync_analyse_flags+0x1fa>
			}

			if (msg->flags & I2C_M_TEN) {
    4460:	687b      	ldr	r3, [r7, #4]
    4462:	885b      	ldrh	r3, [r3, #2]
    4464:	b29b      	uxth	r3, r3
    4466:	f403 6380 	and.w	r3, r3, #1024	; 0x400
    446a:	2b00      	cmp	r3, #0
    446c:	d01c      	beq.n	44a8 <_sercom_i2c_sync_analyse_flags+0x104>
				hri_sercomi2cm_write_ADDR_reg(hw,
				                              ((((msg->addr & TEN_ADDR_MASK) >> 8) | TEN_ADDR_FRAME) << 1) | I2C_M_RD
    446e:	687b      	ldr	r3, [r7, #4]
    4470:	881b      	ldrh	r3, [r3, #0]
    4472:	121b      	asrs	r3, r3, #8
    4474:	005b      	lsls	r3, r3, #1
				                                  | (hri_sercomi2cm_read_ADDR_reg(hw) & SERCOM_I2CM_ADDR_HS));
    4476:	f003 0406 	and.w	r4, r3, #6
    447a:	68f8      	ldr	r0, [r7, #12]
    447c:	4b4e      	ldr	r3, [pc, #312]	; (45b8 <_sercom_i2c_sync_analyse_flags+0x214>)
    447e:	4798      	blx	r3
    4480:	4603      	mov	r3, r0
    4482:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
    4486:	4323      	orrs	r3, r4
				hri_sercomi2cm_write_ADDR_reg(hw,
    4488:	f043 03f1 	orr.w	r3, r3, #241	; 0xf1
    448c:	4619      	mov	r1, r3
    448e:	68f8      	ldr	r0, [r7, #12]
    4490:	4b4a      	ldr	r3, [pc, #296]	; (45bc <_sercom_i2c_sync_analyse_flags+0x218>)
    4492:	4798      	blx	r3
				msg->flags &= ~I2C_M_TEN;
    4494:	687b      	ldr	r3, [r7, #4]
    4496:	885b      	ldrh	r3, [r3, #2]
    4498:	b29b      	uxth	r3, r3
    449a:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
    449e:	b29a      	uxth	r2, r3
    44a0:	687b      	ldr	r3, [r7, #4]
    44a2:	805a      	strh	r2, [r3, #2]

				return I2C_OK;
    44a4:	2300      	movs	r3, #0
    44a6:	e07a      	b.n	459e <_sercom_i2c_sync_analyse_flags+0x1fa>
			}

			if (msg->len == 0) {
    44a8:	687b      	ldr	r3, [r7, #4]
    44aa:	685b      	ldr	r3, [r3, #4]
    44ac:	2b00      	cmp	r3, #0
    44ae:	d111      	bne.n	44d4 <_sercom_i2c_sync_analyse_flags+0x130>
				if (msg->flags & I2C_M_STOP) {
    44b0:	687b      	ldr	r3, [r7, #4]
    44b2:	885b      	ldrh	r3, [r3, #2]
    44b4:	b29b      	uxth	r3, r3
    44b6:	b21b      	sxth	r3, r3
    44b8:	2b00      	cmp	r3, #0
    44ba:	da02      	bge.n	44c2 <_sercom_i2c_sync_analyse_flags+0x11e>
					_sercom_i2c_send_stop(hw);
    44bc:	68f8      	ldr	r0, [r7, #12]
    44be:	4b3d      	ldr	r3, [pc, #244]	; (45b4 <_sercom_i2c_sync_analyse_flags+0x210>)
    44c0:	4798      	blx	r3
				}

				msg->flags &= ~I2C_M_BUSY;
    44c2:	687b      	ldr	r3, [r7, #4]
    44c4:	885b      	ldrh	r3, [r3, #2]
    44c6:	b29b      	uxth	r3, r3
    44c8:	f423 7380 	bic.w	r3, r3, #256	; 0x100
    44cc:	b29a      	uxth	r2, r3
    44ce:	687b      	ldr	r3, [r7, #4]
    44d0:	805a      	strh	r2, [r3, #2]
    44d2:	e010      	b.n	44f6 <_sercom_i2c_sync_analyse_flags+0x152>
			} else {
				hri_sercomi2cm_write_DATA_reg(hw, *msg->buffer);
    44d4:	687b      	ldr	r3, [r7, #4]
    44d6:	689b      	ldr	r3, [r3, #8]
    44d8:	781b      	ldrb	r3, [r3, #0]
    44da:	4619      	mov	r1, r3
    44dc:	68f8      	ldr	r0, [r7, #12]
    44de:	4b38      	ldr	r3, [pc, #224]	; (45c0 <_sercom_i2c_sync_analyse_flags+0x21c>)
    44e0:	4798      	blx	r3
				msg->buffer++;
    44e2:	687b      	ldr	r3, [r7, #4]
    44e4:	689b      	ldr	r3, [r3, #8]
    44e6:	1c5a      	adds	r2, r3, #1
    44e8:	687b      	ldr	r3, [r7, #4]
    44ea:	609a      	str	r2, [r3, #8]
				msg->len--;
    44ec:	687b      	ldr	r3, [r7, #4]
    44ee:	685b      	ldr	r3, [r3, #4]
    44f0:	1e5a      	subs	r2, r3, #1
    44f2:	687b      	ldr	r3, [r7, #4]
    44f4:	605a      	str	r2, [r3, #4]
			}

			return I2C_OK;
    44f6:	2300      	movs	r3, #0
    44f8:	e051      	b.n	459e <_sercom_i2c_sync_analyse_flags+0x1fa>
		}
	} else if (flags & SB_FLAG) {
    44fa:	68bb      	ldr	r3, [r7, #8]
    44fc:	f003 0302 	and.w	r3, r3, #2
    4500:	2b00      	cmp	r3, #0
    4502:	d04b      	beq.n	459c <_sercom_i2c_sync_analyse_flags+0x1f8>
		if ((msg->len) && !(status & SERCOM_I2CM_STATUS_RXNACK)) {
    4504:	687b      	ldr	r3, [r7, #4]
    4506:	685b      	ldr	r3, [r3, #4]
    4508:	2b00      	cmp	r3, #0
    450a:	d041      	beq.n	4590 <_sercom_i2c_sync_analyse_flags+0x1ec>
    450c:	8a7b      	ldrh	r3, [r7, #18]
    450e:	f003 0304 	and.w	r3, r3, #4
    4512:	2b00      	cmp	r3, #0
    4514:	d13c      	bne.n	4590 <_sercom_i2c_sync_analyse_flags+0x1ec>
			msg->len--;
    4516:	687b      	ldr	r3, [r7, #4]
    4518:	685b      	ldr	r3, [r3, #4]
    451a:	1e5a      	subs	r2, r3, #1
    451c:	687b      	ldr	r3, [r7, #4]
    451e:	605a      	str	r2, [r3, #4]

			/* last byte, send nack */
			if ((msg->len == 0 && !sclsm) || (msg->len == 1 && sclsm)) {
    4520:	687b      	ldr	r3, [r7, #4]
    4522:	685b      	ldr	r3, [r3, #4]
    4524:	2b00      	cmp	r3, #0
    4526:	d102      	bne.n	452e <_sercom_i2c_sync_analyse_flags+0x18a>
    4528:	697b      	ldr	r3, [r7, #20]
    452a:	2b00      	cmp	r3, #0
    452c:	d006      	beq.n	453c <_sercom_i2c_sync_analyse_flags+0x198>
    452e:	687b      	ldr	r3, [r7, #4]
    4530:	685b      	ldr	r3, [r3, #4]
    4532:	2b01      	cmp	r3, #1
    4534:	d105      	bne.n	4542 <_sercom_i2c_sync_analyse_flags+0x19e>
    4536:	697b      	ldr	r3, [r7, #20]
    4538:	2b00      	cmp	r3, #0
    453a:	d002      	beq.n	4542 <_sercom_i2c_sync_analyse_flags+0x19e>
				hri_sercomi2cm_set_CTRLB_ACKACT_bit(hw);
    453c:	68f8      	ldr	r0, [r7, #12]
    453e:	4b21      	ldr	r3, [pc, #132]	; (45c4 <_sercom_i2c_sync_analyse_flags+0x220>)
    4540:	4798      	blx	r3
			}

			if (msg->len == 0) {
    4542:	687b      	ldr	r3, [r7, #4]
    4544:	685b      	ldr	r3, [r3, #4]
    4546:	2b00      	cmp	r3, #0
    4548:	d113      	bne.n	4572 <_sercom_i2c_sync_analyse_flags+0x1ce>
				if (msg->flags & I2C_M_STOP) {
    454a:	687b      	ldr	r3, [r7, #4]
    454c:	885b      	ldrh	r3, [r3, #2]
    454e:	b29b      	uxth	r3, r3
    4550:	b21b      	sxth	r3, r3
    4552:	2b00      	cmp	r3, #0
    4554:	da05      	bge.n	4562 <_sercom_i2c_sync_analyse_flags+0x1be>
					hri_sercomi2cm_clear_CTRLB_SMEN_bit(hw);
    4556:	68f8      	ldr	r0, [r7, #12]
    4558:	4b1b      	ldr	r3, [pc, #108]	; (45c8 <_sercom_i2c_sync_analyse_flags+0x224>)
    455a:	4798      	blx	r3
					_sercom_i2c_send_stop(hw);
    455c:	68f8      	ldr	r0, [r7, #12]
    455e:	4b15      	ldr	r3, [pc, #84]	; (45b4 <_sercom_i2c_sync_analyse_flags+0x210>)
    4560:	4798      	blx	r3
				}

				msg->flags &= ~I2C_M_BUSY;
    4562:	687b      	ldr	r3, [r7, #4]
    4564:	885b      	ldrh	r3, [r3, #2]
    4566:	b29b      	uxth	r3, r3
    4568:	f423 7380 	bic.w	r3, r3, #256	; 0x100
    456c:	b29a      	uxth	r2, r3
    456e:	687b      	ldr	r3, [r7, #4]
    4570:	805a      	strh	r2, [r3, #2]

			/* Accessing DATA.DATA auto-triggers I2C bus operations.
			 * The operation performed depends on the state of
			 * CTRLB.ACKACT, CTRLB.SMEN
			 **/
			*msg->buffer++ = hri_sercomi2cm_read_DATA_reg(hw);
    4572:	687b      	ldr	r3, [r7, #4]
    4574:	689c      	ldr	r4, [r3, #8]
    4576:	1c62      	adds	r2, r4, #1
    4578:	687b      	ldr	r3, [r7, #4]
    457a:	609a      	str	r2, [r3, #8]
    457c:	68f8      	ldr	r0, [r7, #12]
    457e:	4b13      	ldr	r3, [pc, #76]	; (45cc <_sercom_i2c_sync_analyse_flags+0x228>)
    4580:	4798      	blx	r3
    4582:	4603      	mov	r3, r0
    4584:	b2db      	uxtb	r3, r3
    4586:	7023      	strb	r3, [r4, #0]
		} else {
			hri_sercomi2cm_clear_interrupt_SB_bit(hw);
			return I2C_NACK;
		}

		hri_sercomi2cm_clear_interrupt_SB_bit(hw);
    4588:	68f8      	ldr	r0, [r7, #12]
    458a:	4b11      	ldr	r3, [pc, #68]	; (45d0 <_sercom_i2c_sync_analyse_flags+0x22c>)
    458c:	4798      	blx	r3
    458e:	e005      	b.n	459c <_sercom_i2c_sync_analyse_flags+0x1f8>
			hri_sercomi2cm_clear_interrupt_SB_bit(hw);
    4590:	68f8      	ldr	r0, [r7, #12]
    4592:	4b0f      	ldr	r3, [pc, #60]	; (45d0 <_sercom_i2c_sync_analyse_flags+0x22c>)
    4594:	4798      	blx	r3
			return I2C_NACK;
    4596:	f06f 0301 	mvn.w	r3, #1
    459a:	e000      	b.n	459e <_sercom_i2c_sync_analyse_flags+0x1fa>
	}

	return I2C_OK;
    459c:	2300      	movs	r3, #0
}
    459e:	4618      	mov	r0, r3
    45a0:	371c      	adds	r7, #28
    45a2:	46bd      	mov	sp, r7
    45a4:	bd90      	pop	{r4, r7, pc}
    45a6:	bf00      	nop
    45a8:	000039a1 	.word	0x000039a1
    45ac:	00003dd5 	.word	0x00003dd5
    45b0:	00003789 	.word	0x00003789
    45b4:	00004389 	.word	0x00004389
    45b8:	00003cb9 	.word	0x00003cb9
    45bc:	00003c95 	.word	0x00003c95
    45c0:	00003cd9 	.word	0x00003cd9
    45c4:	00003b19 	.word	0x00003b19
    45c8:	00003af1 	.word	0x00003af1
    45cc:	00003cfd 	.word	0x00003cfd
    45d0:	000037a3 	.word	0x000037a3

000045d4 <_sercom_get_irq_num>:

/**
 * \brief Retrieve IRQ number for the given hardware instance
 */
static uint8_t _sercom_get_irq_num(const void *const hw)
{
    45d4:	b580      	push	{r7, lr}
    45d6:	b082      	sub	sp, #8
    45d8:	af00      	add	r7, sp, #0
    45da:	6078      	str	r0, [r7, #4]
	return SERCOM0_0_IRQn + (_sercom_get_hardware_index(hw) << 2);
    45dc:	6878      	ldr	r0, [r7, #4]
    45de:	4b05      	ldr	r3, [pc, #20]	; (45f4 <_sercom_get_irq_num+0x20>)
    45e0:	4798      	blx	r3
    45e2:	4603      	mov	r3, r0
    45e4:	009b      	lsls	r3, r3, #2
    45e6:	b2db      	uxtb	r3, r3
    45e8:	332e      	adds	r3, #46	; 0x2e
    45ea:	b2db      	uxtb	r3, r3
}
    45ec:	4618      	mov	r0, r3
    45ee:	3708      	adds	r7, #8
    45f0:	46bd      	mov	sp, r7
    45f2:	bd80      	pop	{r7, pc}
    45f4:	00003f75 	.word	0x00003f75

000045f8 <_i2c_m_sync_init>:
 * \brief Initialize sercom i2c module to use in sync mode
 *
 * \param[in] i2c_dev The pointer to i2c device
 */
int32_t _i2c_m_sync_init(struct _i2c_m_sync_device *const i2c_dev, void *const hw)
{
    45f8:	b580      	push	{r7, lr}
    45fa:	b082      	sub	sp, #8
    45fc:	af00      	add	r7, sp, #0
    45fe:	6078      	str	r0, [r7, #4]
    4600:	6039      	str	r1, [r7, #0]
	ASSERT(i2c_dev);
    4602:	687b      	ldr	r3, [r7, #4]
    4604:	2b00      	cmp	r3, #0
    4606:	bf14      	ite	ne
    4608:	2301      	movne	r3, #1
    460a:	2300      	moveq	r3, #0
    460c:	b2db      	uxtb	r3, r3
    460e:	f44f 62a8 	mov.w	r2, #1344	; 0x540
    4612:	4908      	ldr	r1, [pc, #32]	; (4634 <_i2c_m_sync_init+0x3c>)
    4614:	4618      	mov	r0, r3
    4616:	4b08      	ldr	r3, [pc, #32]	; (4638 <_i2c_m_sync_init+0x40>)
    4618:	4798      	blx	r3

	i2c_dev->hw = hw;
    461a:	687b      	ldr	r3, [r7, #4]
    461c:	683a      	ldr	r2, [r7, #0]
    461e:	611a      	str	r2, [r3, #16]

	return _i2c_m_sync_init_impl(&i2c_dev->service, hw);
    4620:	687b      	ldr	r3, [r7, #4]
    4622:	6839      	ldr	r1, [r7, #0]
    4624:	4618      	mov	r0, r3
    4626:	4b05      	ldr	r3, [pc, #20]	; (463c <_i2c_m_sync_init+0x44>)
    4628:	4798      	blx	r3
    462a:	4603      	mov	r3, r0
}
    462c:	4618      	mov	r0, r3
    462e:	3708      	adds	r7, #8
    4630:	46bd      	mov	sp, r7
    4632:	bd80      	pop	{r7, pc}
    4634:	00005dd4 	.word	0x00005dd4
    4638:	00001849 	.word	0x00001849
    463c:	000049b5 	.word	0x000049b5

00004640 <_i2c_m_sync_enable>:
 * \brief Enable the i2c master module
 *
 * \param[in] i2c_dev The pointer to i2c device
 */
int32_t _i2c_m_sync_enable(struct _i2c_m_sync_device *const i2c_dev)
{
    4640:	b580      	push	{r7, lr}
    4642:	b082      	sub	sp, #8
    4644:	af00      	add	r7, sp, #0
    4646:	6078      	str	r0, [r7, #4]
	ASSERT(i2c_dev);
    4648:	687b      	ldr	r3, [r7, #4]
    464a:	2b00      	cmp	r3, #0
    464c:	bf14      	ite	ne
    464e:	2301      	movne	r3, #1
    4650:	2300      	moveq	r3, #0
    4652:	b2db      	uxtb	r3, r3
    4654:	f240 525d 	movw	r2, #1373	; 0x55d
    4658:	4906      	ldr	r1, [pc, #24]	; (4674 <_i2c_m_sync_enable+0x34>)
    465a:	4618      	mov	r0, r3
    465c:	4b06      	ldr	r3, [pc, #24]	; (4678 <_i2c_m_sync_enable+0x38>)
    465e:	4798      	blx	r3

	return _i2c_m_enable_implementation(i2c_dev->hw);
    4660:	687b      	ldr	r3, [r7, #4]
    4662:	691b      	ldr	r3, [r3, #16]
    4664:	4618      	mov	r0, r3
    4666:	4b05      	ldr	r3, [pc, #20]	; (467c <_i2c_m_sync_enable+0x3c>)
    4668:	4798      	blx	r3
    466a:	4603      	mov	r3, r0
}
    466c:	4618      	mov	r0, r3
    466e:	3708      	adds	r7, #8
    4670:	46bd      	mov	sp, r7
    4672:	bd80      	pop	{r7, pc}
    4674:	00005dd4 	.word	0x00005dd4
    4678:	00001849 	.word	0x00001849
    467c:	00004929 	.word	0x00004929

00004680 <_sercom_i2c_sync_wait_bus>:
 * \return Bus response status.
 * \retval 0 Bus response status OK
 * \retval <0 Bus response fail
 */
inline static int32_t _sercom_i2c_sync_wait_bus(struct _i2c_m_sync_device *const i2c_dev, uint32_t *flags)
{
    4680:	b580      	push	{r7, lr}
    4682:	b084      	sub	sp, #16
    4684:	af00      	add	r7, sp, #0
    4686:	6078      	str	r0, [r7, #4]
    4688:	6039      	str	r1, [r7, #0]
	uint32_t timeout = 65535;
    468a:	f64f 73ff 	movw	r3, #65535	; 0xffff
    468e:	60fb      	str	r3, [r7, #12]
	void *   hw      = i2c_dev->hw;
    4690:	687b      	ldr	r3, [r7, #4]
    4692:	691b      	ldr	r3, [r3, #16]
    4694:	60bb      	str	r3, [r7, #8]

	do {
		*flags = hri_sercomi2cm_read_INTFLAG_reg(hw);
    4696:	68b8      	ldr	r0, [r7, #8]
    4698:	4b0f      	ldr	r3, [pc, #60]	; (46d8 <_sercom_i2c_sync_wait_bus+0x58>)
    469a:	4798      	blx	r3
    469c:	4603      	mov	r3, r0
    469e:	461a      	mov	r2, r3
    46a0:	683b      	ldr	r3, [r7, #0]
    46a2:	601a      	str	r2, [r3, #0]

		if (timeout-- == 0) {
    46a4:	68fb      	ldr	r3, [r7, #12]
    46a6:	1e5a      	subs	r2, r3, #1
    46a8:	60fa      	str	r2, [r7, #12]
    46aa:	2b00      	cmp	r3, #0
    46ac:	d102      	bne.n	46b4 <_sercom_i2c_sync_wait_bus+0x34>
			return I2C_ERR_BUS;
    46ae:	f06f 0304 	mvn.w	r3, #4
    46b2:	e00c      	b.n	46ce <_sercom_i2c_sync_wait_bus+0x4e>
		}
	} while (!(*flags & MB_FLAG) && !(*flags & SB_FLAG));
    46b4:	683b      	ldr	r3, [r7, #0]
    46b6:	681b      	ldr	r3, [r3, #0]
    46b8:	f003 0301 	and.w	r3, r3, #1
    46bc:	2b00      	cmp	r3, #0
    46be:	d105      	bne.n	46cc <_sercom_i2c_sync_wait_bus+0x4c>
    46c0:	683b      	ldr	r3, [r7, #0]
    46c2:	681b      	ldr	r3, [r3, #0]
    46c4:	f003 0302 	and.w	r3, r3, #2
    46c8:	2b00      	cmp	r3, #0
    46ca:	d0e4      	beq.n	4696 <_sercom_i2c_sync_wait_bus+0x16>

	return I2C_OK;
    46cc:	2300      	movs	r3, #0
}
    46ce:	4618      	mov	r0, r3
    46d0:	3710      	adds	r7, #16
    46d2:	46bd      	mov	sp, r7
    46d4:	bd80      	pop	{r7, pc}
    46d6:	bf00      	nop
    46d8:	000037bd 	.word	0x000037bd

000046dc <_sercom_i2c_sync_send_address>:
 * \brief Send the slave address to bus, which will start the transfer
 *
 * \param[in] i2c_dev The pointer to i2c device
 */
static int32_t _sercom_i2c_sync_send_address(struct _i2c_m_sync_device *const i2c_dev)
{
    46dc:	b590      	push	{r4, r7, lr}
    46de:	b087      	sub	sp, #28
    46e0:	af00      	add	r7, sp, #0
    46e2:	6078      	str	r0, [r7, #4]
	void *             hw    = i2c_dev->hw;
    46e4:	687b      	ldr	r3, [r7, #4]
    46e6:	691b      	ldr	r3, [r3, #16]
    46e8:	617b      	str	r3, [r7, #20]
	struct _i2c_m_msg *msg   = &i2c_dev->service.msg;
    46ea:	687b      	ldr	r3, [r7, #4]
    46ec:	613b      	str	r3, [r7, #16]
	int                sclsm = hri_sercomi2cm_get_CTRLA_SCLSM_bit(hw);
    46ee:	6978      	ldr	r0, [r7, #20]
    46f0:	4b39      	ldr	r3, [pc, #228]	; (47d8 <_sercom_i2c_sync_send_address+0xfc>)
    46f2:	4798      	blx	r3
    46f4:	4603      	mov	r3, r0
    46f6:	60fb      	str	r3, [r7, #12]
	uint32_t           flags;

	ASSERT(i2c_dev);
    46f8:	687b      	ldr	r3, [r7, #4]
    46fa:	2b00      	cmp	r3, #0
    46fc:	bf14      	ite	ne
    46fe:	2301      	movne	r3, #1
    4700:	2300      	moveq	r3, #0
    4702:	b2db      	uxtb	r3, r3
    4704:	f240 52cd 	movw	r2, #1485	; 0x5cd
    4708:	4934      	ldr	r1, [pc, #208]	; (47dc <_sercom_i2c_sync_send_address+0x100>)
    470a:	4618      	mov	r0, r3
    470c:	4b34      	ldr	r3, [pc, #208]	; (47e0 <_sercom_i2c_sync_send_address+0x104>)
    470e:	4798      	blx	r3

	if (msg->len == 1 && sclsm) {
    4710:	693b      	ldr	r3, [r7, #16]
    4712:	685b      	ldr	r3, [r3, #4]
    4714:	2b01      	cmp	r3, #1
    4716:	d106      	bne.n	4726 <_sercom_i2c_sync_send_address+0x4a>
    4718:	68fb      	ldr	r3, [r7, #12]
    471a:	2b00      	cmp	r3, #0
    471c:	d003      	beq.n	4726 <_sercom_i2c_sync_send_address+0x4a>
		hri_sercomi2cm_set_CTRLB_ACKACT_bit(hw);
    471e:	6978      	ldr	r0, [r7, #20]
    4720:	4b30      	ldr	r3, [pc, #192]	; (47e4 <_sercom_i2c_sync_send_address+0x108>)
    4722:	4798      	blx	r3
    4724:	e002      	b.n	472c <_sercom_i2c_sync_send_address+0x50>
	} else {
		hri_sercomi2cm_clear_CTRLB_ACKACT_bit(hw);
    4726:	6978      	ldr	r0, [r7, #20]
    4728:	4b2f      	ldr	r3, [pc, #188]	; (47e8 <_sercom_i2c_sync_send_address+0x10c>)
    472a:	4798      	blx	r3
	}

	/* ten bit address */
	if (msg->addr & I2C_M_TEN) {
    472c:	693b      	ldr	r3, [r7, #16]
    472e:	881b      	ldrh	r3, [r3, #0]
    4730:	f403 6380 	and.w	r3, r3, #1024	; 0x400
    4734:	2b00      	cmp	r3, #0
    4736:	d022      	beq.n	477e <_sercom_i2c_sync_send_address+0xa2>
		if (msg->flags & I2C_M_RD) {
    4738:	693b      	ldr	r3, [r7, #16]
    473a:	885b      	ldrh	r3, [r3, #2]
    473c:	b29b      	uxth	r3, r3
    473e:	f003 0301 	and.w	r3, r3, #1
    4742:	2b00      	cmp	r3, #0
    4744:	d007      	beq.n	4756 <_sercom_i2c_sync_send_address+0x7a>
			msg->flags |= I2C_M_TEN;
    4746:	693b      	ldr	r3, [r7, #16]
    4748:	885b      	ldrh	r3, [r3, #2]
    474a:	b29b      	uxth	r3, r3
    474c:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
    4750:	b29a      	uxth	r2, r3
    4752:	693b      	ldr	r3, [r7, #16]
    4754:	805a      	strh	r2, [r3, #2]
		}

		hri_sercomi2cm_write_ADDR_reg(hw,
		                              ((msg->addr & TEN_ADDR_MASK) << 1) | SERCOM_I2CM_ADDR_TENBITEN
    4756:	693b      	ldr	r3, [r7, #16]
    4758:	881b      	ldrh	r3, [r3, #0]
    475a:	005b      	lsls	r3, r3, #1
		                                  | (hri_sercomi2cm_read_ADDR_reg(hw) & SERCOM_I2CM_ADDR_HS));
    475c:	f240 74fe 	movw	r4, #2046	; 0x7fe
    4760:	401c      	ands	r4, r3
    4762:	6978      	ldr	r0, [r7, #20]
    4764:	4b21      	ldr	r3, [pc, #132]	; (47ec <_sercom_i2c_sync_send_address+0x110>)
    4766:	4798      	blx	r3
    4768:	4603      	mov	r3, r0
    476a:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
    476e:	4323      	orrs	r3, r4
		hri_sercomi2cm_write_ADDR_reg(hw,
    4770:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
    4774:	4619      	mov	r1, r3
    4776:	6978      	ldr	r0, [r7, #20]
    4778:	4b1d      	ldr	r3, [pc, #116]	; (47f0 <_sercom_i2c_sync_send_address+0x114>)
    477a:	4798      	blx	r3
    477c:	e01a      	b.n	47b4 <_sercom_i2c_sync_send_address+0xd8>
	} else {
		hri_sercomi2cm_write_ADDR_reg(hw,
		                              ((msg->addr & SEVEN_ADDR_MASK) << 1) | (msg->flags & I2C_M_RD ? I2C_M_RD : 0x0)
    477e:	693b      	ldr	r3, [r7, #16]
    4780:	881b      	ldrh	r3, [r3, #0]
    4782:	005b      	lsls	r3, r3, #1
    4784:	b2db      	uxtb	r3, r3
    4786:	693a      	ldr	r2, [r7, #16]
    4788:	8852      	ldrh	r2, [r2, #2]
    478a:	b292      	uxth	r2, r2
    478c:	f002 0201 	and.w	r2, r2, #1
    4790:	2a00      	cmp	r2, #0
    4792:	bf14      	ite	ne
    4794:	2201      	movne	r2, #1
    4796:	2200      	moveq	r2, #0
    4798:	b2d2      	uxtb	r2, r2
    479a:	4313      	orrs	r3, r2
    479c:	461c      	mov	r4, r3
		                                  | (hri_sercomi2cm_read_ADDR_reg(hw) & SERCOM_I2CM_ADDR_HS));
    479e:	6978      	ldr	r0, [r7, #20]
    47a0:	4b12      	ldr	r3, [pc, #72]	; (47ec <_sercom_i2c_sync_send_address+0x110>)
    47a2:	4798      	blx	r3
    47a4:	4603      	mov	r3, r0
    47a6:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
		hri_sercomi2cm_write_ADDR_reg(hw,
    47aa:	4323      	orrs	r3, r4
    47ac:	4619      	mov	r1, r3
    47ae:	6978      	ldr	r0, [r7, #20]
    47b0:	4b0f      	ldr	r3, [pc, #60]	; (47f0 <_sercom_i2c_sync_send_address+0x114>)
    47b2:	4798      	blx	r3
	}

	_sercom_i2c_sync_wait_bus(i2c_dev, &flags);
    47b4:	f107 0308 	add.w	r3, r7, #8
    47b8:	4619      	mov	r1, r3
    47ba:	6878      	ldr	r0, [r7, #4]
    47bc:	4b0d      	ldr	r3, [pc, #52]	; (47f4 <_sercom_i2c_sync_send_address+0x118>)
    47be:	4798      	blx	r3
	return _sercom_i2c_sync_analyse_flags(hw, flags, msg);
    47c0:	68bb      	ldr	r3, [r7, #8]
    47c2:	693a      	ldr	r2, [r7, #16]
    47c4:	4619      	mov	r1, r3
    47c6:	6978      	ldr	r0, [r7, #20]
    47c8:	4b0b      	ldr	r3, [pc, #44]	; (47f8 <_sercom_i2c_sync_send_address+0x11c>)
    47ca:	4798      	blx	r3
    47cc:	4603      	mov	r3, r0
}
    47ce:	4618      	mov	r0, r3
    47d0:	371c      	adds	r7, #28
    47d2:	46bd      	mov	sp, r7
    47d4:	bd90      	pop	{r4, r7, pc}
    47d6:	bf00      	nop
    47d8:	000039a1 	.word	0x000039a1
    47dc:	00005dd4 	.word	0x00005dd4
    47e0:	00001849 	.word	0x00001849
    47e4:	00003b19 	.word	0x00003b19
    47e8:	00003b41 	.word	0x00003b41
    47ec:	00003cb9 	.word	0x00003cb9
    47f0:	00003c95 	.word	0x00003c95
    47f4:	00004681 	.word	0x00004681
    47f8:	000043a5 	.word	0x000043a5

000047fc <_i2c_m_sync_transfer>:
 * \return Transfer status.
 * \retval 0 Transfer success
 * \retval <0 Transfer fail or partial fail, return the error code
 */
int32_t _i2c_m_sync_transfer(struct _i2c_m_sync_device *const i2c_dev, struct _i2c_m_msg *msg)
{
    47fc:	b580      	push	{r7, lr}
    47fe:	b086      	sub	sp, #24
    4800:	af00      	add	r7, sp, #0
    4802:	6078      	str	r0, [r7, #4]
    4804:	6039      	str	r1, [r7, #0]
	uint32_t flags;
	int      ret;
	void *   hw = i2c_dev->hw;
    4806:	687b      	ldr	r3, [r7, #4]
    4808:	691b      	ldr	r3, [r3, #16]
    480a:	613b      	str	r3, [r7, #16]

	ASSERT(i2c_dev);
    480c:	687b      	ldr	r3, [r7, #4]
    480e:	2b00      	cmp	r3, #0
    4810:	bf14      	ite	ne
    4812:	2301      	movne	r3, #1
    4814:	2300      	moveq	r3, #0
    4816:	b2db      	uxtb	r3, r3
    4818:	f44f 62bf 	mov.w	r2, #1528	; 0x5f8
    481c:	493b      	ldr	r1, [pc, #236]	; (490c <_i2c_m_sync_transfer+0x110>)
    481e:	4618      	mov	r0, r3
    4820:	4b3b      	ldr	r3, [pc, #236]	; (4910 <_i2c_m_sync_transfer+0x114>)
    4822:	4798      	blx	r3
	ASSERT(i2c_dev->hw);
    4824:	687b      	ldr	r3, [r7, #4]
    4826:	691b      	ldr	r3, [r3, #16]
    4828:	2b00      	cmp	r3, #0
    482a:	bf14      	ite	ne
    482c:	2301      	movne	r3, #1
    482e:	2300      	moveq	r3, #0
    4830:	b2db      	uxtb	r3, r3
    4832:	f240 52f9 	movw	r2, #1529	; 0x5f9
    4836:	4935      	ldr	r1, [pc, #212]	; (490c <_i2c_m_sync_transfer+0x110>)
    4838:	4618      	mov	r0, r3
    483a:	4b35      	ldr	r3, [pc, #212]	; (4910 <_i2c_m_sync_transfer+0x114>)
    483c:	4798      	blx	r3
	ASSERT(msg);
    483e:	683b      	ldr	r3, [r7, #0]
    4840:	2b00      	cmp	r3, #0
    4842:	bf14      	ite	ne
    4844:	2301      	movne	r3, #1
    4846:	2300      	moveq	r3, #0
    4848:	b2db      	uxtb	r3, r3
    484a:	f240 52fa 	movw	r2, #1530	; 0x5fa
    484e:	492f      	ldr	r1, [pc, #188]	; (490c <_i2c_m_sync_transfer+0x110>)
    4850:	4618      	mov	r0, r3
    4852:	4b2f      	ldr	r3, [pc, #188]	; (4910 <_i2c_m_sync_transfer+0x114>)
    4854:	4798      	blx	r3

	if (i2c_dev->service.msg.flags & I2C_M_BUSY) {
    4856:	687b      	ldr	r3, [r7, #4]
    4858:	885b      	ldrh	r3, [r3, #2]
    485a:	b29b      	uxth	r3, r3
    485c:	f403 7380 	and.w	r3, r3, #256	; 0x100
    4860:	2b00      	cmp	r3, #0
    4862:	d002      	beq.n	486a <_i2c_m_sync_transfer+0x6e>
		return I2C_ERR_BUSY;
    4864:	f06f 0305 	mvn.w	r3, #5
    4868:	e04c      	b.n	4904 <_i2c_m_sync_transfer+0x108>
	}

	msg->flags |= I2C_M_BUSY;
    486a:	683b      	ldr	r3, [r7, #0]
    486c:	885b      	ldrh	r3, [r3, #2]
    486e:	b29b      	uxth	r3, r3
    4870:	f443 7380 	orr.w	r3, r3, #256	; 0x100
    4874:	b29a      	uxth	r2, r3
    4876:	683b      	ldr	r3, [r7, #0]
    4878:	805a      	strh	r2, [r3, #2]
	i2c_dev->service.msg = *msg;
    487a:	687b      	ldr	r3, [r7, #4]
    487c:	683a      	ldr	r2, [r7, #0]
    487e:	ca07      	ldmia	r2, {r0, r1, r2}
    4880:	e883 0007 	stmia.w	r3, {r0, r1, r2}
	hri_sercomi2cm_set_CTRLB_SMEN_bit(hw);
    4884:	6938      	ldr	r0, [r7, #16]
    4886:	4b23      	ldr	r3, [pc, #140]	; (4914 <_i2c_m_sync_transfer+0x118>)
    4888:	4798      	blx	r3

	ret = _sercom_i2c_sync_send_address(i2c_dev);
    488a:	6878      	ldr	r0, [r7, #4]
    488c:	4b22      	ldr	r3, [pc, #136]	; (4918 <_i2c_m_sync_transfer+0x11c>)
    488e:	4798      	blx	r3
    4890:	6178      	str	r0, [r7, #20]

	if (ret) {
    4892:	697b      	ldr	r3, [r7, #20]
    4894:	2b00      	cmp	r3, #0
    4896:	d02d      	beq.n	48f4 <_i2c_m_sync_transfer+0xf8>
		i2c_dev->service.msg.flags &= ~I2C_M_BUSY;
    4898:	687b      	ldr	r3, [r7, #4]
    489a:	885b      	ldrh	r3, [r3, #2]
    489c:	b29b      	uxth	r3, r3
    489e:	f423 7380 	bic.w	r3, r3, #256	; 0x100
    48a2:	b29a      	uxth	r2, r3
    48a4:	687b      	ldr	r3, [r7, #4]
    48a6:	805a      	strh	r2, [r3, #2]

		return ret;
    48a8:	697b      	ldr	r3, [r7, #20]
    48aa:	e02b      	b.n	4904 <_i2c_m_sync_transfer+0x108>
	}

	while (i2c_dev->service.msg.flags & I2C_M_BUSY) {
		ret = _sercom_i2c_sync_wait_bus(i2c_dev, &flags);
    48ac:	f107 030c 	add.w	r3, r7, #12
    48b0:	4619      	mov	r1, r3
    48b2:	6878      	ldr	r0, [r7, #4]
    48b4:	4b19      	ldr	r3, [pc, #100]	; (491c <_i2c_m_sync_transfer+0x120>)
    48b6:	4798      	blx	r3
    48b8:	6178      	str	r0, [r7, #20]

		if (ret) {
    48ba:	697b      	ldr	r3, [r7, #20]
    48bc:	2b00      	cmp	r3, #0
    48be:	d012      	beq.n	48e6 <_i2c_m_sync_transfer+0xea>
			if (msg->flags & I2C_M_STOP) {
    48c0:	683b      	ldr	r3, [r7, #0]
    48c2:	885b      	ldrh	r3, [r3, #2]
    48c4:	b29b      	uxth	r3, r3
    48c6:	b21b      	sxth	r3, r3
    48c8:	2b00      	cmp	r3, #0
    48ca:	da02      	bge.n	48d2 <_i2c_m_sync_transfer+0xd6>
				_sercom_i2c_send_stop(hw);
    48cc:	6938      	ldr	r0, [r7, #16]
    48ce:	4b14      	ldr	r3, [pc, #80]	; (4920 <_i2c_m_sync_transfer+0x124>)
    48d0:	4798      	blx	r3
			}

			i2c_dev->service.msg.flags &= ~I2C_M_BUSY;
    48d2:	687b      	ldr	r3, [r7, #4]
    48d4:	885b      	ldrh	r3, [r3, #2]
    48d6:	b29b      	uxth	r3, r3
    48d8:	f423 7380 	bic.w	r3, r3, #256	; 0x100
    48dc:	b29a      	uxth	r2, r3
    48de:	687b      	ldr	r3, [r7, #4]
    48e0:	805a      	strh	r2, [r3, #2]

			return ret;
    48e2:	697b      	ldr	r3, [r7, #20]
    48e4:	e00e      	b.n	4904 <_i2c_m_sync_transfer+0x108>
		}

		ret = _sercom_i2c_sync_analyse_flags(hw, flags, &i2c_dev->service.msg);
    48e6:	68fb      	ldr	r3, [r7, #12]
    48e8:	687a      	ldr	r2, [r7, #4]
    48ea:	4619      	mov	r1, r3
    48ec:	6938      	ldr	r0, [r7, #16]
    48ee:	4b0d      	ldr	r3, [pc, #52]	; (4924 <_i2c_m_sync_transfer+0x128>)
    48f0:	4798      	blx	r3
    48f2:	6178      	str	r0, [r7, #20]
	while (i2c_dev->service.msg.flags & I2C_M_BUSY) {
    48f4:	687b      	ldr	r3, [r7, #4]
    48f6:	885b      	ldrh	r3, [r3, #2]
    48f8:	b29b      	uxth	r3, r3
    48fa:	f403 7380 	and.w	r3, r3, #256	; 0x100
    48fe:	2b00      	cmp	r3, #0
    4900:	d1d4      	bne.n	48ac <_i2c_m_sync_transfer+0xb0>
	}

	return ret;
    4902:	697b      	ldr	r3, [r7, #20]
}
    4904:	4618      	mov	r0, r3
    4906:	3718      	adds	r7, #24
    4908:	46bd      	mov	sp, r7
    490a:	bd80      	pop	{r7, pc}
    490c:	00005dd4 	.word	0x00005dd4
    4910:	00001849 	.word	0x00001849
    4914:	00003ac9 	.word	0x00003ac9
    4918:	000046dd 	.word	0x000046dd
    491c:	00004681 	.word	0x00004681
    4920:	00004389 	.word	0x00004389
    4924:	000043a5 	.word	0x000043a5

00004928 <_i2c_m_enable_implementation>:

	return I2C_OK;
}

static inline int32_t _i2c_m_enable_implementation(void *const hw)
{
    4928:	b580      	push	{r7, lr}
    492a:	b084      	sub	sp, #16
    492c:	af00      	add	r7, sp, #0
    492e:	6078      	str	r0, [r7, #4]
	int timeout         = 65535;
    4930:	f64f 73ff 	movw	r3, #65535	; 0xffff
    4934:	60fb      	str	r3, [r7, #12]
	int timeout_attempt = 4;
    4936:	2304      	movs	r3, #4
    4938:	60bb      	str	r3, [r7, #8]

	ASSERT(hw);
    493a:	687b      	ldr	r3, [r7, #4]
    493c:	2b00      	cmp	r3, #0
    493e:	bf14      	ite	ne
    4940:	2301      	movne	r3, #1
    4942:	2300      	moveq	r3, #0
    4944:	b2db      	uxtb	r3, r3
    4946:	f240 622d 	movw	r2, #1581	; 0x62d
    494a:	4915      	ldr	r1, [pc, #84]	; (49a0 <_i2c_m_enable_implementation+0x78>)
    494c:	4618      	mov	r0, r3
    494e:	4b15      	ldr	r3, [pc, #84]	; (49a4 <_i2c_m_enable_implementation+0x7c>)
    4950:	4798      	blx	r3

	/* Enable interrupts */
	hri_sercomi2cm_set_CTRLA_ENABLE_bit(hw);
    4952:	6878      	ldr	r0, [r7, #4]
    4954:	4b14      	ldr	r3, [pc, #80]	; (49a8 <_i2c_m_enable_implementation+0x80>)
    4956:	4798      	blx	r3

	while (hri_sercomi2cm_read_STATUS_BUSSTATE_bf(hw) != I2C_IDLE) {
    4958:	e016      	b.n	4988 <_i2c_m_enable_implementation+0x60>
		timeout--;
    495a:	68fb      	ldr	r3, [r7, #12]
    495c:	3b01      	subs	r3, #1
    495e:	60fb      	str	r3, [r7, #12]

		if (timeout <= 0) {
    4960:	68fb      	ldr	r3, [r7, #12]
    4962:	2b00      	cmp	r3, #0
    4964:	dc10      	bgt.n	4988 <_i2c_m_enable_implementation+0x60>
			if (--timeout_attempt)
    4966:	68bb      	ldr	r3, [r7, #8]
    4968:	3b01      	subs	r3, #1
    496a:	60bb      	str	r3, [r7, #8]
    496c:	68bb      	ldr	r3, [r7, #8]
    496e:	2b00      	cmp	r3, #0
    4970:	d007      	beq.n	4982 <_i2c_m_enable_implementation+0x5a>
				timeout = 65535;
    4972:	f64f 73ff 	movw	r3, #65535	; 0xffff
    4976:	60fb      	str	r3, [r7, #12]
			else
				return I2C_ERR_BUSY;
			hri_sercomi2cm_clear_STATUS_reg(hw, SERCOM_I2CM_STATUS_BUSSTATE(I2C_IDLE));
    4978:	2110      	movs	r1, #16
    497a:	6878      	ldr	r0, [r7, #4]
    497c:	4b0b      	ldr	r3, [pc, #44]	; (49ac <_i2c_m_enable_implementation+0x84>)
    497e:	4798      	blx	r3
    4980:	e002      	b.n	4988 <_i2c_m_enable_implementation+0x60>
				return I2C_ERR_BUSY;
    4982:	f06f 0305 	mvn.w	r3, #5
    4986:	e006      	b.n	4996 <_i2c_m_enable_implementation+0x6e>
	while (hri_sercomi2cm_read_STATUS_BUSSTATE_bf(hw) != I2C_IDLE) {
    4988:	6878      	ldr	r0, [r7, #4]
    498a:	4b09      	ldr	r3, [pc, #36]	; (49b0 <_i2c_m_enable_implementation+0x88>)
    498c:	4798      	blx	r3
    498e:	4603      	mov	r3, r0
    4990:	2b01      	cmp	r3, #1
    4992:	d1e2      	bne.n	495a <_i2c_m_enable_implementation+0x32>
		}
	}
	return ERR_NONE;
    4994:	2300      	movs	r3, #0
}
    4996:	4618      	mov	r0, r3
    4998:	3710      	adds	r7, #16
    499a:	46bd      	mov	sp, r7
    499c:	bd80      	pop	{r7, pc}
    499e:	bf00      	nop
    49a0:	00005dd4 	.word	0x00005dd4
    49a4:	00001849 	.word	0x00001849
    49a8:	00003951 	.word	0x00003951
    49ac:	00003df9 	.word	0x00003df9
    49b0:	00003da9 	.word	0x00003da9

000049b4 <_i2c_m_sync_init_impl>:

static int32_t _i2c_m_sync_init_impl(struct _i2c_m_service *const service, void *const hw)
{
    49b4:	b580      	push	{r7, lr}
    49b6:	b084      	sub	sp, #16
    49b8:	af00      	add	r7, sp, #0
    49ba:	6078      	str	r0, [r7, #4]
    49bc:	6039      	str	r1, [r7, #0]
	uint8_t i = _get_i2cm_index(hw);
    49be:	6838      	ldr	r0, [r7, #0]
    49c0:	4b42      	ldr	r3, [pc, #264]	; (4acc <_i2c_m_sync_init_impl+0x118>)
    49c2:	4798      	blx	r3
    49c4:	4603      	mov	r3, r0
    49c6:	73fb      	strb	r3, [r7, #15]

	if (!hri_sercomi2cm_is_syncing(hw, SERCOM_I2CM_SYNCBUSY_SWRST)) {
    49c8:	2101      	movs	r1, #1
    49ca:	6838      	ldr	r0, [r7, #0]
    49cc:	4b40      	ldr	r3, [pc, #256]	; (4ad0 <_i2c_m_sync_init_impl+0x11c>)
    49ce:	4798      	blx	r3
    49d0:	4603      	mov	r3, r0
    49d2:	f083 0301 	eor.w	r3, r3, #1
    49d6:	b2db      	uxtb	r3, r3
    49d8:	2b00      	cmp	r3, #0
    49da:	d020      	beq.n	4a1e <_i2c_m_sync_init_impl+0x6a>
		uint32_t mode = _i2cms[i].ctrl_a & SERCOM_I2CM_CTRLA_MODE_Msk;
    49dc:	7bfa      	ldrb	r2, [r7, #15]
    49de:	493d      	ldr	r1, [pc, #244]	; (4ad4 <_i2c_m_sync_init_impl+0x120>)
    49e0:	4613      	mov	r3, r2
    49e2:	005b      	lsls	r3, r3, #1
    49e4:	4413      	add	r3, r2
    49e6:	00db      	lsls	r3, r3, #3
    49e8:	440b      	add	r3, r1
    49ea:	3304      	adds	r3, #4
    49ec:	681b      	ldr	r3, [r3, #0]
    49ee:	f003 031c 	and.w	r3, r3, #28
    49f2:	60bb      	str	r3, [r7, #8]
		if (hri_sercomi2cm_get_CTRLA_reg(hw, SERCOM_I2CM_CTRLA_ENABLE)) {
    49f4:	2102      	movs	r1, #2
    49f6:	6838      	ldr	r0, [r7, #0]
    49f8:	4b37      	ldr	r3, [pc, #220]	; (4ad8 <_i2c_m_sync_init_impl+0x124>)
    49fa:	4798      	blx	r3
    49fc:	4603      	mov	r3, r0
    49fe:	2b00      	cmp	r3, #0
    4a00:	d006      	beq.n	4a10 <_i2c_m_sync_init_impl+0x5c>
			hri_sercomi2cm_clear_CTRLA_ENABLE_bit(hw);
    4a02:	6838      	ldr	r0, [r7, #0]
    4a04:	4b35      	ldr	r3, [pc, #212]	; (4adc <_i2c_m_sync_init_impl+0x128>)
    4a06:	4798      	blx	r3
			hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_ENABLE);
    4a08:	2102      	movs	r1, #2
    4a0a:	6838      	ldr	r0, [r7, #0]
    4a0c:	4b34      	ldr	r3, [pc, #208]	; (4ae0 <_i2c_m_sync_init_impl+0x12c>)
    4a0e:	4798      	blx	r3
		}
		hri_sercomi2cm_write_CTRLA_reg(hw, SERCOM_I2CM_CTRLA_SWRST | mode);
    4a10:	68bb      	ldr	r3, [r7, #8]
    4a12:	f043 0301 	orr.w	r3, r3, #1
    4a16:	4619      	mov	r1, r3
    4a18:	6838      	ldr	r0, [r7, #0]
    4a1a:	4b32      	ldr	r3, [pc, #200]	; (4ae4 <_i2c_m_sync_init_impl+0x130>)
    4a1c:	4798      	blx	r3
	}
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SWRST);
    4a1e:	2101      	movs	r1, #1
    4a20:	6838      	ldr	r0, [r7, #0]
    4a22:	4b2f      	ldr	r3, [pc, #188]	; (4ae0 <_i2c_m_sync_init_impl+0x12c>)
    4a24:	4798      	blx	r3

	hri_sercomi2cm_write_CTRLA_reg(hw, _i2cms[i].ctrl_a);
    4a26:	7bfa      	ldrb	r2, [r7, #15]
    4a28:	492a      	ldr	r1, [pc, #168]	; (4ad4 <_i2c_m_sync_init_impl+0x120>)
    4a2a:	4613      	mov	r3, r2
    4a2c:	005b      	lsls	r3, r3, #1
    4a2e:	4413      	add	r3, r2
    4a30:	00db      	lsls	r3, r3, #3
    4a32:	440b      	add	r3, r1
    4a34:	3304      	adds	r3, #4
    4a36:	681b      	ldr	r3, [r3, #0]
    4a38:	4619      	mov	r1, r3
    4a3a:	6838      	ldr	r0, [r7, #0]
    4a3c:	4b29      	ldr	r3, [pc, #164]	; (4ae4 <_i2c_m_sync_init_impl+0x130>)
    4a3e:	4798      	blx	r3
	hri_sercomi2cm_write_CTRLB_reg(hw, _i2cms[i].ctrl_b);
    4a40:	7bfa      	ldrb	r2, [r7, #15]
    4a42:	4924      	ldr	r1, [pc, #144]	; (4ad4 <_i2c_m_sync_init_impl+0x120>)
    4a44:	4613      	mov	r3, r2
    4a46:	005b      	lsls	r3, r3, #1
    4a48:	4413      	add	r3, r2
    4a4a:	00db      	lsls	r3, r3, #3
    4a4c:	440b      	add	r3, r1
    4a4e:	3308      	adds	r3, #8
    4a50:	681b      	ldr	r3, [r3, #0]
    4a52:	4619      	mov	r1, r3
    4a54:	6838      	ldr	r0, [r7, #0]
    4a56:	4b24      	ldr	r3, [pc, #144]	; (4ae8 <_i2c_m_sync_init_impl+0x134>)
    4a58:	4798      	blx	r3
	hri_sercomi2cm_write_BAUD_reg(hw, _i2cms[i].baud);
    4a5a:	7bfa      	ldrb	r2, [r7, #15]
    4a5c:	491d      	ldr	r1, [pc, #116]	; (4ad4 <_i2c_m_sync_init_impl+0x120>)
    4a5e:	4613      	mov	r3, r2
    4a60:	005b      	lsls	r3, r3, #1
    4a62:	4413      	add	r3, r2
    4a64:	00db      	lsls	r3, r3, #3
    4a66:	440b      	add	r3, r1
    4a68:	330c      	adds	r3, #12
    4a6a:	681b      	ldr	r3, [r3, #0]
    4a6c:	4619      	mov	r1, r3
    4a6e:	6838      	ldr	r0, [r7, #0]
    4a70:	4b1e      	ldr	r3, [pc, #120]	; (4aec <_i2c_m_sync_init_impl+0x138>)
    4a72:	4798      	blx	r3

	service->mode = (_i2cms[i].ctrl_a & SERCOM_I2CM_CTRLA_SPEED_Msk) >> SERCOM_I2CM_CTRLA_SPEED_Pos;
    4a74:	7bfa      	ldrb	r2, [r7, #15]
    4a76:	4917      	ldr	r1, [pc, #92]	; (4ad4 <_i2c_m_sync_init_impl+0x120>)
    4a78:	4613      	mov	r3, r2
    4a7a:	005b      	lsls	r3, r3, #1
    4a7c:	4413      	add	r3, r2
    4a7e:	00db      	lsls	r3, r3, #3
    4a80:	440b      	add	r3, r1
    4a82:	3304      	adds	r3, #4
    4a84:	681b      	ldr	r3, [r3, #0]
    4a86:	0e1b      	lsrs	r3, r3, #24
    4a88:	b29b      	uxth	r3, r3
    4a8a:	f003 0303 	and.w	r3, r3, #3
    4a8e:	b29a      	uxth	r2, r3
    4a90:	687b      	ldr	r3, [r7, #4]
    4a92:	819a      	strh	r2, [r3, #12]
	hri_sercomi2cm_write_ADDR_HS_bit(hw, service->mode < I2C_HS ? 0 : 1);
    4a94:	687b      	ldr	r3, [r7, #4]
    4a96:	899b      	ldrh	r3, [r3, #12]
    4a98:	2b01      	cmp	r3, #1
    4a9a:	bf8c      	ite	hi
    4a9c:	2301      	movhi	r3, #1
    4a9e:	2300      	movls	r3, #0
    4aa0:	b2db      	uxtb	r3, r3
    4aa2:	4619      	mov	r1, r3
    4aa4:	6838      	ldr	r0, [r7, #0]
    4aa6:	4b12      	ldr	r3, [pc, #72]	; (4af0 <_i2c_m_sync_init_impl+0x13c>)
    4aa8:	4798      	blx	r3

	service->trise = _i2cms[i].trise;
    4aaa:	7bfa      	ldrb	r2, [r7, #15]
    4aac:	4909      	ldr	r1, [pc, #36]	; (4ad4 <_i2c_m_sync_init_impl+0x120>)
    4aae:	4613      	mov	r3, r2
    4ab0:	005b      	lsls	r3, r3, #1
    4ab2:	4413      	add	r3, r2
    4ab4:	00db      	lsls	r3, r3, #3
    4ab6:	440b      	add	r3, r1
    4ab8:	3312      	adds	r3, #18
    4aba:	881a      	ldrh	r2, [r3, #0]
    4abc:	687b      	ldr	r3, [r7, #4]
    4abe:	81da      	strh	r2, [r3, #14]

	return ERR_NONE;
    4ac0:	2300      	movs	r3, #0
}
    4ac2:	4618      	mov	r0, r3
    4ac4:	3710      	adds	r7, #16
    4ac6:	46bd      	mov	sp, r7
    4ac8:	bd80      	pop	{r7, pc}
    4aca:	bf00      	nop
    4acc:	00004321 	.word	0x00004321
    4ad0:	00003715 	.word	0x00003715
    4ad4:	20000018 	.word	0x20000018
    4ad8:	000039d1 	.word	0x000039d1
    4adc:	00003979 	.word	0x00003979
    4ae0:	000036f1 	.word	0x000036f1
    4ae4:	00003a01 	.word	0x00003a01
    4ae8:	00003b99 	.word	0x00003b99
    4aec:	00003bfd 	.word	0x00003bfd
    4af0:	00003c55 	.word	0x00003c55

00004af4 <SERCOM1_0_Handler>:

/**
 * \internal Sercom interrupt handler
 */
void SERCOM1_0_Handler(void)
{
    4af4:	b580      	push	{r7, lr}
    4af6:	af00      	add	r7, sp, #0
	_sercom_usart_interrupt_handler(_sercom1_dev);
    4af8:	4b03      	ldr	r3, [pc, #12]	; (4b08 <SERCOM1_0_Handler+0x14>)
    4afa:	681b      	ldr	r3, [r3, #0]
    4afc:	4618      	mov	r0, r3
    4afe:	4b03      	ldr	r3, [pc, #12]	; (4b0c <SERCOM1_0_Handler+0x18>)
    4b00:	4798      	blx	r3
}
    4b02:	bf00      	nop
    4b04:	bd80      	pop	{r7, pc}
    4b06:	bf00      	nop
    4b08:	20000aa8 	.word	0x20000aa8
    4b0c:	00003fd1 	.word	0x00003fd1

00004b10 <SERCOM1_1_Handler>:
/**
 * \internal Sercom interrupt handler
 */
void SERCOM1_1_Handler(void)
{
    4b10:	b580      	push	{r7, lr}
    4b12:	af00      	add	r7, sp, #0
	_sercom_usart_interrupt_handler(_sercom1_dev);
    4b14:	4b03      	ldr	r3, [pc, #12]	; (4b24 <SERCOM1_1_Handler+0x14>)
    4b16:	681b      	ldr	r3, [r3, #0]
    4b18:	4618      	mov	r0, r3
    4b1a:	4b03      	ldr	r3, [pc, #12]	; (4b28 <SERCOM1_1_Handler+0x18>)
    4b1c:	4798      	blx	r3
}
    4b1e:	bf00      	nop
    4b20:	bd80      	pop	{r7, pc}
    4b22:	bf00      	nop
    4b24:	20000aa8 	.word	0x20000aa8
    4b28:	00003fd1 	.word	0x00003fd1

00004b2c <SERCOM1_2_Handler>:
/**
 * \internal Sercom interrupt handler
 */
void SERCOM1_2_Handler(void)
{
    4b2c:	b580      	push	{r7, lr}
    4b2e:	af00      	add	r7, sp, #0
	_sercom_usart_interrupt_handler(_sercom1_dev);
    4b30:	4b03      	ldr	r3, [pc, #12]	; (4b40 <SERCOM1_2_Handler+0x14>)
    4b32:	681b      	ldr	r3, [r3, #0]
    4b34:	4618      	mov	r0, r3
    4b36:	4b03      	ldr	r3, [pc, #12]	; (4b44 <SERCOM1_2_Handler+0x18>)
    4b38:	4798      	blx	r3
}
    4b3a:	bf00      	nop
    4b3c:	bd80      	pop	{r7, pc}
    4b3e:	bf00      	nop
    4b40:	20000aa8 	.word	0x20000aa8
    4b44:	00003fd1 	.word	0x00003fd1

00004b48 <SERCOM1_3_Handler>:
/**
 * \internal Sercom interrupt handler
 */
void SERCOM1_3_Handler(void)
{
    4b48:	b580      	push	{r7, lr}
    4b4a:	af00      	add	r7, sp, #0
	_sercom_usart_interrupt_handler(_sercom1_dev);
    4b4c:	4b03      	ldr	r3, [pc, #12]	; (4b5c <SERCOM1_3_Handler+0x14>)
    4b4e:	681b      	ldr	r3, [r3, #0]
    4b50:	4618      	mov	r0, r3
    4b52:	4b03      	ldr	r3, [pc, #12]	; (4b60 <SERCOM1_3_Handler+0x18>)
    4b54:	4798      	blx	r3
}
    4b56:	bf00      	nop
    4b58:	bd80      	pop	{r7, pc}
    4b5a:	bf00      	nop
    4b5c:	20000aa8 	.word	0x20000aa8
    4b60:	00003fd1 	.word	0x00003fd1

00004b64 <_system_time_init>:

/**
 * \brief Initialize system time module
 */
void _system_time_init(void *const hw)
{
    4b64:	b480      	push	{r7}
    4b66:	b083      	sub	sp, #12
    4b68:	af00      	add	r7, sp, #0
    4b6a:	6078      	str	r0, [r7, #4]
	(void)hw;
	SysTick->LOAD = (0xFFFFFF << SysTick_LOAD_RELOAD_Pos);
    4b6c:	4b06      	ldr	r3, [pc, #24]	; (4b88 <_system_time_init+0x24>)
    4b6e:	f06f 427f 	mvn.w	r2, #4278190080	; 0xff000000
    4b72:	605a      	str	r2, [r3, #4]
	SysTick->CTRL = (1 << SysTick_CTRL_ENABLE_Pos) | (CONF_SYSTICK_TICKINT << SysTick_CTRL_TICKINT_Pos)
    4b74:	4b04      	ldr	r3, [pc, #16]	; (4b88 <_system_time_init+0x24>)
    4b76:	2205      	movs	r2, #5
    4b78:	601a      	str	r2, [r3, #0]
	                | (1 << SysTick_CTRL_CLKSOURCE_Pos);
}
    4b7a:	bf00      	nop
    4b7c:	370c      	adds	r7, #12
    4b7e:	46bd      	mov	sp, r7
    4b80:	f85d 7b04 	ldr.w	r7, [sp], #4
    4b84:	4770      	bx	lr
    4b86:	bf00      	nop
    4b88:	e000e010 	.word	0xe000e010

00004b8c <_delay_init>:
/**
 * \brief Initialize delay functionality
 */
void _delay_init(void *const hw)
{
    4b8c:	b580      	push	{r7, lr}
    4b8e:	b082      	sub	sp, #8
    4b90:	af00      	add	r7, sp, #0
    4b92:	6078      	str	r0, [r7, #4]
	_system_time_init(hw);
    4b94:	6878      	ldr	r0, [r7, #4]
    4b96:	4b03      	ldr	r3, [pc, #12]	; (4ba4 <_delay_init+0x18>)
    4b98:	4798      	blx	r3
}
    4b9a:	bf00      	nop
    4b9c:	3708      	adds	r7, #8
    4b9e:	46bd      	mov	sp, r7
    4ba0:	bd80      	pop	{r7, pc}
    4ba2:	bf00      	nop
    4ba4:	00004b65 	.word	0x00004b65

00004ba8 <_delay_cycles>:
}
/**
 * \brief Delay loop to delay n number of cycles
 */
void _delay_cycles(void *const hw, uint32_t cycles)
{
    4ba8:	b480      	push	{r7}
    4baa:	b085      	sub	sp, #20
    4bac:	af00      	add	r7, sp, #0
    4bae:	6078      	str	r0, [r7, #4]
    4bb0:	6039      	str	r1, [r7, #0]
	(void)hw;
	uint8_t  n   = cycles >> 24;
    4bb2:	683b      	ldr	r3, [r7, #0]
    4bb4:	0e1b      	lsrs	r3, r3, #24
    4bb6:	73fb      	strb	r3, [r7, #15]
	uint32_t buf = cycles;
    4bb8:	683b      	ldr	r3, [r7, #0]
    4bba:	60bb      	str	r3, [r7, #8]

	while (n--) {
    4bbc:	e013      	b.n	4be6 <_delay_cycles+0x3e>
		SysTick->LOAD = 0xFFFFFF;
    4bbe:	4b16      	ldr	r3, [pc, #88]	; (4c18 <_delay_cycles+0x70>)
    4bc0:	f06f 427f 	mvn.w	r2, #4278190080	; 0xff000000
    4bc4:	605a      	str	r2, [r3, #4]
		SysTick->VAL  = 0xFFFFFF;
    4bc6:	4b14      	ldr	r3, [pc, #80]	; (4c18 <_delay_cycles+0x70>)
    4bc8:	f06f 427f 	mvn.w	r2, #4278190080	; 0xff000000
    4bcc:	609a      	str	r2, [r3, #8]
		while (!(SysTick->CTRL & SysTick_CTRL_COUNTFLAG_Msk))
    4bce:	bf00      	nop
    4bd0:	4b11      	ldr	r3, [pc, #68]	; (4c18 <_delay_cycles+0x70>)
    4bd2:	681b      	ldr	r3, [r3, #0]
    4bd4:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
    4bd8:	2b00      	cmp	r3, #0
    4bda:	d0f9      	beq.n	4bd0 <_delay_cycles+0x28>
			;
		buf -= 0xFFFFFF;
    4bdc:	68bb      	ldr	r3, [r7, #8]
    4bde:	f103 437f 	add.w	r3, r3, #4278190080	; 0xff000000
    4be2:	3301      	adds	r3, #1
    4be4:	60bb      	str	r3, [r7, #8]
	while (n--) {
    4be6:	7bfb      	ldrb	r3, [r7, #15]
    4be8:	1e5a      	subs	r2, r3, #1
    4bea:	73fa      	strb	r2, [r7, #15]
    4bec:	2b00      	cmp	r3, #0
    4bee:	d1e6      	bne.n	4bbe <_delay_cycles+0x16>
	}

	SysTick->LOAD = buf;
    4bf0:	4a09      	ldr	r2, [pc, #36]	; (4c18 <_delay_cycles+0x70>)
    4bf2:	68bb      	ldr	r3, [r7, #8]
    4bf4:	6053      	str	r3, [r2, #4]
	SysTick->VAL  = buf;
    4bf6:	4a08      	ldr	r2, [pc, #32]	; (4c18 <_delay_cycles+0x70>)
    4bf8:	68bb      	ldr	r3, [r7, #8]
    4bfa:	6093      	str	r3, [r2, #8]
	while (!(SysTick->CTRL & SysTick_CTRL_COUNTFLAG_Msk))
    4bfc:	bf00      	nop
    4bfe:	4b06      	ldr	r3, [pc, #24]	; (4c18 <_delay_cycles+0x70>)
    4c00:	681b      	ldr	r3, [r3, #0]
    4c02:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
    4c06:	2b00      	cmp	r3, #0
    4c08:	d0f9      	beq.n	4bfe <_delay_cycles+0x56>
		;
}
    4c0a:	bf00      	nop
    4c0c:	3714      	adds	r7, #20
    4c0e:	46bd      	mov	sp, r7
    4c10:	f85d 7b04 	ldr.w	r7, [sp], #4
    4c14:	4770      	bx	lr
    4c16:	bf00      	nop
    4c18:	e000e010 	.word	0xe000e010

00004c1c <__NVIC_EnableIRQ>:
{
    4c1c:	b480      	push	{r7}
    4c1e:	b083      	sub	sp, #12
    4c20:	af00      	add	r7, sp, #0
    4c22:	4603      	mov	r3, r0
    4c24:	80fb      	strh	r3, [r7, #6]
  if ((int32_t)(IRQn) >= 0)
    4c26:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
    4c2a:	2b00      	cmp	r3, #0
    4c2c:	db0b      	blt.n	4c46 <__NVIC_EnableIRQ+0x2a>
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    4c2e:	4909      	ldr	r1, [pc, #36]	; (4c54 <__NVIC_EnableIRQ+0x38>)
    4c30:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
    4c34:	095b      	lsrs	r3, r3, #5
    4c36:	88fa      	ldrh	r2, [r7, #6]
    4c38:	f002 021f 	and.w	r2, r2, #31
    4c3c:	2001      	movs	r0, #1
    4c3e:	fa00 f202 	lsl.w	r2, r0, r2
    4c42:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    4c46:	bf00      	nop
    4c48:	370c      	adds	r7, #12
    4c4a:	46bd      	mov	sp, r7
    4c4c:	f85d 7b04 	ldr.w	r7, [sp], #4
    4c50:	4770      	bx	lr
    4c52:	bf00      	nop
    4c54:	e000e100 	.word	0xe000e100

00004c58 <__NVIC_DisableIRQ>:
{
    4c58:	b480      	push	{r7}
    4c5a:	b083      	sub	sp, #12
    4c5c:	af00      	add	r7, sp, #0
    4c5e:	4603      	mov	r3, r0
    4c60:	80fb      	strh	r3, [r7, #6]
  if ((int32_t)(IRQn) >= 0)
    4c62:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
    4c66:	2b00      	cmp	r3, #0
    4c68:	db10      	blt.n	4c8c <__NVIC_DisableIRQ+0x34>
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    4c6a:	490b      	ldr	r1, [pc, #44]	; (4c98 <__NVIC_DisableIRQ+0x40>)
    4c6c:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
    4c70:	095b      	lsrs	r3, r3, #5
    4c72:	88fa      	ldrh	r2, [r7, #6]
    4c74:	f002 021f 	and.w	r2, r2, #31
    4c78:	2001      	movs	r0, #1
    4c7a:	fa00 f202 	lsl.w	r2, r0, r2
    4c7e:	3320      	adds	r3, #32
    4c80:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  __ASM volatile ("dsb 0xF":::"memory");
    4c84:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    4c88:	f3bf 8f6f 	isb	sy
}
    4c8c:	bf00      	nop
    4c8e:	370c      	adds	r7, #12
    4c90:	46bd      	mov	sp, r7
    4c92:	f85d 7b04 	ldr.w	r7, [sp], #4
    4c96:	4770      	bx	lr
    4c98:	e000e100 	.word	0xe000e100

00004c9c <__NVIC_ClearPendingIRQ>:
{
    4c9c:	b480      	push	{r7}
    4c9e:	b083      	sub	sp, #12
    4ca0:	af00      	add	r7, sp, #0
    4ca2:	4603      	mov	r3, r0
    4ca4:	80fb      	strh	r3, [r7, #6]
  if ((int32_t)(IRQn) >= 0)
    4ca6:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
    4caa:	2b00      	cmp	r3, #0
    4cac:	db0c      	blt.n	4cc8 <__NVIC_ClearPendingIRQ+0x2c>
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    4cae:	4909      	ldr	r1, [pc, #36]	; (4cd4 <__NVIC_ClearPendingIRQ+0x38>)
    4cb0:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
    4cb4:	095b      	lsrs	r3, r3, #5
    4cb6:	88fa      	ldrh	r2, [r7, #6]
    4cb8:	f002 021f 	and.w	r2, r2, #31
    4cbc:	2001      	movs	r0, #1
    4cbe:	fa00 f202 	lsl.w	r2, r0, r2
    4cc2:	3360      	adds	r3, #96	; 0x60
    4cc4:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    4cc8:	bf00      	nop
    4cca:	370c      	adds	r7, #12
    4ccc:	46bd      	mov	sp, r7
    4cce:	f85d 7b04 	ldr.w	r7, [sp], #4
    4cd2:	4770      	bx	lr
    4cd4:	e000e100 	.word	0xe000e100

00004cd8 <hri_tcc_wait_for_sync>:
typedef uint32_t hri_tcc_wexctrl_reg_t;
typedef uint8_t  hri_tcc_ctrlbset_reg_t;
typedef uint8_t  hri_tcc_dbgctrl_reg_t;

static inline void hri_tcc_wait_for_sync(const void *const hw, hri_tcc_syncbusy_reg_t reg)
{
    4cd8:	b480      	push	{r7}
    4cda:	b083      	sub	sp, #12
    4cdc:	af00      	add	r7, sp, #0
    4cde:	6078      	str	r0, [r7, #4]
    4ce0:	6039      	str	r1, [r7, #0]
	while (((Tcc *)hw)->SYNCBUSY.reg & reg) {
    4ce2:	bf00      	nop
    4ce4:	687b      	ldr	r3, [r7, #4]
    4ce6:	689a      	ldr	r2, [r3, #8]
    4ce8:	683b      	ldr	r3, [r7, #0]
    4cea:	4013      	ands	r3, r2
    4cec:	2b00      	cmp	r3, #0
    4cee:	d1f9      	bne.n	4ce4 <hri_tcc_wait_for_sync+0xc>
	};
}
    4cf0:	bf00      	nop
    4cf2:	370c      	adds	r7, #12
    4cf4:	46bd      	mov	sp, r7
    4cf6:	f85d 7b04 	ldr.w	r7, [sp], #4
    4cfa:	4770      	bx	lr

00004cfc <hri_tcc_is_syncing>:

static inline bool hri_tcc_is_syncing(const void *const hw, hri_tcc_syncbusy_reg_t reg)
{
    4cfc:	b480      	push	{r7}
    4cfe:	b083      	sub	sp, #12
    4d00:	af00      	add	r7, sp, #0
    4d02:	6078      	str	r0, [r7, #4]
    4d04:	6039      	str	r1, [r7, #0]
	return ((Tcc *)hw)->SYNCBUSY.reg & reg;
    4d06:	687b      	ldr	r3, [r7, #4]
    4d08:	689a      	ldr	r2, [r3, #8]
    4d0a:	683b      	ldr	r3, [r7, #0]
    4d0c:	4013      	ands	r3, r2
    4d0e:	2b00      	cmp	r3, #0
    4d10:	bf14      	ite	ne
    4d12:	2301      	movne	r3, #1
    4d14:	2300      	moveq	r3, #0
    4d16:	b2db      	uxtb	r3, r3
}
    4d18:	4618      	mov	r0, r3
    4d1a:	370c      	adds	r7, #12
    4d1c:	46bd      	mov	sp, r7
    4d1e:	f85d 7b04 	ldr.w	r7, [sp], #4
    4d22:	4770      	bx	lr

00004d24 <hri_tcc_get_interrupt_OVF_bit>:
{
	((Tcc *)hw)->INTFLAG.reg = TCC_INTFLAG_MC5;
}

static inline bool hri_tcc_get_interrupt_OVF_bit(const void *const hw)
{
    4d24:	b480      	push	{r7}
    4d26:	b083      	sub	sp, #12
    4d28:	af00      	add	r7, sp, #0
    4d2a:	6078      	str	r0, [r7, #4]
	return (((Tcc *)hw)->INTFLAG.reg & TCC_INTFLAG_OVF) >> TCC_INTFLAG_OVF_Pos;
    4d2c:	687b      	ldr	r3, [r7, #4]
    4d2e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    4d30:	f003 0301 	and.w	r3, r3, #1
    4d34:	2b00      	cmp	r3, #0
    4d36:	bf14      	ite	ne
    4d38:	2301      	movne	r3, #1
    4d3a:	2300      	moveq	r3, #0
    4d3c:	b2db      	uxtb	r3, r3
}
    4d3e:	4618      	mov	r0, r3
    4d40:	370c      	adds	r7, #12
    4d42:	46bd      	mov	sp, r7
    4d44:	f85d 7b04 	ldr.w	r7, [sp], #4
    4d48:	4770      	bx	lr

00004d4a <hri_tcc_clear_interrupt_OVF_bit>:

static inline void hri_tcc_clear_interrupt_OVF_bit(const void *const hw)
{
    4d4a:	b480      	push	{r7}
    4d4c:	b083      	sub	sp, #12
    4d4e:	af00      	add	r7, sp, #0
    4d50:	6078      	str	r0, [r7, #4]
	((Tcc *)hw)->INTFLAG.reg = TCC_INTFLAG_OVF;
    4d52:	687b      	ldr	r3, [r7, #4]
    4d54:	2201      	movs	r2, #1
    4d56:	62da      	str	r2, [r3, #44]	; 0x2c
}
    4d58:	bf00      	nop
    4d5a:	370c      	adds	r7, #12
    4d5c:	46bd      	mov	sp, r7
    4d5e:	f85d 7b04 	ldr.w	r7, [sp], #4
    4d62:	4770      	bx	lr

00004d64 <hri_tcc_clear_interrupt_ERR_bit>:
{
	return (((Tcc *)hw)->INTFLAG.reg & TCC_INTFLAG_ERR) >> TCC_INTFLAG_ERR_Pos;
}

static inline void hri_tcc_clear_interrupt_ERR_bit(const void *const hw)
{
    4d64:	b480      	push	{r7}
    4d66:	b083      	sub	sp, #12
    4d68:	af00      	add	r7, sp, #0
    4d6a:	6078      	str	r0, [r7, #4]
	((Tcc *)hw)->INTFLAG.reg = TCC_INTFLAG_ERR;
    4d6c:	687b      	ldr	r3, [r7, #4]
    4d6e:	2208      	movs	r2, #8
    4d70:	62da      	str	r2, [r3, #44]	; 0x2c
}
    4d72:	bf00      	nop
    4d74:	370c      	adds	r7, #12
    4d76:	46bd      	mov	sp, r7
    4d78:	f85d 7b04 	ldr.w	r7, [sp], #4
    4d7c:	4770      	bx	lr

00004d7e <hri_tcc_clear_CTRLB_LUPD_bit>:
		((Tcc *)hw)->CTRLBSET.reg = TCC_CTRLBSET_LUPD;
	}
}

static inline void hri_tcc_clear_CTRLB_LUPD_bit(const void *const hw)
{
    4d7e:	b480      	push	{r7}
    4d80:	b083      	sub	sp, #12
    4d82:	af00      	add	r7, sp, #0
    4d84:	6078      	str	r0, [r7, #4]
	((Tcc *)hw)->CTRLBCLR.reg = TCC_CTRLBSET_LUPD;
    4d86:	687b      	ldr	r3, [r7, #4]
    4d88:	2202      	movs	r2, #2
    4d8a:	711a      	strb	r2, [r3, #4]
}
    4d8c:	bf00      	nop
    4d8e:	370c      	adds	r7, #12
    4d90:	46bd      	mov	sp, r7
    4d92:	f85d 7b04 	ldr.w	r7, [sp], #4
    4d96:	4770      	bx	lr

00004d98 <hri_tcc_set_CTRLB_reg>:
{
	((Tcc *)hw)->CTRLBCLR.reg = TCC_CTRLBSET_CMD(mask);
}

static inline void hri_tcc_set_CTRLB_reg(const void *const hw, hri_tcc_ctrlbset_reg_t mask)
{
    4d98:	b480      	push	{r7}
    4d9a:	b083      	sub	sp, #12
    4d9c:	af00      	add	r7, sp, #0
    4d9e:	6078      	str	r0, [r7, #4]
    4da0:	460b      	mov	r3, r1
    4da2:	70fb      	strb	r3, [r7, #3]
	((Tcc *)hw)->CTRLBSET.reg = mask;
    4da4:	687b      	ldr	r3, [r7, #4]
    4da6:	78fa      	ldrb	r2, [r7, #3]
    4da8:	715a      	strb	r2, [r3, #5]
}
    4daa:	bf00      	nop
    4dac:	370c      	adds	r7, #12
    4dae:	46bd      	mov	sp, r7
    4db0:	f85d 7b04 	ldr.w	r7, [sp], #4
    4db4:	4770      	bx	lr

00004db6 <hri_tcc_get_INTEN_ERR_bit>:
{
	((Tcc *)hw)->INTENSET.reg = TCC_INTENSET_ERR;
}

static inline bool hri_tcc_get_INTEN_ERR_bit(const void *const hw)
{
    4db6:	b480      	push	{r7}
    4db8:	b083      	sub	sp, #12
    4dba:	af00      	add	r7, sp, #0
    4dbc:	6078      	str	r0, [r7, #4]
	return (((Tcc *)hw)->INTENSET.reg & TCC_INTENSET_ERR) >> TCC_INTENSET_ERR_Pos;
    4dbe:	687b      	ldr	r3, [r7, #4]
    4dc0:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    4dc2:	08db      	lsrs	r3, r3, #3
    4dc4:	f003 0301 	and.w	r3, r3, #1
    4dc8:	2b00      	cmp	r3, #0
    4dca:	bf14      	ite	ne
    4dcc:	2301      	movne	r3, #1
    4dce:	2300      	moveq	r3, #0
    4dd0:	b2db      	uxtb	r3, r3
}
    4dd2:	4618      	mov	r0, r3
    4dd4:	370c      	adds	r7, #12
    4dd6:	46bd      	mov	sp, r7
    4dd8:	f85d 7b04 	ldr.w	r7, [sp], #4
    4ddc:	4770      	bx	lr
	...

00004de0 <hri_tcc_set_CTRLA_ENABLE_bit>:
	tmp = (tmp & TCC_CTRLA_SWRST) >> TCC_CTRLA_SWRST_Pos;
	return (bool)tmp;
}

static inline void hri_tcc_set_CTRLA_ENABLE_bit(const void *const hw)
{
    4de0:	b580      	push	{r7, lr}
    4de2:	b082      	sub	sp, #8
    4de4:	af00      	add	r7, sp, #0
    4de6:	6078      	str	r0, [r7, #4]
	TCC_CRITICAL_SECTION_ENTER();
	((Tcc *)hw)->CTRLA.reg |= TCC_CTRLA_ENABLE;
    4de8:	687b      	ldr	r3, [r7, #4]
    4dea:	681b      	ldr	r3, [r3, #0]
    4dec:	f043 0202 	orr.w	r2, r3, #2
    4df0:	687b      	ldr	r3, [r7, #4]
    4df2:	601a      	str	r2, [r3, #0]
	hri_tcc_wait_for_sync(hw, TCC_SYNCBUSY_SWRST | TCC_SYNCBUSY_ENABLE);
    4df4:	2103      	movs	r1, #3
    4df6:	6878      	ldr	r0, [r7, #4]
    4df8:	4b02      	ldr	r3, [pc, #8]	; (4e04 <hri_tcc_set_CTRLA_ENABLE_bit+0x24>)
    4dfa:	4798      	blx	r3
	TCC_CRITICAL_SECTION_LEAVE();
}
    4dfc:	bf00      	nop
    4dfe:	3708      	adds	r7, #8
    4e00:	46bd      	mov	sp, r7
    4e02:	bd80      	pop	{r7, pc}
    4e04:	00004cd9 	.word	0x00004cd9

00004e08 <hri_tcc_get_CTRLA_ENABLE_bit>:

static inline bool hri_tcc_get_CTRLA_ENABLE_bit(const void *const hw)
{
    4e08:	b580      	push	{r7, lr}
    4e0a:	b084      	sub	sp, #16
    4e0c:	af00      	add	r7, sp, #0
    4e0e:	6078      	str	r0, [r7, #4]
	uint32_t tmp;
	hri_tcc_wait_for_sync(hw, TCC_SYNCBUSY_SWRST | TCC_SYNCBUSY_ENABLE);
    4e10:	2103      	movs	r1, #3
    4e12:	6878      	ldr	r0, [r7, #4]
    4e14:	4b09      	ldr	r3, [pc, #36]	; (4e3c <hri_tcc_get_CTRLA_ENABLE_bit+0x34>)
    4e16:	4798      	blx	r3
	tmp = ((Tcc *)hw)->CTRLA.reg;
    4e18:	687b      	ldr	r3, [r7, #4]
    4e1a:	681b      	ldr	r3, [r3, #0]
    4e1c:	60fb      	str	r3, [r7, #12]
	tmp = (tmp & TCC_CTRLA_ENABLE) >> TCC_CTRLA_ENABLE_Pos;
    4e1e:	68fb      	ldr	r3, [r7, #12]
    4e20:	085b      	lsrs	r3, r3, #1
    4e22:	f003 0301 	and.w	r3, r3, #1
    4e26:	60fb      	str	r3, [r7, #12]
	return (bool)tmp;
    4e28:	68fb      	ldr	r3, [r7, #12]
    4e2a:	2b00      	cmp	r3, #0
    4e2c:	bf14      	ite	ne
    4e2e:	2301      	movne	r3, #1
    4e30:	2300      	moveq	r3, #0
    4e32:	b2db      	uxtb	r3, r3
}
    4e34:	4618      	mov	r0, r3
    4e36:	3710      	adds	r7, #16
    4e38:	46bd      	mov	sp, r7
    4e3a:	bd80      	pop	{r7, pc}
    4e3c:	00004cd9 	.word	0x00004cd9

00004e40 <hri_tcc_clear_CTRLA_ENABLE_bit>:
	hri_tcc_wait_for_sync(hw, TCC_SYNCBUSY_SWRST | TCC_SYNCBUSY_ENABLE);
	TCC_CRITICAL_SECTION_LEAVE();
}

static inline void hri_tcc_clear_CTRLA_ENABLE_bit(const void *const hw)
{
    4e40:	b580      	push	{r7, lr}
    4e42:	b082      	sub	sp, #8
    4e44:	af00      	add	r7, sp, #0
    4e46:	6078      	str	r0, [r7, #4]
	TCC_CRITICAL_SECTION_ENTER();
	((Tcc *)hw)->CTRLA.reg &= ~TCC_CTRLA_ENABLE;
    4e48:	687b      	ldr	r3, [r7, #4]
    4e4a:	681b      	ldr	r3, [r3, #0]
    4e4c:	f023 0202 	bic.w	r2, r3, #2
    4e50:	687b      	ldr	r3, [r7, #4]
    4e52:	601a      	str	r2, [r3, #0]
	hri_tcc_wait_for_sync(hw, TCC_SYNCBUSY_SWRST | TCC_SYNCBUSY_ENABLE);
    4e54:	2103      	movs	r1, #3
    4e56:	6878      	ldr	r0, [r7, #4]
    4e58:	4b02      	ldr	r3, [pc, #8]	; (4e64 <hri_tcc_clear_CTRLA_ENABLE_bit+0x24>)
    4e5a:	4798      	blx	r3
	TCC_CRITICAL_SECTION_LEAVE();
}
    4e5c:	bf00      	nop
    4e5e:	3708      	adds	r7, #8
    4e60:	46bd      	mov	sp, r7
    4e62:	bd80      	pop	{r7, pc}
    4e64:	00004cd9 	.word	0x00004cd9

00004e68 <hri_tcc_get_CTRLA_reg>:
	hri_tcc_wait_for_sync(hw, TCC_SYNCBUSY_SWRST | TCC_SYNCBUSY_ENABLE);
	TCC_CRITICAL_SECTION_LEAVE();
}

static inline hri_tcc_ctrla_reg_t hri_tcc_get_CTRLA_reg(const void *const hw, hri_tcc_ctrla_reg_t mask)
{
    4e68:	b580      	push	{r7, lr}
    4e6a:	b084      	sub	sp, #16
    4e6c:	af00      	add	r7, sp, #0
    4e6e:	6078      	str	r0, [r7, #4]
    4e70:	6039      	str	r1, [r7, #0]
	uint32_t tmp;
	hri_tcc_wait_for_sync(hw, TCC_SYNCBUSY_SWRST | TCC_SYNCBUSY_ENABLE);
    4e72:	2103      	movs	r1, #3
    4e74:	6878      	ldr	r0, [r7, #4]
    4e76:	4b07      	ldr	r3, [pc, #28]	; (4e94 <hri_tcc_get_CTRLA_reg+0x2c>)
    4e78:	4798      	blx	r3
	tmp = ((Tcc *)hw)->CTRLA.reg;
    4e7a:	687b      	ldr	r3, [r7, #4]
    4e7c:	681b      	ldr	r3, [r3, #0]
    4e7e:	60fb      	str	r3, [r7, #12]
	tmp &= mask;
    4e80:	68fa      	ldr	r2, [r7, #12]
    4e82:	683b      	ldr	r3, [r7, #0]
    4e84:	4013      	ands	r3, r2
    4e86:	60fb      	str	r3, [r7, #12]
	return tmp;
    4e88:	68fb      	ldr	r3, [r7, #12]
}
    4e8a:	4618      	mov	r0, r3
    4e8c:	3710      	adds	r7, #16
    4e8e:	46bd      	mov	sp, r7
    4e90:	bd80      	pop	{r7, pc}
    4e92:	bf00      	nop
    4e94:	00004cd9 	.word	0x00004cd9

00004e98 <hri_tcc_write_CTRLA_reg>:

static inline void hri_tcc_write_CTRLA_reg(const void *const hw, hri_tcc_ctrla_reg_t data)
{
    4e98:	b580      	push	{r7, lr}
    4e9a:	b082      	sub	sp, #8
    4e9c:	af00      	add	r7, sp, #0
    4e9e:	6078      	str	r0, [r7, #4]
    4ea0:	6039      	str	r1, [r7, #0]
	TCC_CRITICAL_SECTION_ENTER();
	((Tcc *)hw)->CTRLA.reg = data;
    4ea2:	687b      	ldr	r3, [r7, #4]
    4ea4:	683a      	ldr	r2, [r7, #0]
    4ea6:	601a      	str	r2, [r3, #0]
	hri_tcc_wait_for_sync(hw, TCC_SYNCBUSY_SWRST | TCC_SYNCBUSY_ENABLE);
    4ea8:	2103      	movs	r1, #3
    4eaa:	6878      	ldr	r0, [r7, #4]
    4eac:	4b02      	ldr	r3, [pc, #8]	; (4eb8 <hri_tcc_write_CTRLA_reg+0x20>)
    4eae:	4798      	blx	r3
	TCC_CRITICAL_SECTION_LEAVE();
}
    4eb0:	bf00      	nop
    4eb2:	3708      	adds	r7, #8
    4eb4:	46bd      	mov	sp, r7
    4eb6:	bd80      	pop	{r7, pc}
    4eb8:	00004cd9 	.word	0x00004cd9

00004ebc <hri_tcc_write_DBGCTRL_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_tcc_write_DBGCTRL_reg(const void *const hw, hri_tcc_dbgctrl_reg_t data)
{
    4ebc:	b480      	push	{r7}
    4ebe:	b083      	sub	sp, #12
    4ec0:	af00      	add	r7, sp, #0
    4ec2:	6078      	str	r0, [r7, #4]
    4ec4:	460b      	mov	r3, r1
    4ec6:	70fb      	strb	r3, [r7, #3]
	TCC_CRITICAL_SECTION_ENTER();
	((Tcc *)hw)->DBGCTRL.reg = data;
    4ec8:	687b      	ldr	r3, [r7, #4]
    4eca:	78fa      	ldrb	r2, [r7, #3]
    4ecc:	779a      	strb	r2, [r3, #30]
	TCC_CRITICAL_SECTION_LEAVE();
}
    4ece:	bf00      	nop
    4ed0:	370c      	adds	r7, #12
    4ed2:	46bd      	mov	sp, r7
    4ed4:	f85d 7b04 	ldr.w	r7, [sp], #4
    4ed8:	4770      	bx	lr

00004eda <hri_tcc_write_EVCTRL_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_tcc_write_EVCTRL_reg(const void *const hw, hri_tcc_evctrl_reg_t data)
{
    4eda:	b480      	push	{r7}
    4edc:	b083      	sub	sp, #12
    4ede:	af00      	add	r7, sp, #0
    4ee0:	6078      	str	r0, [r7, #4]
    4ee2:	6039      	str	r1, [r7, #0]
	TCC_CRITICAL_SECTION_ENTER();
	((Tcc *)hw)->EVCTRL.reg = data;
    4ee4:	687b      	ldr	r3, [r7, #4]
    4ee6:	683a      	ldr	r2, [r7, #0]
    4ee8:	621a      	str	r2, [r3, #32]
	TCC_CRITICAL_SECTION_LEAVE();
}
    4eea:	bf00      	nop
    4eec:	370c      	adds	r7, #12
    4eee:	46bd      	mov	sp, r7
    4ef0:	f85d 7b04 	ldr.w	r7, [sp], #4
    4ef4:	4770      	bx	lr
	...

00004ef8 <hri_tcc_write_WAVE_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_tcc_write_WAVE_reg(const void *const hw, hri_tcc_wave_reg_t data)
{
    4ef8:	b580      	push	{r7, lr}
    4efa:	b082      	sub	sp, #8
    4efc:	af00      	add	r7, sp, #0
    4efe:	6078      	str	r0, [r7, #4]
    4f00:	6039      	str	r1, [r7, #0]
	TCC_CRITICAL_SECTION_ENTER();
	((Tcc *)hw)->WAVE.reg = data;
    4f02:	687b      	ldr	r3, [r7, #4]
    4f04:	683a      	ldr	r2, [r7, #0]
    4f06:	63da      	str	r2, [r3, #60]	; 0x3c
	hri_tcc_wait_for_sync(hw, TCC_SYNCBUSY_MASK);
    4f08:	f643 71ff 	movw	r1, #16383	; 0x3fff
    4f0c:	6878      	ldr	r0, [r7, #4]
    4f0e:	4b03      	ldr	r3, [pc, #12]	; (4f1c <hri_tcc_write_WAVE_reg+0x24>)
    4f10:	4798      	blx	r3
	TCC_CRITICAL_SECTION_LEAVE();
}
    4f12:	bf00      	nop
    4f14:	3708      	adds	r7, #8
    4f16:	46bd      	mov	sp, r7
    4f18:	bd80      	pop	{r7, pc}
    4f1a:	bf00      	nop
    4f1c:	00004cd9 	.word	0x00004cd9

00004f20 <hri_tcc_write_PER_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_tcc_write_PER_reg(const void *const hw, hri_tcc_per_reg_t data)
{
    4f20:	b580      	push	{r7, lr}
    4f22:	b082      	sub	sp, #8
    4f24:	af00      	add	r7, sp, #0
    4f26:	6078      	str	r0, [r7, #4]
    4f28:	6039      	str	r1, [r7, #0]
	TCC_CRITICAL_SECTION_ENTER();
	((Tcc *)hw)->PER.reg = data;
    4f2a:	687b      	ldr	r3, [r7, #4]
    4f2c:	683a      	ldr	r2, [r7, #0]
    4f2e:	641a      	str	r2, [r3, #64]	; 0x40
	hri_tcc_wait_for_sync(hw, TCC_SYNCBUSY_PER);
    4f30:	2180      	movs	r1, #128	; 0x80
    4f32:	6878      	ldr	r0, [r7, #4]
    4f34:	4b02      	ldr	r3, [pc, #8]	; (4f40 <hri_tcc_write_PER_reg+0x20>)
    4f36:	4798      	blx	r3
	TCC_CRITICAL_SECTION_LEAVE();
}
    4f38:	bf00      	nop
    4f3a:	3708      	adds	r7, #8
    4f3c:	46bd      	mov	sp, r7
    4f3e:	bd80      	pop	{r7, pc}
    4f40:	00004cd9 	.word	0x00004cd9

00004f44 <hri_tcc_write_CC_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_tcc_write_CC_reg(const void *const hw, uint8_t index, hri_tcc_cc_reg_t data)
{
    4f44:	b580      	push	{r7, lr}
    4f46:	b084      	sub	sp, #16
    4f48:	af00      	add	r7, sp, #0
    4f4a:	60f8      	str	r0, [r7, #12]
    4f4c:	460b      	mov	r3, r1
    4f4e:	607a      	str	r2, [r7, #4]
    4f50:	72fb      	strb	r3, [r7, #11]
	TCC_CRITICAL_SECTION_ENTER();
	((Tcc *)hw)->CC[index].reg = data;
    4f52:	7afb      	ldrb	r3, [r7, #11]
    4f54:	68fa      	ldr	r2, [r7, #12]
    4f56:	3310      	adds	r3, #16
    4f58:	009b      	lsls	r3, r3, #2
    4f5a:	4413      	add	r3, r2
    4f5c:	687a      	ldr	r2, [r7, #4]
    4f5e:	605a      	str	r2, [r3, #4]
	hri_tcc_wait_for_sync(hw,
    4f60:	f44f 517c 	mov.w	r1, #16128	; 0x3f00
    4f64:	68f8      	ldr	r0, [r7, #12]
    4f66:	4b03      	ldr	r3, [pc, #12]	; (4f74 <hri_tcc_write_CC_reg+0x30>)
    4f68:	4798      	blx	r3
	                      TCC_SYNCBUSY_CC0 | TCC_SYNCBUSY_CC1 | TCC_SYNCBUSY_CC2 | TCC_SYNCBUSY_CC3 | TCC_SYNCBUSY_CC4
	                          | TCC_SYNCBUSY_CC5);
	TCC_CRITICAL_SECTION_LEAVE();
}
    4f6a:	bf00      	nop
    4f6c:	3710      	adds	r7, #16
    4f6e:	46bd      	mov	sp, r7
    4f70:	bd80      	pop	{r7, pc}
    4f72:	bf00      	nop
    4f74:	00004cd9 	.word	0x00004cd9

00004f78 <hri_tcc_write_PERBUF_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_tcc_write_PERBUF_reg(const void *const hw, hri_tcc_perbuf_reg_t data)
{
    4f78:	b480      	push	{r7}
    4f7a:	b083      	sub	sp, #12
    4f7c:	af00      	add	r7, sp, #0
    4f7e:	6078      	str	r0, [r7, #4]
    4f80:	6039      	str	r1, [r7, #0]
	TCC_CRITICAL_SECTION_ENTER();
	((Tcc *)hw)->PERBUF.reg = data;
    4f82:	687b      	ldr	r3, [r7, #4]
    4f84:	683a      	ldr	r2, [r7, #0]
    4f86:	66da      	str	r2, [r3, #108]	; 0x6c
	TCC_CRITICAL_SECTION_LEAVE();
}
    4f88:	bf00      	nop
    4f8a:	370c      	adds	r7, #12
    4f8c:	46bd      	mov	sp, r7
    4f8e:	f85d 7b04 	ldr.w	r7, [sp], #4
    4f92:	4770      	bx	lr

00004f94 <hri_tcc_write_CCBUF_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_tcc_write_CCBUF_reg(const void *const hw, uint8_t index, hri_tcc_ccbuf_reg_t data)
{
    4f94:	b480      	push	{r7}
    4f96:	b085      	sub	sp, #20
    4f98:	af00      	add	r7, sp, #0
    4f9a:	60f8      	str	r0, [r7, #12]
    4f9c:	460b      	mov	r3, r1
    4f9e:	607a      	str	r2, [r7, #4]
    4fa0:	72fb      	strb	r3, [r7, #11]
	TCC_CRITICAL_SECTION_ENTER();
	((Tcc *)hw)->CCBUF[index].reg = data;
    4fa2:	7afa      	ldrb	r2, [r7, #11]
    4fa4:	68fb      	ldr	r3, [r7, #12]
    4fa6:	321c      	adds	r2, #28
    4fa8:	6879      	ldr	r1, [r7, #4]
    4faa:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
	TCC_CRITICAL_SECTION_LEAVE();
}
    4fae:	bf00      	nop
    4fb0:	3714      	adds	r7, #20
    4fb2:	46bd      	mov	sp, r7
    4fb4:	f85d 7b04 	ldr.w	r7, [sp], #4
    4fb8:	4770      	bx	lr
	...

00004fbc <_tcc_init_irq_param>:

/**
 * \brief Init irq param with the given tcc hardware instance
 */
static void _tcc_init_irq_param(const void *const hw, void *dev)
{
    4fbc:	b480      	push	{r7}
    4fbe:	b083      	sub	sp, #12
    4fc0:	af00      	add	r7, sp, #0
    4fc2:	6078      	str	r0, [r7, #4]
    4fc4:	6039      	str	r1, [r7, #0]
	if (hw == TCC0) {
    4fc6:	687b      	ldr	r3, [r7, #4]
    4fc8:	4a05      	ldr	r2, [pc, #20]	; (4fe0 <_tcc_init_irq_param+0x24>)
    4fca:	4293      	cmp	r3, r2
    4fcc:	d102      	bne.n	4fd4 <_tcc_init_irq_param+0x18>
		_tcc0_dev = (struct _pwm_device *)dev;
    4fce:	4a05      	ldr	r2, [pc, #20]	; (4fe4 <_tcc_init_irq_param+0x28>)
    4fd0:	683b      	ldr	r3, [r7, #0]
    4fd2:	6013      	str	r3, [r2, #0]
	}
}
    4fd4:	bf00      	nop
    4fd6:	370c      	adds	r7, #12
    4fd8:	46bd      	mov	sp, r7
    4fda:	f85d 7b04 	ldr.w	r7, [sp], #4
    4fde:	4770      	bx	lr
    4fe0:	41016000 	.word	0x41016000
    4fe4:	20000abc 	.word	0x20000abc

00004fe8 <_pwm_init>:
/**
 * \brief Initialize TCC for PWM mode
 */
int32_t _pwm_init(struct _pwm_device *const device, void *const hw)
{
    4fe8:	b580      	push	{r7, lr}
    4fea:	b084      	sub	sp, #16
    4fec:	af00      	add	r7, sp, #0
    4fee:	6078      	str	r0, [r7, #4]
    4ff0:	6039      	str	r1, [r7, #0]
	struct tcc_cfg *cfg = _get_tcc_cfg(hw);
    4ff2:	6838      	ldr	r0, [r7, #0]
    4ff4:	4b6d      	ldr	r3, [pc, #436]	; (51ac <_pwm_init+0x1c4>)
    4ff6:	4798      	blx	r3
    4ff8:	60f8      	str	r0, [r7, #12]
	if (cfg == NULL) {
    4ffa:	68fb      	ldr	r3, [r7, #12]
    4ffc:	2b00      	cmp	r3, #0
    4ffe:	d102      	bne.n	5006 <_pwm_init+0x1e>
		return ERR_NOT_FOUND;
    5000:	f06f 0309 	mvn.w	r3, #9
    5004:	e0cd      	b.n	51a2 <_pwm_init+0x1ba>
	}
	struct tcc_pwm_cfg *cfg_pwm = _get_tcc_pwm_cfg(hw);
    5006:	6838      	ldr	r0, [r7, #0]
    5008:	4b69      	ldr	r3, [pc, #420]	; (51b0 <_pwm_init+0x1c8>)
    500a:	4798      	blx	r3
    500c:	60b8      	str	r0, [r7, #8]
	if (cfg_pwm == NULL) {
    500e:	68bb      	ldr	r3, [r7, #8]
    5010:	2b00      	cmp	r3, #0
    5012:	d102      	bne.n	501a <_pwm_init+0x32>
		return ERR_NOT_FOUND;
    5014:	f06f 0309 	mvn.w	r3, #9
    5018:	e0c3      	b.n	51a2 <_pwm_init+0x1ba>
	}

	device->hw = hw;
    501a:	687b      	ldr	r3, [r7, #4]
    501c:	683a      	ldr	r2, [r7, #0]
    501e:	611a      	str	r2, [r3, #16]

	if (!hri_tcc_is_syncing(hw, TCC_SYNCBUSY_SWRST)) {
    5020:	2101      	movs	r1, #1
    5022:	6838      	ldr	r0, [r7, #0]
    5024:	4b63      	ldr	r3, [pc, #396]	; (51b4 <_pwm_init+0x1cc>)
    5026:	4798      	blx	r3
    5028:	4603      	mov	r3, r0
    502a:	f083 0301 	eor.w	r3, r3, #1
    502e:	b2db      	uxtb	r3, r3
    5030:	2b00      	cmp	r3, #0
    5032:	d011      	beq.n	5058 <_pwm_init+0x70>
		if (hri_tcc_get_CTRLA_reg(hw, TCC_CTRLA_ENABLE)) {
    5034:	2102      	movs	r1, #2
    5036:	6838      	ldr	r0, [r7, #0]
    5038:	4b5f      	ldr	r3, [pc, #380]	; (51b8 <_pwm_init+0x1d0>)
    503a:	4798      	blx	r3
    503c:	4603      	mov	r3, r0
    503e:	2b00      	cmp	r3, #0
    5040:	d006      	beq.n	5050 <_pwm_init+0x68>
			hri_tcc_clear_CTRLA_ENABLE_bit(hw);
    5042:	6838      	ldr	r0, [r7, #0]
    5044:	4b5d      	ldr	r3, [pc, #372]	; (51bc <_pwm_init+0x1d4>)
    5046:	4798      	blx	r3
			hri_tcc_wait_for_sync(hw, TCC_SYNCBUSY_ENABLE);
    5048:	2102      	movs	r1, #2
    504a:	6838      	ldr	r0, [r7, #0]
    504c:	4b5c      	ldr	r3, [pc, #368]	; (51c0 <_pwm_init+0x1d8>)
    504e:	4798      	blx	r3
		}
		hri_tcc_write_CTRLA_reg(hw, TCC_CTRLA_SWRST);
    5050:	2101      	movs	r1, #1
    5052:	6838      	ldr	r0, [r7, #0]
    5054:	4b5b      	ldr	r3, [pc, #364]	; (51c4 <_pwm_init+0x1dc>)
    5056:	4798      	blx	r3
	}
	hri_tcc_wait_for_sync(hw, TCC_SYNCBUSY_SWRST);
    5058:	2101      	movs	r1, #1
    505a:	6838      	ldr	r0, [r7, #0]
    505c:	4b58      	ldr	r3, [pc, #352]	; (51c0 <_pwm_init+0x1d8>)
    505e:	4798      	blx	r3

	hri_tcc_write_CTRLA_reg(hw, cfg->ctrl_a);
    5060:	68fb      	ldr	r3, [r7, #12]
    5062:	689b      	ldr	r3, [r3, #8]
    5064:	4619      	mov	r1, r3
    5066:	6838      	ldr	r0, [r7, #0]
    5068:	4b56      	ldr	r3, [pc, #344]	; (51c4 <_pwm_init+0x1dc>)
    506a:	4798      	blx	r3
	hri_tcc_set_CTRLB_reg(hw, cfg->ctrl_b);
    506c:	68fb      	ldr	r3, [r7, #12]
    506e:	7b1b      	ldrb	r3, [r3, #12]
    5070:	4619      	mov	r1, r3
    5072:	6838      	ldr	r0, [r7, #0]
    5074:	4b54      	ldr	r3, [pc, #336]	; (51c8 <_pwm_init+0x1e0>)
    5076:	4798      	blx	r3
	hri_tcc_write_DBGCTRL_reg(hw, cfg->dbg_ctrl);
    5078:	68fb      	ldr	r3, [r7, #12]
    507a:	7b5b      	ldrb	r3, [r3, #13]
    507c:	4619      	mov	r1, r3
    507e:	6838      	ldr	r0, [r7, #0]
    5080:	4b52      	ldr	r3, [pc, #328]	; (51cc <_pwm_init+0x1e4>)
    5082:	4798      	blx	r3
	hri_tcc_write_EVCTRL_reg(hw, cfg->event_ctrl);
    5084:	68fb      	ldr	r3, [r7, #12]
    5086:	691b      	ldr	r3, [r3, #16]
    5088:	4619      	mov	r1, r3
    508a:	6838      	ldr	r0, [r7, #0]
    508c:	4b50      	ldr	r3, [pc, #320]	; (51d0 <_pwm_init+0x1e8>)
    508e:	4798      	blx	r3

	hri_tcc_write_WAVE_reg(hw, cfg_pwm->wave);
    5090:	68bb      	ldr	r3, [r7, #8]
    5092:	691b      	ldr	r3, [r3, #16]
    5094:	4619      	mov	r1, r3
    5096:	6838      	ldr	r0, [r7, #0]
    5098:	4b4e      	ldr	r3, [pc, #312]	; (51d4 <_pwm_init+0x1ec>)
    509a:	4798      	blx	r3
	hri_tcc_write_PER_reg(hw, cfg_pwm->period);
    509c:	68bb      	ldr	r3, [r7, #8]
    509e:	689b      	ldr	r3, [r3, #8]
    50a0:	4619      	mov	r1, r3
    50a2:	6838      	ldr	r0, [r7, #0]
    50a4:	4b4c      	ldr	r3, [pc, #304]	; (51d8 <_pwm_init+0x1f0>)
    50a6:	4798      	blx	r3
	cfg->per = cfg_pwm->period;
    50a8:	68bb      	ldr	r3, [r7, #8]
    50aa:	689a      	ldr	r2, [r3, #8]
    50ac:	68fb      	ldr	r3, [r7, #12]
    50ae:	62da      	str	r2, [r3, #44]	; 0x2c
	switch (cfg_pwm->sel_ch) {
    50b0:	68bb      	ldr	r3, [r7, #8]
    50b2:	799b      	ldrb	r3, [r3, #6]
    50b4:	2b05      	cmp	r3, #5
    50b6:	d857      	bhi.n	5168 <_pwm_init+0x180>
    50b8:	a201      	add	r2, pc, #4	; (adr r2, 50c0 <_pwm_init+0xd8>)
    50ba:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    50be:	bf00      	nop
    50c0:	000050d9 	.word	0x000050d9
    50c4:	000050f1 	.word	0x000050f1
    50c8:	00005109 	.word	0x00005109
    50cc:	00005121 	.word	0x00005121
    50d0:	00005139 	.word	0x00005139
    50d4:	00005151 	.word	0x00005151
	case 0:
		cfg->cc0 = cfg_pwm->duty_cycle;
    50d8:	68bb      	ldr	r3, [r7, #8]
    50da:	68da      	ldr	r2, [r3, #12]
    50dc:	68fb      	ldr	r3, [r7, #12]
    50de:	615a      	str	r2, [r3, #20]
		hri_tcc_write_CC_reg(hw, 0, cfg->cc0);
    50e0:	68fb      	ldr	r3, [r7, #12]
    50e2:	695b      	ldr	r3, [r3, #20]
    50e4:	461a      	mov	r2, r3
    50e6:	2100      	movs	r1, #0
    50e8:	6838      	ldr	r0, [r7, #0]
    50ea:	4b3c      	ldr	r3, [pc, #240]	; (51dc <_pwm_init+0x1f4>)
    50ec:	4798      	blx	r3
		break;
    50ee:	e03e      	b.n	516e <_pwm_init+0x186>
	case 1:
		cfg->cc1 = cfg_pwm->duty_cycle;
    50f0:	68bb      	ldr	r3, [r7, #8]
    50f2:	68da      	ldr	r2, [r3, #12]
    50f4:	68fb      	ldr	r3, [r7, #12]
    50f6:	619a      	str	r2, [r3, #24]
		hri_tcc_write_CC_reg(hw, 1, cfg->cc1);
    50f8:	68fb      	ldr	r3, [r7, #12]
    50fa:	699b      	ldr	r3, [r3, #24]
    50fc:	461a      	mov	r2, r3
    50fe:	2101      	movs	r1, #1
    5100:	6838      	ldr	r0, [r7, #0]
    5102:	4b36      	ldr	r3, [pc, #216]	; (51dc <_pwm_init+0x1f4>)
    5104:	4798      	blx	r3
		break;
    5106:	e032      	b.n	516e <_pwm_init+0x186>
	case 2:
		cfg->cc2 = cfg_pwm->duty_cycle;
    5108:	68bb      	ldr	r3, [r7, #8]
    510a:	68da      	ldr	r2, [r3, #12]
    510c:	68fb      	ldr	r3, [r7, #12]
    510e:	61da      	str	r2, [r3, #28]
		hri_tcc_write_CC_reg(hw, 2, cfg->cc2);
    5110:	68fb      	ldr	r3, [r7, #12]
    5112:	69db      	ldr	r3, [r3, #28]
    5114:	461a      	mov	r2, r3
    5116:	2102      	movs	r1, #2
    5118:	6838      	ldr	r0, [r7, #0]
    511a:	4b30      	ldr	r3, [pc, #192]	; (51dc <_pwm_init+0x1f4>)
    511c:	4798      	blx	r3
		break;
    511e:	e026      	b.n	516e <_pwm_init+0x186>
	case 3:
		cfg->cc3 = cfg_pwm->duty_cycle;
    5120:	68bb      	ldr	r3, [r7, #8]
    5122:	68da      	ldr	r2, [r3, #12]
    5124:	68fb      	ldr	r3, [r7, #12]
    5126:	621a      	str	r2, [r3, #32]
		hri_tcc_write_CC_reg(hw, 3, cfg->cc3);
    5128:	68fb      	ldr	r3, [r7, #12]
    512a:	6a1b      	ldr	r3, [r3, #32]
    512c:	461a      	mov	r2, r3
    512e:	2103      	movs	r1, #3
    5130:	6838      	ldr	r0, [r7, #0]
    5132:	4b2a      	ldr	r3, [pc, #168]	; (51dc <_pwm_init+0x1f4>)
    5134:	4798      	blx	r3
		break;
    5136:	e01a      	b.n	516e <_pwm_init+0x186>
	case 4:
		cfg->cc4 = cfg_pwm->duty_cycle;
    5138:	68bb      	ldr	r3, [r7, #8]
    513a:	68da      	ldr	r2, [r3, #12]
    513c:	68fb      	ldr	r3, [r7, #12]
    513e:	625a      	str	r2, [r3, #36]	; 0x24
		hri_tcc_write_CC_reg(hw, 4, cfg->cc4);
    5140:	68fb      	ldr	r3, [r7, #12]
    5142:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    5144:	461a      	mov	r2, r3
    5146:	2104      	movs	r1, #4
    5148:	6838      	ldr	r0, [r7, #0]
    514a:	4b24      	ldr	r3, [pc, #144]	; (51dc <_pwm_init+0x1f4>)
    514c:	4798      	blx	r3
		break;
    514e:	e00e      	b.n	516e <_pwm_init+0x186>
	case 5:
		cfg->cc5 = cfg_pwm->duty_cycle;
    5150:	68bb      	ldr	r3, [r7, #8]
    5152:	68da      	ldr	r2, [r3, #12]
    5154:	68fb      	ldr	r3, [r7, #12]
    5156:	629a      	str	r2, [r3, #40]	; 0x28
		hri_tcc_write_CC_reg(hw, 5, cfg->cc5);
    5158:	68fb      	ldr	r3, [r7, #12]
    515a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    515c:	461a      	mov	r2, r3
    515e:	2105      	movs	r1, #5
    5160:	6838      	ldr	r0, [r7, #0]
    5162:	4b1e      	ldr	r3, [pc, #120]	; (51dc <_pwm_init+0x1f4>)
    5164:	4798      	blx	r3
		break;
    5166:	e002      	b.n	516e <_pwm_init+0x186>
	default:
		return ERR_NO_RESOURCE;
    5168:	f06f 031b 	mvn.w	r3, #27
    516c:	e019      	b.n	51a2 <_pwm_init+0x1ba>
		break;
	}
	hri_tcc_clear_CTRLB_LUPD_bit(hw);
    516e:	6838      	ldr	r0, [r7, #0]
    5170:	4b1b      	ldr	r3, [pc, #108]	; (51e0 <_pwm_init+0x1f8>)
    5172:	4798      	blx	r3

	_tcc_init_irq_param(hw, (void *)device);
    5174:	6879      	ldr	r1, [r7, #4]
    5176:	6838      	ldr	r0, [r7, #0]
    5178:	4b1a      	ldr	r3, [pc, #104]	; (51e4 <_pwm_init+0x1fc>)
    517a:	4798      	blx	r3
	NVIC_DisableIRQ((IRQn_Type)cfg_pwm->irq);
    517c:	68bb      	ldr	r3, [r7, #8]
    517e:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
    5182:	4618      	mov	r0, r3
    5184:	4b18      	ldr	r3, [pc, #96]	; (51e8 <_pwm_init+0x200>)
    5186:	4798      	blx	r3
	NVIC_ClearPendingIRQ((IRQn_Type)cfg_pwm->irq);
    5188:	68bb      	ldr	r3, [r7, #8]
    518a:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
    518e:	4618      	mov	r0, r3
    5190:	4b16      	ldr	r3, [pc, #88]	; (51ec <_pwm_init+0x204>)
    5192:	4798      	blx	r3
	NVIC_EnableIRQ((IRQn_Type)cfg_pwm->irq);
    5194:	68bb      	ldr	r3, [r7, #8]
    5196:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
    519a:	4618      	mov	r0, r3
    519c:	4b14      	ldr	r3, [pc, #80]	; (51f0 <_pwm_init+0x208>)
    519e:	4798      	blx	r3

	return ERR_NONE;
    51a0:	2300      	movs	r3, #0
}
    51a2:	4618      	mov	r0, r3
    51a4:	3710      	adds	r7, #16
    51a6:	46bd      	mov	sp, r7
    51a8:	bd80      	pop	{r7, pc}
    51aa:	bf00      	nop
    51ac:	00005319 	.word	0x00005319
    51b0:	0000536d 	.word	0x0000536d
    51b4:	00004cfd 	.word	0x00004cfd
    51b8:	00004e69 	.word	0x00004e69
    51bc:	00004e41 	.word	0x00004e41
    51c0:	00004cd9 	.word	0x00004cd9
    51c4:	00004e99 	.word	0x00004e99
    51c8:	00004d99 	.word	0x00004d99
    51cc:	00004ebd 	.word	0x00004ebd
    51d0:	00004edb 	.word	0x00004edb
    51d4:	00004ef9 	.word	0x00004ef9
    51d8:	00004f21 	.word	0x00004f21
    51dc:	00004f45 	.word	0x00004f45
    51e0:	00004d7f 	.word	0x00004d7f
    51e4:	00004fbd 	.word	0x00004fbd
    51e8:	00004c59 	.word	0x00004c59
    51ec:	00004c9d 	.word	0x00004c9d
    51f0:	00004c1d 	.word	0x00004c1d

000051f4 <_pwm_enable>:
}
/**
 * \brief Start PWM
 */
void _pwm_enable(struct _pwm_device *const device)
{
    51f4:	b580      	push	{r7, lr}
    51f6:	b082      	sub	sp, #8
    51f8:	af00      	add	r7, sp, #0
    51fa:	6078      	str	r0, [r7, #4]
	hri_tcc_set_CTRLA_ENABLE_bit(device->hw);
    51fc:	687b      	ldr	r3, [r7, #4]
    51fe:	691b      	ldr	r3, [r3, #16]
    5200:	4618      	mov	r0, r3
    5202:	4b03      	ldr	r3, [pc, #12]	; (5210 <_pwm_enable+0x1c>)
    5204:	4798      	blx	r3
}
    5206:	bf00      	nop
    5208:	3708      	adds	r7, #8
    520a:	46bd      	mov	sp, r7
    520c:	bd80      	pop	{r7, pc}
    520e:	bf00      	nop
    5210:	00004de1 	.word	0x00004de1

00005214 <_pwm_set_param>:
}
/**
 * \brief Set PWM parameter
 */
void _pwm_set_param(struct _pwm_device *const device, const pwm_period_t period, const pwm_period_t duty_cycle)
{
    5214:	b580      	push	{r7, lr}
    5216:	b086      	sub	sp, #24
    5218:	af00      	add	r7, sp, #0
    521a:	60f8      	str	r0, [r7, #12]
    521c:	60b9      	str	r1, [r7, #8]
    521e:	607a      	str	r2, [r7, #4]
	void *const         hw      = device->hw;
    5220:	68fb      	ldr	r3, [r7, #12]
    5222:	691b      	ldr	r3, [r3, #16]
    5224:	617b      	str	r3, [r7, #20]
	struct tcc_pwm_cfg *cfg_pwm = _get_tcc_pwm_cfg(hw);
    5226:	6978      	ldr	r0, [r7, #20]
    5228:	4b0a      	ldr	r3, [pc, #40]	; (5254 <_pwm_set_param+0x40>)
    522a:	4798      	blx	r3
    522c:	6138      	str	r0, [r7, #16]
	if (cfg_pwm != NULL) {
    522e:	693b      	ldr	r3, [r7, #16]
    5230:	2b00      	cmp	r3, #0
    5232:	d00a      	beq.n	524a <_pwm_set_param+0x36>
		hri_tcc_write_PERB_reg(hw, period);
    5234:	68b9      	ldr	r1, [r7, #8]
    5236:	6978      	ldr	r0, [r7, #20]
    5238:	4b07      	ldr	r3, [pc, #28]	; (5258 <_pwm_set_param+0x44>)
    523a:	4798      	blx	r3
		hri_tcc_write_CCB_reg(hw, cfg_pwm->sel_ch, duty_cycle);
    523c:	693b      	ldr	r3, [r7, #16]
    523e:	799b      	ldrb	r3, [r3, #6]
    5240:	687a      	ldr	r2, [r7, #4]
    5242:	4619      	mov	r1, r3
    5244:	6978      	ldr	r0, [r7, #20]
    5246:	4b05      	ldr	r3, [pc, #20]	; (525c <_pwm_set_param+0x48>)
    5248:	4798      	blx	r3
		;
	}
}
    524a:	bf00      	nop
    524c:	3718      	adds	r7, #24
    524e:	46bd      	mov	sp, r7
    5250:	bd80      	pop	{r7, pc}
    5252:	bf00      	nop
    5254:	0000536d 	.word	0x0000536d
    5258:	00004f79 	.word	0x00004f79
    525c:	00004f95 	.word	0x00004f95

00005260 <_pwm_is_enabled>:
}
/**
 * \brief Check if PWM is running
 */
bool _pwm_is_enabled(const struct _pwm_device *const device)
{
    5260:	b580      	push	{r7, lr}
    5262:	b082      	sub	sp, #8
    5264:	af00      	add	r7, sp, #0
    5266:	6078      	str	r0, [r7, #4]
	return hri_tcc_get_CTRLA_ENABLE_bit(device->hw);
    5268:	687b      	ldr	r3, [r7, #4]
    526a:	691b      	ldr	r3, [r3, #16]
    526c:	4618      	mov	r0, r3
    526e:	4b03      	ldr	r3, [pc, #12]	; (527c <_pwm_is_enabled+0x1c>)
    5270:	4798      	blx	r3
    5272:	4603      	mov	r3, r0
}
    5274:	4618      	mov	r0, r3
    5276:	3708      	adds	r7, #8
    5278:	46bd      	mov	sp, r7
    527a:	bd80      	pop	{r7, pc}
    527c:	00004e09 	.word	0x00004e09

00005280 <_tcc_get_pwm>:

/**
 * \brief Retrieve pwm helper functions
 */
struct _pwm_hpl_interface *_tcc_get_pwm(void)
{
    5280:	b480      	push	{r7}
    5282:	af00      	add	r7, sp, #0
	return NULL;
    5284:	2300      	movs	r3, #0
}
    5286:	4618      	mov	r0, r3
    5288:	46bd      	mov	sp, r7
    528a:	f85d 7b04 	ldr.w	r7, [sp], #4
    528e:	4770      	bx	lr

00005290 <tcc_pwm_interrupt_handler>:
 * \internal TC interrupt handler for PWM
 *
 * \param[in] instance TC instance number
 */
static void tcc_pwm_interrupt_handler(struct _pwm_device *device)
{
    5290:	b580      	push	{r7, lr}
    5292:	b084      	sub	sp, #16
    5294:	af00      	add	r7, sp, #0
    5296:	6078      	str	r0, [r7, #4]
	void *const hw = device->hw;
    5298:	687b      	ldr	r3, [r7, #4]
    529a:	691b      	ldr	r3, [r3, #16]
    529c:	60fb      	str	r3, [r7, #12]

	if (hri_tcc_get_interrupt_OVF_bit(hw)) {
    529e:	68f8      	ldr	r0, [r7, #12]
    52a0:	4b12      	ldr	r3, [pc, #72]	; (52ec <tcc_pwm_interrupt_handler+0x5c>)
    52a2:	4798      	blx	r3
    52a4:	4603      	mov	r3, r0
    52a6:	2b00      	cmp	r3, #0
    52a8:	d00a      	beq.n	52c0 <tcc_pwm_interrupt_handler+0x30>
		hri_tcc_clear_interrupt_OVF_bit(hw);
    52aa:	68f8      	ldr	r0, [r7, #12]
    52ac:	4b10      	ldr	r3, [pc, #64]	; (52f0 <tcc_pwm_interrupt_handler+0x60>)
    52ae:	4798      	blx	r3
		if (NULL != device->callback.pwm_period_cb) {
    52b0:	687b      	ldr	r3, [r7, #4]
    52b2:	681b      	ldr	r3, [r3, #0]
    52b4:	2b00      	cmp	r3, #0
    52b6:	d003      	beq.n	52c0 <tcc_pwm_interrupt_handler+0x30>
			device->callback.pwm_period_cb(device);
    52b8:	687b      	ldr	r3, [r7, #4]
    52ba:	681b      	ldr	r3, [r3, #0]
    52bc:	6878      	ldr	r0, [r7, #4]
    52be:	4798      	blx	r3
		}
	}
	if (hri_tcc_get_INTEN_ERR_bit(hw)) {
    52c0:	68f8      	ldr	r0, [r7, #12]
    52c2:	4b0c      	ldr	r3, [pc, #48]	; (52f4 <tcc_pwm_interrupt_handler+0x64>)
    52c4:	4798      	blx	r3
    52c6:	4603      	mov	r3, r0
    52c8:	2b00      	cmp	r3, #0
    52ca:	d00a      	beq.n	52e2 <tcc_pwm_interrupt_handler+0x52>
		hri_tcc_clear_interrupt_ERR_bit(hw);
    52cc:	68f8      	ldr	r0, [r7, #12]
    52ce:	4b0a      	ldr	r3, [pc, #40]	; (52f8 <tcc_pwm_interrupt_handler+0x68>)
    52d0:	4798      	blx	r3
		if (NULL != device->callback.pwm_error_cb) {
    52d2:	687b      	ldr	r3, [r7, #4]
    52d4:	685b      	ldr	r3, [r3, #4]
    52d6:	2b00      	cmp	r3, #0
    52d8:	d003      	beq.n	52e2 <tcc_pwm_interrupt_handler+0x52>
			device->callback.pwm_error_cb(device);
    52da:	687b      	ldr	r3, [r7, #4]
    52dc:	685b      	ldr	r3, [r3, #4]
    52de:	6878      	ldr	r0, [r7, #4]
    52e0:	4798      	blx	r3
		}
	}
}
    52e2:	bf00      	nop
    52e4:	3710      	adds	r7, #16
    52e6:	46bd      	mov	sp, r7
    52e8:	bd80      	pop	{r7, pc}
    52ea:	bf00      	nop
    52ec:	00004d25 	.word	0x00004d25
    52f0:	00004d4b 	.word	0x00004d4b
    52f4:	00004db7 	.word	0x00004db7
    52f8:	00004d65 	.word	0x00004d65

000052fc <TCC0_0_Handler>:

/**
 * \brief TCC interrupt handler
 */
void TCC0_0_Handler(void)
{
    52fc:	b580      	push	{r7, lr}
    52fe:	af00      	add	r7, sp, #0
	tcc_pwm_interrupt_handler(_tcc0_dev);
    5300:	4b03      	ldr	r3, [pc, #12]	; (5310 <TCC0_0_Handler+0x14>)
    5302:	681b      	ldr	r3, [r3, #0]
    5304:	4618      	mov	r0, r3
    5306:	4b03      	ldr	r3, [pc, #12]	; (5314 <TCC0_0_Handler+0x18>)
    5308:	4798      	blx	r3
}
    530a:	bf00      	nop
    530c:	bd80      	pop	{r7, pc}
    530e:	bf00      	nop
    5310:	20000abc 	.word	0x20000abc
    5314:	00005291 	.word	0x00005291

00005318 <_get_tcc_cfg>:

static struct tcc_cfg *_get_tcc_cfg(void *hw)
{
    5318:	b480      	push	{r7}
    531a:	b085      	sub	sp, #20
    531c:	af00      	add	r7, sp, #0
    531e:	6078      	str	r0, [r7, #4]
	uint8_t i;

	for (i = 0; i < ARRAY_SIZE(_cfgs); i++) {
    5320:	2300      	movs	r3, #0
    5322:	73fb      	strb	r3, [r7, #15]
    5324:	e015      	b.n	5352 <_get_tcc_cfg+0x3a>
		if (_cfgs[i].hw == hw) {
    5326:	7bfa      	ldrb	r2, [r7, #15]
    5328:	490f      	ldr	r1, [pc, #60]	; (5368 <_get_tcc_cfg+0x50>)
    532a:	4613      	mov	r3, r2
    532c:	005b      	lsls	r3, r3, #1
    532e:	4413      	add	r3, r2
    5330:	011b      	lsls	r3, r3, #4
    5332:	440b      	add	r3, r1
    5334:	681a      	ldr	r2, [r3, #0]
    5336:	687b      	ldr	r3, [r7, #4]
    5338:	429a      	cmp	r2, r3
    533a:	d107      	bne.n	534c <_get_tcc_cfg+0x34>
			return &(_cfgs[i]);
    533c:	7bfa      	ldrb	r2, [r7, #15]
    533e:	4613      	mov	r3, r2
    5340:	005b      	lsls	r3, r3, #1
    5342:	4413      	add	r3, r2
    5344:	011b      	lsls	r3, r3, #4
    5346:	4a08      	ldr	r2, [pc, #32]	; (5368 <_get_tcc_cfg+0x50>)
    5348:	4413      	add	r3, r2
    534a:	e006      	b.n	535a <_get_tcc_cfg+0x42>
	for (i = 0; i < ARRAY_SIZE(_cfgs); i++) {
    534c:	7bfb      	ldrb	r3, [r7, #15]
    534e:	3301      	adds	r3, #1
    5350:	73fb      	strb	r3, [r7, #15]
    5352:	7bfb      	ldrb	r3, [r7, #15]
    5354:	2b00      	cmp	r3, #0
    5356:	d0e6      	beq.n	5326 <_get_tcc_cfg+0xe>
		}
	}
	return NULL;
    5358:	2300      	movs	r3, #0
}
    535a:	4618      	mov	r0, r3
    535c:	3714      	adds	r7, #20
    535e:	46bd      	mov	sp, r7
    5360:	f85d 7b04 	ldr.w	r7, [sp], #4
    5364:	4770      	bx	lr
    5366:	bf00      	nop
    5368:	20000030 	.word	0x20000030

0000536c <_get_tcc_pwm_cfg>:

static struct tcc_pwm_cfg *_get_tcc_pwm_cfg(void *hw)
{
    536c:	b480      	push	{r7}
    536e:	b085      	sub	sp, #20
    5370:	af00      	add	r7, sp, #0
    5372:	6078      	str	r0, [r7, #4]
	uint8_t i;

	for (i = 0; i < ARRAY_SIZE(_cfgs_pwm); i++) {
    5374:	2300      	movs	r3, #0
    5376:	73fb      	strb	r3, [r7, #15]
    5378:	e015      	b.n	53a6 <_get_tcc_pwm_cfg+0x3a>
		if (_cfgs_pwm[i].hw == hw) {
    537a:	7bfa      	ldrb	r2, [r7, #15]
    537c:	490f      	ldr	r1, [pc, #60]	; (53bc <_get_tcc_pwm_cfg+0x50>)
    537e:	4613      	mov	r3, r2
    5380:	009b      	lsls	r3, r3, #2
    5382:	4413      	add	r3, r2
    5384:	009b      	lsls	r3, r3, #2
    5386:	440b      	add	r3, r1
    5388:	681a      	ldr	r2, [r3, #0]
    538a:	687b      	ldr	r3, [r7, #4]
    538c:	429a      	cmp	r2, r3
    538e:	d107      	bne.n	53a0 <_get_tcc_pwm_cfg+0x34>
			return &(_cfgs_pwm[i]);
    5390:	7bfa      	ldrb	r2, [r7, #15]
    5392:	4613      	mov	r3, r2
    5394:	009b      	lsls	r3, r3, #2
    5396:	4413      	add	r3, r2
    5398:	009b      	lsls	r3, r3, #2
    539a:	4a08      	ldr	r2, [pc, #32]	; (53bc <_get_tcc_pwm_cfg+0x50>)
    539c:	4413      	add	r3, r2
    539e:	e006      	b.n	53ae <_get_tcc_pwm_cfg+0x42>
	for (i = 0; i < ARRAY_SIZE(_cfgs_pwm); i++) {
    53a0:	7bfb      	ldrb	r3, [r7, #15]
    53a2:	3301      	adds	r3, #1
    53a4:	73fb      	strb	r3, [r7, #15]
    53a6:	7bfb      	ldrb	r3, [r7, #15]
    53a8:	2b00      	cmp	r3, #0
    53aa:	d0e6      	beq.n	537a <_get_tcc_pwm_cfg+0xe>
		}
	}
	return NULL;
    53ac:	2300      	movs	r3, #0
}
    53ae:	4618      	mov	r0, r3
    53b0:	3714      	adds	r7, #20
    53b2:	46bd      	mov	sp, r7
    53b4:	f85d 7b04 	ldr.w	r7, [sp], #4
    53b8:	4770      	bx	lr
    53ba:	bf00      	nop
    53bc:	20000060 	.word	0x20000060

000053c0 <hri_port_read_DIR_reg>:
{
    53c0:	b480      	push	{r7}
    53c2:	b083      	sub	sp, #12
    53c4:	af00      	add	r7, sp, #0
    53c6:	6078      	str	r0, [r7, #4]
    53c8:	460b      	mov	r3, r1
    53ca:	70fb      	strb	r3, [r7, #3]
	return ((Port *)hw)->Group[submodule_index].DIR.reg;
    53cc:	78fb      	ldrb	r3, [r7, #3]
    53ce:	687a      	ldr	r2, [r7, #4]
    53d0:	01db      	lsls	r3, r3, #7
    53d2:	4413      	add	r3, r2
    53d4:	681b      	ldr	r3, [r3, #0]
}
    53d6:	4618      	mov	r0, r3
    53d8:	370c      	adds	r7, #12
    53da:	46bd      	mov	sp, r7
    53dc:	f85d 7b04 	ldr.w	r7, [sp], #4
    53e0:	4770      	bx	lr

000053e2 <hri_port_set_OUT_reg>:
{
    53e2:	b480      	push	{r7}
    53e4:	b085      	sub	sp, #20
    53e6:	af00      	add	r7, sp, #0
    53e8:	60f8      	str	r0, [r7, #12]
    53ea:	460b      	mov	r3, r1
    53ec:	607a      	str	r2, [r7, #4]
    53ee:	72fb      	strb	r3, [r7, #11]
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
    53f0:	7afb      	ldrb	r3, [r7, #11]
    53f2:	68fa      	ldr	r2, [r7, #12]
    53f4:	01db      	lsls	r3, r3, #7
    53f6:	4413      	add	r3, r2
    53f8:	3318      	adds	r3, #24
    53fa:	687a      	ldr	r2, [r7, #4]
    53fc:	601a      	str	r2, [r3, #0]
}
    53fe:	bf00      	nop
    5400:	3714      	adds	r7, #20
    5402:	46bd      	mov	sp, r7
    5404:	f85d 7b04 	ldr.w	r7, [sp], #4
    5408:	4770      	bx	lr

0000540a <hri_port_read_OUT_reg>:
{
    540a:	b480      	push	{r7}
    540c:	b083      	sub	sp, #12
    540e:	af00      	add	r7, sp, #0
    5410:	6078      	str	r0, [r7, #4]
    5412:	460b      	mov	r3, r1
    5414:	70fb      	strb	r3, [r7, #3]
	return ((Port *)hw)->Group[submodule_index].OUT.reg;
    5416:	78fb      	ldrb	r3, [r7, #3]
    5418:	687a      	ldr	r2, [r7, #4]
    541a:	01db      	lsls	r3, r3, #7
    541c:	4413      	add	r3, r2
    541e:	3310      	adds	r3, #16
    5420:	681b      	ldr	r3, [r3, #0]
}
    5422:	4618      	mov	r0, r3
    5424:	370c      	adds	r7, #12
    5426:	46bd      	mov	sp, r7
    5428:	f85d 7b04 	ldr.w	r7, [sp], #4
    542c:	4770      	bx	lr

0000542e <hri_port_clear_OUT_reg>:
{
    542e:	b480      	push	{r7}
    5430:	b085      	sub	sp, #20
    5432:	af00      	add	r7, sp, #0
    5434:	60f8      	str	r0, [r7, #12]
    5436:	460b      	mov	r3, r1
    5438:	607a      	str	r2, [r7, #4]
    543a:	72fb      	strb	r3, [r7, #11]
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
    543c:	7afb      	ldrb	r3, [r7, #11]
    543e:	68fa      	ldr	r2, [r7, #12]
    5440:	01db      	lsls	r3, r3, #7
    5442:	4413      	add	r3, r2
    5444:	3314      	adds	r3, #20
    5446:	687a      	ldr	r2, [r7, #4]
    5448:	601a      	str	r2, [r3, #0]
}
    544a:	bf00      	nop
    544c:	3714      	adds	r7, #20
    544e:	46bd      	mov	sp, r7
    5450:	f85d 7b04 	ldr.w	r7, [sp], #4
    5454:	4770      	bx	lr

00005456 <hri_port_read_IN_reg>:
{
    5456:	b480      	push	{r7}
    5458:	b083      	sub	sp, #12
    545a:	af00      	add	r7, sp, #0
    545c:	6078      	str	r0, [r7, #4]
    545e:	460b      	mov	r3, r1
    5460:	70fb      	strb	r3, [r7, #3]
	return ((Port *)hw)->Group[submodule_index].IN.reg;
    5462:	78fb      	ldrb	r3, [r7, #3]
    5464:	687a      	ldr	r2, [r7, #4]
    5466:	01db      	lsls	r3, r3, #7
    5468:	4413      	add	r3, r2
    546a:	3320      	adds	r3, #32
    546c:	681b      	ldr	r3, [r3, #0]
}
    546e:	4618      	mov	r0, r3
    5470:	370c      	adds	r7, #12
    5472:	46bd      	mov	sp, r7
    5474:	f85d 7b04 	ldr.w	r7, [sp], #4
    5478:	4770      	bx	lr
	...

0000547c <_gpio_set_level>:
{
    547c:	b580      	push	{r7, lr}
    547e:	b082      	sub	sp, #8
    5480:	af00      	add	r7, sp, #0
    5482:	4603      	mov	r3, r0
    5484:	6039      	str	r1, [r7, #0]
    5486:	71fb      	strb	r3, [r7, #7]
    5488:	4613      	mov	r3, r2
    548a:	71bb      	strb	r3, [r7, #6]
	if (level) {
    548c:	79bb      	ldrb	r3, [r7, #6]
    548e:	2b00      	cmp	r3, #0
    5490:	d006      	beq.n	54a0 <_gpio_set_level+0x24>
		hri_port_set_OUT_reg(PORT, port, mask);
    5492:	79fb      	ldrb	r3, [r7, #7]
    5494:	683a      	ldr	r2, [r7, #0]
    5496:	4619      	mov	r1, r3
    5498:	4806      	ldr	r0, [pc, #24]	; (54b4 <_gpio_set_level+0x38>)
    549a:	4b07      	ldr	r3, [pc, #28]	; (54b8 <_gpio_set_level+0x3c>)
    549c:	4798      	blx	r3
}
    549e:	e005      	b.n	54ac <_gpio_set_level+0x30>
		hri_port_clear_OUT_reg(PORT, port, mask);
    54a0:	79fb      	ldrb	r3, [r7, #7]
    54a2:	683a      	ldr	r2, [r7, #0]
    54a4:	4619      	mov	r1, r3
    54a6:	4803      	ldr	r0, [pc, #12]	; (54b4 <_gpio_set_level+0x38>)
    54a8:	4b04      	ldr	r3, [pc, #16]	; (54bc <_gpio_set_level+0x40>)
    54aa:	4798      	blx	r3
}
    54ac:	bf00      	nop
    54ae:	3708      	adds	r7, #8
    54b0:	46bd      	mov	sp, r7
    54b2:	bd80      	pop	{r7, pc}
    54b4:	41008000 	.word	0x41008000
    54b8:	000053e3 	.word	0x000053e3
    54bc:	0000542f 	.word	0x0000542f

000054c0 <_gpio_get_level>:
{
    54c0:	b580      	push	{r7, lr}
    54c2:	b086      	sub	sp, #24
    54c4:	af00      	add	r7, sp, #0
    54c6:	4603      	mov	r3, r0
    54c8:	71fb      	strb	r3, [r7, #7]
	CRITICAL_SECTION_ENTER();
    54ca:	f107 030c 	add.w	r3, r7, #12
    54ce:	4618      	mov	r0, r3
    54d0:	4b13      	ldr	r3, [pc, #76]	; (5520 <_gpio_get_level+0x60>)
    54d2:	4798      	blx	r3
	uint32_t dir_tmp = hri_port_read_DIR_reg(PORT, port);
    54d4:	79fb      	ldrb	r3, [r7, #7]
    54d6:	4619      	mov	r1, r3
    54d8:	4812      	ldr	r0, [pc, #72]	; (5524 <_gpio_get_level+0x64>)
    54da:	4b13      	ldr	r3, [pc, #76]	; (5528 <_gpio_get_level+0x68>)
    54dc:	4798      	blx	r3
    54de:	6178      	str	r0, [r7, #20]
	tmp = hri_port_read_IN_reg(PORT, port) & ~dir_tmp;
    54e0:	79fb      	ldrb	r3, [r7, #7]
    54e2:	4619      	mov	r1, r3
    54e4:	480f      	ldr	r0, [pc, #60]	; (5524 <_gpio_get_level+0x64>)
    54e6:	4b11      	ldr	r3, [pc, #68]	; (552c <_gpio_get_level+0x6c>)
    54e8:	4798      	blx	r3
    54ea:	4602      	mov	r2, r0
    54ec:	697b      	ldr	r3, [r7, #20]
    54ee:	43db      	mvns	r3, r3
    54f0:	4013      	ands	r3, r2
    54f2:	613b      	str	r3, [r7, #16]
	tmp |= hri_port_read_OUT_reg(PORT, port) & dir_tmp;
    54f4:	79fb      	ldrb	r3, [r7, #7]
    54f6:	4619      	mov	r1, r3
    54f8:	480a      	ldr	r0, [pc, #40]	; (5524 <_gpio_get_level+0x64>)
    54fa:	4b0d      	ldr	r3, [pc, #52]	; (5530 <_gpio_get_level+0x70>)
    54fc:	4798      	blx	r3
    54fe:	4602      	mov	r2, r0
    5500:	697b      	ldr	r3, [r7, #20]
    5502:	4013      	ands	r3, r2
    5504:	693a      	ldr	r2, [r7, #16]
    5506:	4313      	orrs	r3, r2
    5508:	613b      	str	r3, [r7, #16]
	CRITICAL_SECTION_LEAVE();
    550a:	f107 030c 	add.w	r3, r7, #12
    550e:	4618      	mov	r0, r3
    5510:	4b08      	ldr	r3, [pc, #32]	; (5534 <_gpio_get_level+0x74>)
    5512:	4798      	blx	r3
	return tmp;
    5514:	693b      	ldr	r3, [r7, #16]
}
    5516:	4618      	mov	r0, r3
    5518:	3718      	adds	r7, #24
    551a:	46bd      	mov	sp, r7
    551c:	bd80      	pop	{r7, pc}
    551e:	bf00      	nop
    5520:	00000ded 	.word	0x00000ded
    5524:	41008000 	.word	0x41008000
    5528:	000053c1 	.word	0x000053c1
    552c:	00005457 	.word	0x00005457
    5530:	0000540b 	.word	0x0000540b
    5534:	00000e13 	.word	0x00000e13

00005538 <gpio_set_pin_level>:
{
    5538:	b580      	push	{r7, lr}
    553a:	b082      	sub	sp, #8
    553c:	af00      	add	r7, sp, #0
    553e:	4603      	mov	r3, r0
    5540:	460a      	mov	r2, r1
    5542:	71fb      	strb	r3, [r7, #7]
    5544:	4613      	mov	r3, r2
    5546:	71bb      	strb	r3, [r7, #6]
	_gpio_set_level((enum gpio_port)GPIO_PORT(pin), 1U << GPIO_PIN(pin), level);
    5548:	79fb      	ldrb	r3, [r7, #7]
    554a:	095b      	lsrs	r3, r3, #5
    554c:	b2d8      	uxtb	r0, r3
    554e:	79fb      	ldrb	r3, [r7, #7]
    5550:	f003 031f 	and.w	r3, r3, #31
    5554:	2201      	movs	r2, #1
    5556:	fa02 f303 	lsl.w	r3, r2, r3
    555a:	79ba      	ldrb	r2, [r7, #6]
    555c:	4619      	mov	r1, r3
    555e:	4b03      	ldr	r3, [pc, #12]	; (556c <gpio_set_pin_level+0x34>)
    5560:	4798      	blx	r3
}
    5562:	bf00      	nop
    5564:	3708      	adds	r7, #8
    5566:	46bd      	mov	sp, r7
    5568:	bd80      	pop	{r7, pc}
    556a:	bf00      	nop
    556c:	0000547d 	.word	0x0000547d

00005570 <gpio_get_pin_level>:
 * Reads the level on pins connected to a port
 *
 * \param[in] pin       The pin number for device
 */
static inline bool gpio_get_pin_level(const uint8_t pin)
{
    5570:	b580      	push	{r7, lr}
    5572:	b082      	sub	sp, #8
    5574:	af00      	add	r7, sp, #0
    5576:	4603      	mov	r3, r0
    5578:	71fb      	strb	r3, [r7, #7]
	return (bool)(_gpio_get_level((enum gpio_port)GPIO_PORT(pin)) & (0x01U << GPIO_PIN(pin)));
    557a:	79fb      	ldrb	r3, [r7, #7]
    557c:	095b      	lsrs	r3, r3, #5
    557e:	b2db      	uxtb	r3, r3
    5580:	4618      	mov	r0, r3
    5582:	4b09      	ldr	r3, [pc, #36]	; (55a8 <gpio_get_pin_level+0x38>)
    5584:	4798      	blx	r3
    5586:	4601      	mov	r1, r0
    5588:	79fb      	ldrb	r3, [r7, #7]
    558a:	f003 031f 	and.w	r3, r3, #31
    558e:	2201      	movs	r2, #1
    5590:	fa02 f303 	lsl.w	r3, r2, r3
    5594:	400b      	ands	r3, r1
    5596:	2b00      	cmp	r3, #0
    5598:	bf14      	ite	ne
    559a:	2301      	movne	r3, #1
    559c:	2300      	moveq	r3, #0
    559e:	b2db      	uxtb	r3, r3
}
    55a0:	4618      	mov	r0, r3
    55a2:	3708      	adds	r7, #8
    55a4:	46bd      	mov	sp, r7
    55a6:	bd80      	pop	{r7, pc}
    55a8:	000054c1 	.word	0x000054c1

000055ac <camera_async_enable>:
 * \param[in] descr Camera sensor descriptor to enable
 *
 * \return Enabling status.
 */
static inline int32_t camera_async_enable(struct camera_async_descriptor *const descr)
{
    55ac:	b580      	push	{r7, lr}
    55ae:	b082      	sub	sp, #8
    55b0:	af00      	add	r7, sp, #0
    55b2:	6078      	str	r0, [r7, #4]
	ASSERT(descr);
    55b4:	687b      	ldr	r3, [r7, #4]
    55b6:	2b00      	cmp	r3, #0
    55b8:	bf14      	ite	ne
    55ba:	2301      	movne	r3, #1
    55bc:	2300      	moveq	r3, #0
    55be:	b2db      	uxtb	r3, r3
    55c0:	227f      	movs	r2, #127	; 0x7f
    55c2:	4906      	ldr	r1, [pc, #24]	; (55dc <camera_async_enable+0x30>)
    55c4:	4618      	mov	r0, r3
    55c6:	4b06      	ldr	r3, [pc, #24]	; (55e0 <camera_async_enable+0x34>)
    55c8:	4798      	blx	r3

	_camera_async_enable(&descr->device);
    55ca:	687b      	ldr	r3, [r7, #4]
    55cc:	4618      	mov	r0, r3
    55ce:	4b05      	ldr	r3, [pc, #20]	; (55e4 <camera_async_enable+0x38>)
    55d0:	4798      	blx	r3

	return ERR_NONE;
    55d2:	2300      	movs	r3, #0
}
    55d4:	4618      	mov	r0, r3
    55d6:	3708      	adds	r7, #8
    55d8:	46bd      	mov	sp, r7
    55da:	bd80      	pop	{r7, pc}
    55dc:	00005e24 	.word	0x00005e24
    55e0:	00001849 	.word	0x00001849
    55e4:	00003485 	.word	0x00003485

000055e8 <camera_async_disable>:
 * \param[in] descr The camera sensor descriptor to disable
 *
 * \return Disabling status.
 */
static inline int32_t camera_async_disable(struct camera_async_descriptor *const descr)
{
    55e8:	b580      	push	{r7, lr}
    55ea:	b082      	sub	sp, #8
    55ec:	af00      	add	r7, sp, #0
    55ee:	6078      	str	r0, [r7, #4]
	ASSERT(descr);
    55f0:	687b      	ldr	r3, [r7, #4]
    55f2:	2b00      	cmp	r3, #0
    55f4:	bf14      	ite	ne
    55f6:	2301      	movne	r3, #1
    55f8:	2300      	moveq	r3, #0
    55fa:	b2db      	uxtb	r3, r3
    55fc:	2291      	movs	r2, #145	; 0x91
    55fe:	4906      	ldr	r1, [pc, #24]	; (5618 <camera_async_disable+0x30>)
    5600:	4618      	mov	r0, r3
    5602:	4b06      	ldr	r3, [pc, #24]	; (561c <camera_async_disable+0x34>)
    5604:	4798      	blx	r3

	_camera_async_disable(&descr->device);
    5606:	687b      	ldr	r3, [r7, #4]
    5608:	4618      	mov	r0, r3
    560a:	4b05      	ldr	r3, [pc, #20]	; (5620 <camera_async_disable+0x38>)
    560c:	4798      	blx	r3

	return ERR_NONE;
    560e:	2300      	movs	r3, #0
}
    5610:	4618      	mov	r0, r3
    5612:	3708      	adds	r7, #8
    5614:	46bd      	mov	sp, r7
    5616:	bd80      	pop	{r7, pc}
    5618:	00005e24 	.word	0x00005e24
    561c:	00001849 	.word	0x00001849
    5620:	000034a5 	.word	0x000034a5

00005624 <camera_async_capture_start>:
 *
 * \return Capture start status.
 */
static inline int32_t camera_async_capture_start(struct camera_async_descriptor *const descr, uint32_t ch,
                                                 uint32_t *buf)
{
    5624:	b580      	push	{r7, lr}
    5626:	b084      	sub	sp, #16
    5628:	af00      	add	r7, sp, #0
    562a:	60f8      	str	r0, [r7, #12]
    562c:	60b9      	str	r1, [r7, #8]
    562e:	607a      	str	r2, [r7, #4]
	ASSERT(descr);
    5630:	68fb      	ldr	r3, [r7, #12]
    5632:	2b00      	cmp	r3, #0
    5634:	bf14      	ite	ne
    5636:	2301      	movne	r3, #1
    5638:	2300      	moveq	r3, #0
    563a:	b2db      	uxtb	r3, r3
    563c:	22b9      	movs	r2, #185	; 0xb9
    563e:	490d      	ldr	r1, [pc, #52]	; (5674 <camera_async_capture_start+0x50>)
    5640:	4618      	mov	r0, r3
    5642:	4b0d      	ldr	r3, [pc, #52]	; (5678 <camera_async_capture_start+0x54>)
    5644:	4798      	blx	r3
	ASSERT(buf);
    5646:	687b      	ldr	r3, [r7, #4]
    5648:	2b00      	cmp	r3, #0
    564a:	bf14      	ite	ne
    564c:	2301      	movne	r3, #1
    564e:	2300      	moveq	r3, #0
    5650:	b2db      	uxtb	r3, r3
    5652:	22ba      	movs	r2, #186	; 0xba
    5654:	4907      	ldr	r1, [pc, #28]	; (5674 <camera_async_capture_start+0x50>)
    5656:	4618      	mov	r0, r3
    5658:	4b07      	ldr	r3, [pc, #28]	; (5678 <camera_async_capture_start+0x54>)
    565a:	4798      	blx	r3

	_camera_async_capture_start(&descr->device, ch, buf);
    565c:	68fb      	ldr	r3, [r7, #12]
    565e:	687a      	ldr	r2, [r7, #4]
    5660:	68b9      	ldr	r1, [r7, #8]
    5662:	4618      	mov	r0, r3
    5664:	4b05      	ldr	r3, [pc, #20]	; (567c <camera_async_capture_start+0x58>)
    5666:	4798      	blx	r3

	return ERR_NONE;
    5668:	2300      	movs	r3, #0
}
    566a:	4618      	mov	r0, r3
    566c:	3710      	adds	r7, #16
    566e:	46bd      	mov	sp, r7
    5670:	bd80      	pop	{r7, pc}
    5672:	bf00      	nop
    5674:	00005e24 	.word	0x00005e24
    5678:	00001849 	.word	0x00001849
    567c:	000034c5 	.word	0x000034c5

00005680 <ext_irq_cb_PCC_VSYNC>:
	PCC_SCCB_Buffer[1] = dat;
	io_write(&PCC_SCCB.io, PCC_SCCB_Buffer, 2);
}

static void ext_irq_cb_PCC_VSYNC(void)
{
    5680:	b480      	push	{r7}
    5682:	af00      	add	r7, sp, #0
	
	//Do Nothing
//	asm ("nop");
}
    5684:	bf00      	nop
    5686:	46bd      	mov	sp, r7
    5688:	f85d 7b04 	ldr.w	r7, [sp], #4
    568c:	4770      	bx	lr
	...

00005690 <config_sensor_ov7670>:

void config_sensor_ov7670(void)
{
    5690:	b580      	push	{r7, lr}
    5692:	b082      	sub	sp, #8
    5694:	af00      	add	r7, sp, #0

	uint8_t PCC_SCCB_Buffer[2];
	uint8_t recv_vid;
	uint8_t recv_pid;
	
	gpio_set_pin_level(PCC_PWDN, false);
    5696:	2100      	movs	r1, #0
    5698:	2056      	movs	r0, #86	; 0x56
    569a:	4b58      	ldr	r3, [pc, #352]	; (57fc <config_sensor_ov7670+0x16c>)
    569c:	4798      	blx	r3
	gpio_set_pin_level(PCC_RESET, true);
    569e:	2101      	movs	r1, #1
    56a0:	2057      	movs	r0, #87	; 0x57
    56a2:	4b56      	ldr	r3, [pc, #344]	; (57fc <config_sensor_ov7670+0x16c>)
    56a4:	4798      	blx	r3
	delay_ms(10);
    56a6:	200a      	movs	r0, #10
    56a8:	4b55      	ldr	r3, [pc, #340]	; (5800 <config_sensor_ov7670+0x170>)
    56aa:	4798      	blx	r3
	
	i2c_m_sync_get_io_descriptor(&PCC_SCCB, &PCC_SCCB_io);
    56ac:	4955      	ldr	r1, [pc, #340]	; (5804 <config_sensor_ov7670+0x174>)
    56ae:	4856      	ldr	r0, [pc, #344]	; (5808 <config_sensor_ov7670+0x178>)
    56b0:	4b56      	ldr	r3, [pc, #344]	; (580c <config_sensor_ov7670+0x17c>)
    56b2:	4798      	blx	r3
	i2c_m_sync_enable(&PCC_SCCB);
    56b4:	4854      	ldr	r0, [pc, #336]	; (5808 <config_sensor_ov7670+0x178>)
    56b6:	4b56      	ldr	r3, [pc, #344]	; (5810 <config_sensor_ov7670+0x180>)
    56b8:	4798      	blx	r3
	i2c_m_sync_set_slaveaddr(&PCC_SCCB, OV7670_SLAVE_ADDRESS, I2C_M_SEVEN);
    56ba:	f44f 6200 	mov.w	r2, #2048	; 0x800
    56be:	2121      	movs	r1, #33	; 0x21
    56c0:	4851      	ldr	r0, [pc, #324]	; (5808 <config_sensor_ov7670+0x178>)
    56c2:	4b54      	ldr	r3, [pc, #336]	; (5814 <config_sensor_ov7670+0x184>)
    56c4:	4798      	blx	r3

	PCC_SCCB_Buffer[0] = OV7670_CHIPID_HIGH;
    56c6:	230a      	movs	r3, #10
    56c8:	713b      	strb	r3, [r7, #4]
	io_write(&PCC_SCCB.io, PCC_SCCB_Buffer, 1);
    56ca:	1d3b      	adds	r3, r7, #4
    56cc:	2201      	movs	r2, #1
    56ce:	4619      	mov	r1, r3
    56d0:	4851      	ldr	r0, [pc, #324]	; (5818 <config_sensor_ov7670+0x188>)
    56d2:	4b52      	ldr	r3, [pc, #328]	; (581c <config_sensor_ov7670+0x18c>)
    56d4:	4798      	blx	r3
	io_read(&PCC_SCCB.io, &recv_vid, 1);
    56d6:	1cfb      	adds	r3, r7, #3
    56d8:	2201      	movs	r2, #1
    56da:	4619      	mov	r1, r3
    56dc:	484e      	ldr	r0, [pc, #312]	; (5818 <config_sensor_ov7670+0x188>)
    56de:	4b50      	ldr	r3, [pc, #320]	; (5820 <config_sensor_ov7670+0x190>)
    56e0:	4798      	blx	r3

	delay_ms(10);
    56e2:	200a      	movs	r0, #10
    56e4:	4b46      	ldr	r3, [pc, #280]	; (5800 <config_sensor_ov7670+0x170>)
    56e6:	4798      	blx	r3
	PCC_SCCB_Buffer[0] = OV7670_CHIPID_LOW;
    56e8:	230b      	movs	r3, #11
    56ea:	713b      	strb	r3, [r7, #4]
	io_write(&PCC_SCCB.io, PCC_SCCB_Buffer, 1);
    56ec:	1d3b      	adds	r3, r7, #4
    56ee:	2201      	movs	r2, #1
    56f0:	4619      	mov	r1, r3
    56f2:	4849      	ldr	r0, [pc, #292]	; (5818 <config_sensor_ov7670+0x188>)
    56f4:	4b49      	ldr	r3, [pc, #292]	; (581c <config_sensor_ov7670+0x18c>)
    56f6:	4798      	blx	r3
	io_read(&PCC_SCCB.io, &recv_pid, 1);
    56f8:	1cbb      	adds	r3, r7, #2
    56fa:	2201      	movs	r2, #1
    56fc:	4619      	mov	r1, r3
    56fe:	4846      	ldr	r0, [pc, #280]	; (5818 <config_sensor_ov7670+0x188>)
    5700:	4b47      	ldr	r3, [pc, #284]	; (5820 <config_sensor_ov7670+0x190>)
    5702:	4798      	blx	r3
	delay_ms(10);
    5704:	200a      	movs	r0, #10
    5706:	4b3e      	ldr	r3, [pc, #248]	; (5800 <config_sensor_ov7670+0x170>)
    5708:	4798      	blx	r3
	if(OV7670_CHIPID_VID == recv_vid && OV7670_CHIPID_PID == recv_pid)
    570a:	78fb      	ldrb	r3, [r7, #3]
    570c:	2b76      	cmp	r3, #118	; 0x76
    570e:	d108      	bne.n	5722 <config_sensor_ov7670+0x92>
    5710:	78bb      	ldrb	r3, [r7, #2]
    5712:	2b73      	cmp	r3, #115	; 0x73
    5714:	d105      	bne.n	5722 <config_sensor_ov7670+0x92>
	{
		#ifdef CAMERA_0_TEST
		io_write(&EDBG_COM.io, Display_Valid_VID_PID, sizeof(Display_Valid_VID_PID));
    5716:	2220      	movs	r2, #32
    5718:	4942      	ldr	r1, [pc, #264]	; (5824 <config_sensor_ov7670+0x194>)
    571a:	4843      	ldr	r0, [pc, #268]	; (5828 <config_sensor_ov7670+0x198>)
    571c:	4b3f      	ldr	r3, [pc, #252]	; (581c <config_sensor_ov7670+0x18c>)
    571e:	4798      	blx	r3
    5720:	e004      	b.n	572c <config_sensor_ov7670+0x9c>
		#endif
	}
	else
	{
		#ifdef CAMERA_0_TEST
		io_write(&EDBG_COM.io, Display_Invalid_VID_PID, sizeof(Display_Invalid_VID_PID));
    5722:	2218      	movs	r2, #24
    5724:	4941      	ldr	r1, [pc, #260]	; (582c <config_sensor_ov7670+0x19c>)
    5726:	4840      	ldr	r0, [pc, #256]	; (5828 <config_sensor_ov7670+0x198>)
    5728:	4b3c      	ldr	r3, [pc, #240]	; (581c <config_sensor_ov7670+0x18c>)
    572a:	4798      	blx	r3
		#endif
		////while(1);
	}
	
	PCC_SCCB_Buffer[0] = 0x0C;
    572c:	230c      	movs	r3, #12
    572e:	713b      	strb	r3, [r7, #4]
	PCC_SCCB_Buffer[1] = 0x08;
    5730:	2308      	movs	r3, #8
    5732:	717b      	strb	r3, [r7, #5]
	io_write(&PCC_SCCB.io, PCC_SCCB_Buffer, 2);
    5734:	1d3b      	adds	r3, r7, #4
    5736:	2202      	movs	r2, #2
    5738:	4619      	mov	r1, r3
    573a:	4837      	ldr	r0, [pc, #220]	; (5818 <config_sensor_ov7670+0x188>)
    573c:	4b37      	ldr	r3, [pc, #220]	; (581c <config_sensor_ov7670+0x18c>)
    573e:	4798      	blx	r3
	
	PCC_SCCB_Buffer[0] = 0x12;
    5740:	2312      	movs	r3, #18
    5742:	713b      	strb	r3, [r7, #4]
	PCC_SCCB_Buffer[1] = 0x14;
    5744:	2314      	movs	r3, #20
    5746:	717b      	strb	r3, [r7, #5]
	io_write(&PCC_SCCB.io, PCC_SCCB_Buffer, 2);
    5748:	1d3b      	adds	r3, r7, #4
    574a:	2202      	movs	r2, #2
    574c:	4619      	mov	r1, r3
    574e:	4832      	ldr	r0, [pc, #200]	; (5818 <config_sensor_ov7670+0x188>)
    5750:	4b32      	ldr	r3, [pc, #200]	; (581c <config_sensor_ov7670+0x18c>)
    5752:	4798      	blx	r3
	
	PCC_SCCB_Buffer[0] = 0x15;
    5754:	2315      	movs	r3, #21
    5756:	713b      	strb	r3, [r7, #4]
	PCC_SCCB_Buffer[1] = 0x02;
    5758:	2302      	movs	r3, #2
    575a:	717b      	strb	r3, [r7, #5]
	io_write(&PCC_SCCB.io, PCC_SCCB_Buffer, 2);
    575c:	1d3b      	adds	r3, r7, #4
    575e:	2202      	movs	r2, #2
    5760:	4619      	mov	r1, r3
    5762:	482d      	ldr	r0, [pc, #180]	; (5818 <config_sensor_ov7670+0x188>)
    5764:	4b2d      	ldr	r3, [pc, #180]	; (581c <config_sensor_ov7670+0x18c>)
    5766:	4798      	blx	r3
	
	PCC_SCCB_Buffer[0] = 0x40;
    5768:	2340      	movs	r3, #64	; 0x40
    576a:	713b      	strb	r3, [r7, #4]
	PCC_SCCB_Buffer[1] = 0xD0;
    576c:	23d0      	movs	r3, #208	; 0xd0
    576e:	717b      	strb	r3, [r7, #5]
	io_write(&PCC_SCCB.io, PCC_SCCB_Buffer, 2);
    5770:	1d3b      	adds	r3, r7, #4
    5772:	2202      	movs	r2, #2
    5774:	4619      	mov	r1, r3
    5776:	4828      	ldr	r0, [pc, #160]	; (5818 <config_sensor_ov7670+0x188>)
    5778:	4b28      	ldr	r3, [pc, #160]	; (581c <config_sensor_ov7670+0x18c>)
    577a:	4798      	blx	r3
	
	PCC_SCCB_Buffer[0] = 0x1E;
    577c:	231e      	movs	r3, #30
    577e:	713b      	strb	r3, [r7, #4]
	PCC_SCCB_Buffer[1] = 0x31;
    5780:	2331      	movs	r3, #49	; 0x31
    5782:	717b      	strb	r3, [r7, #5]
	io_write(&PCC_SCCB.io, PCC_SCCB_Buffer, 2);
    5784:	1d3b      	adds	r3, r7, #4
    5786:	2202      	movs	r2, #2
    5788:	4619      	mov	r1, r3
    578a:	4823      	ldr	r0, [pc, #140]	; (5818 <config_sensor_ov7670+0x188>)
    578c:	4b23      	ldr	r3, [pc, #140]	; (581c <config_sensor_ov7670+0x18c>)
    578e:	4798      	blx	r3
	
	PCC_SCCB_Buffer[0] = 0x3A;
    5790:	233a      	movs	r3, #58	; 0x3a
    5792:	713b      	strb	r3, [r7, #4]
	PCC_SCCB_Buffer[1] = 0x0C;
    5794:	230c      	movs	r3, #12
    5796:	717b      	strb	r3, [r7, #5]
	io_write(&PCC_SCCB.io, PCC_SCCB_Buffer, 2);
    5798:	1d3b      	adds	r3, r7, #4
    579a:	2202      	movs	r2, #2
    579c:	4619      	mov	r1, r3
    579e:	481e      	ldr	r0, [pc, #120]	; (5818 <config_sensor_ov7670+0x188>)
    57a0:	4b1e      	ldr	r3, [pc, #120]	; (581c <config_sensor_ov7670+0x18c>)
    57a2:	4798      	blx	r3
	
	PCC_SCCB_Buffer[0] = 0x3E;
    57a4:	233e      	movs	r3, #62	; 0x3e
    57a6:	713b      	strb	r3, [r7, #4]
	PCC_SCCB_Buffer[1] = 0x19;
    57a8:	2319      	movs	r3, #25
    57aa:	717b      	strb	r3, [r7, #5]
	io_write(&PCC_SCCB.io, PCC_SCCB_Buffer, 2);
    57ac:	1d3b      	adds	r3, r7, #4
    57ae:	2202      	movs	r2, #2
    57b0:	4619      	mov	r1, r3
    57b2:	4819      	ldr	r0, [pc, #100]	; (5818 <config_sensor_ov7670+0x188>)
    57b4:	4b19      	ldr	r3, [pc, #100]	; (581c <config_sensor_ov7670+0x18c>)
    57b6:	4798      	blx	r3
	
	PCC_SCCB_Buffer[0] = 0x73;
    57b8:	2373      	movs	r3, #115	; 0x73
    57ba:	713b      	strb	r3, [r7, #4]
	PCC_SCCB_Buffer[1] = 0xF1;
    57bc:	23f1      	movs	r3, #241	; 0xf1
    57be:	717b      	strb	r3, [r7, #5]
	io_write(&PCC_SCCB.io, PCC_SCCB_Buffer, 2);
    57c0:	1d3b      	adds	r3, r7, #4
    57c2:	2202      	movs	r2, #2
    57c4:	4619      	mov	r1, r3
    57c6:	4814      	ldr	r0, [pc, #80]	; (5818 <config_sensor_ov7670+0x188>)
    57c8:	4b14      	ldr	r3, [pc, #80]	; (581c <config_sensor_ov7670+0x18c>)
    57ca:	4798      	blx	r3
	
	PCC_SCCB_Buffer[0] = 0x17;
    57cc:	2317      	movs	r3, #23
    57ce:	713b      	strb	r3, [r7, #4]
	PCC_SCCB_Buffer[1] = 0x0B;
    57d0:	230b      	movs	r3, #11
    57d2:	717b      	strb	r3, [r7, #5]
	io_write(&PCC_SCCB.io, PCC_SCCB_Buffer, 2);
    57d4:	1d3b      	adds	r3, r7, #4
    57d6:	2202      	movs	r2, #2
    57d8:	4619      	mov	r1, r3
    57da:	480f      	ldr	r0, [pc, #60]	; (5818 <config_sensor_ov7670+0x188>)
    57dc:	4b0f      	ldr	r3, [pc, #60]	; (581c <config_sensor_ov7670+0x18c>)
    57de:	4798      	blx	r3
	
	PCC_SCCB_Buffer[0] = 0x32;
    57e0:	2332      	movs	r3, #50	; 0x32
    57e2:	713b      	strb	r3, [r7, #4]
	PCC_SCCB_Buffer[1] = 0x80;
    57e4:	2380      	movs	r3, #128	; 0x80
    57e6:	717b      	strb	r3, [r7, #5]
	io_write(&PCC_SCCB.io, PCC_SCCB_Buffer, 2);
    57e8:	1d3b      	adds	r3, r7, #4
    57ea:	2202      	movs	r2, #2
    57ec:	4619      	mov	r1, r3
    57ee:	480a      	ldr	r0, [pc, #40]	; (5818 <config_sensor_ov7670+0x188>)
    57f0:	4b0a      	ldr	r3, [pc, #40]	; (581c <config_sensor_ov7670+0x18c>)
    57f2:	4798      	blx	r3

	
}
    57f4:	bf00      	nop
    57f6:	3708      	adds	r7, #8
    57f8:	46bd      	mov	sp, r7
    57fa:	bd80      	pop	{r7, pc}
    57fc:	00005539 	.word	0x00005539
    5800:	00000f15 	.word	0x00000f15
    5804:	20026380 	.word	0x20026380
    5808:	20026344 	.word	0x20026344
    580c:	000012ff 	.word	0x000012ff
    5810:	000012a5 	.word	0x000012a5
    5814:	000012c5 	.word	0x000012c5
    5818:	20026358 	.word	0x20026358
    581c:	00001321 	.word	0x00001321
    5820:	00001371 	.word	0x00001371
    5824:	20000074 	.word	0x20000074
    5828:	200262e0 	.word	0x200262e0
    582c:	20000094 	.word	0x20000094

00005830 <main>:

int main(void)
{
    5830:	b580      	push	{r7, lr}
    5832:	af00      	add	r7, sp, #0
	
	/* Initializes MCU, drivers and middleware */
	atmel_start_init();
    5834:	4b30      	ldr	r3, [pc, #192]	; (58f8 <main+0xc8>)
    5836:	4798      	blx	r3
	gpio_set_pin_level(PCC_RESET, false);
    5838:	2100      	movs	r1, #0
    583a:	2057      	movs	r0, #87	; 0x57
    583c:	4b2f      	ldr	r3, [pc, #188]	; (58fc <main+0xcc>)
    583e:	4798      	blx	r3
	usart_async_enable(&EDBG_COM);
    5840:	482f      	ldr	r0, [pc, #188]	; (5900 <main+0xd0>)
    5842:	4b30      	ldr	r3, [pc, #192]	; (5904 <main+0xd4>)
    5844:	4798      	blx	r3
	
 	pwm_set_parameters(&PWM_0,22,11);
    5846:	220b      	movs	r2, #11
    5848:	2116      	movs	r1, #22
    584a:	482f      	ldr	r0, [pc, #188]	; (5908 <main+0xd8>)
    584c:	4b2f      	ldr	r3, [pc, #188]	; (590c <main+0xdc>)
    584e:	4798      	blx	r3
 
 	pwm_enable(&PWM_0);	
    5850:	482d      	ldr	r0, [pc, #180]	; (5908 <main+0xd8>)
    5852:	4b2f      	ldr	r3, [pc, #188]	; (5910 <main+0xe0>)
    5854:	4798      	blx	r3
			_usart_async_write_byte(&EDBG_COM.device, Display_title[Index]);
		}
	}
#endif
	//	memset(CAMERA_OV7670_frame_buf.hword,0x30,sizeof(CAMERA_OV7670_frame_buf.hword));
    	config_sensor_ov7670();
    5856:	4b2f      	ldr	r3, [pc, #188]	; (5914 <main+0xe4>)
    5858:	4798      	blx	r3
		ext_irq_register(PCC_VSYNC, ext_irq_cb_PCC_VSYNC);
    585a:	492f      	ldr	r1, [pc, #188]	; (5918 <main+0xe8>)
    585c:	200c      	movs	r0, #12
    585e:	4b2f      	ldr	r3, [pc, #188]	; (591c <main+0xec>)
    5860:	4798      	blx	r3
  		
 		while(gpio_get_pin_level(PCC_VSYNC) == 0);
    5862:	bf00      	nop
    5864:	200c      	movs	r0, #12
    5866:	4b2e      	ldr	r3, [pc, #184]	; (5920 <main+0xf0>)
    5868:	4798      	blx	r3
    586a:	4603      	mov	r3, r0
    586c:	f083 0301 	eor.w	r3, r3, #1
    5870:	b2db      	uxtb	r3, r3
    5872:	2b00      	cmp	r3, #0
    5874:	d1f6      	bne.n	5864 <main+0x34>
 		while(gpio_get_pin_level(PCC_VSYNC) != 0);
    5876:	bf00      	nop
    5878:	200c      	movs	r0, #12
    587a:	4b29      	ldr	r3, [pc, #164]	; (5920 <main+0xf0>)
    587c:	4798      	blx	r3
    587e:	4603      	mov	r3, r0
    5880:	2b00      	cmp	r3, #0
    5882:	d1f9      	bne.n	5878 <main+0x48>
 		camera_async_enable(&CAMERA_OV7670);
    5884:	4827      	ldr	r0, [pc, #156]	; (5924 <main+0xf4>)
    5886:	4b28      	ldr	r3, [pc, #160]	; (5928 <main+0xf8>)
    5888:	4798      	blx	r3
 		camera_async_capture_start(&CAMERA_OV7670, 0, (uint32_t *) &CAMERA_OV7670_frame_buf.hword[0]);
    588a:	4a28      	ldr	r2, [pc, #160]	; (592c <main+0xfc>)
    588c:	2100      	movs	r1, #0
    588e:	4825      	ldr	r0, [pc, #148]	; (5924 <main+0xf4>)
    5890:	4b27      	ldr	r3, [pc, #156]	; (5930 <main+0x100>)
    5892:	4798      	blx	r3

		
 		flag_frame_captured = 0;
    5894:	4b27      	ldr	r3, [pc, #156]	; (5934 <main+0x104>)
    5896:	2200      	movs	r2, #0
    5898:	601a      	str	r2, [r3, #0]
 		while(flag_frame_captured == 0);
    589a:	bf00      	nop
    589c:	4b25      	ldr	r3, [pc, #148]	; (5934 <main+0x104>)
    589e:	681b      	ldr	r3, [r3, #0]
    58a0:	2b00      	cmp	r3, #0
    58a2:	d0fb      	beq.n	589c <main+0x6c>
 		camera_async_disable(&CAMERA_OV7670);
    58a4:	481f      	ldr	r0, [pc, #124]	; (5924 <main+0xf4>)
    58a6:	4b24      	ldr	r3, [pc, #144]	; (5938 <main+0x108>)
    58a8:	4798      	blx	r3
 		ext_irq_disable(PCC_VSYNC);
    58aa:	200c      	movs	r0, #12
    58ac:	4b23      	ldr	r3, [pc, #140]	; (593c <main+0x10c>)
    58ae:	4798      	blx	r3
	  //  memset(CAMERA_OV7670_frame_buf.hword,0x30,sizeof(CAMERA_OV7670_frame_buf.hword));
		for(Index = 0; Index < 153600; Index++)		
    58b0:	4b23      	ldr	r3, [pc, #140]	; (5940 <main+0x110>)
    58b2:	2200      	movs	r2, #0
    58b4:	601a      	str	r2, [r3, #0]
    58b6:	e019      	b.n	58ec <main+0xbc>
		{
			while(_usart_async_is_byte_sent(&EDBG_COM.device) == 0);
    58b8:	bf00      	nop
    58ba:	4822      	ldr	r0, [pc, #136]	; (5944 <main+0x114>)
    58bc:	4b22      	ldr	r3, [pc, #136]	; (5948 <main+0x118>)
    58be:	4798      	blx	r3
    58c0:	4603      	mov	r3, r0
    58c2:	f083 0301 	eor.w	r3, r3, #1
    58c6:	b2db      	uxtb	r3, r3
    58c8:	2b00      	cmp	r3, #0
    58ca:	d1f6      	bne.n	58ba <main+0x8a>
			_usart_async_write_byte(&EDBG_COM.device, CAMERA_OV7670_frame_buf.byte[Index]);
    58cc:	4b1c      	ldr	r3, [pc, #112]	; (5940 <main+0x110>)
    58ce:	681b      	ldr	r3, [r3, #0]
    58d0:	4a16      	ldr	r2, [pc, #88]	; (592c <main+0xfc>)
    58d2:	5cd3      	ldrb	r3, [r2, r3]
    58d4:	4619      	mov	r1, r3
    58d6:	481b      	ldr	r0, [pc, #108]	; (5944 <main+0x114>)
    58d8:	4b1c      	ldr	r3, [pc, #112]	; (594c <main+0x11c>)
    58da:	4798      	blx	r3
			delay_us(10);
    58dc:	200a      	movs	r0, #10
    58de:	4b1c      	ldr	r3, [pc, #112]	; (5950 <main+0x120>)
    58e0:	4798      	blx	r3
		for(Index = 0; Index < 153600; Index++)		
    58e2:	4b17      	ldr	r3, [pc, #92]	; (5940 <main+0x110>)
    58e4:	681b      	ldr	r3, [r3, #0]
    58e6:	3301      	adds	r3, #1
    58e8:	4a15      	ldr	r2, [pc, #84]	; (5940 <main+0x110>)
    58ea:	6013      	str	r3, [r2, #0]
    58ec:	4b14      	ldr	r3, [pc, #80]	; (5940 <main+0x110>)
    58ee:	681b      	ldr	r3, [r3, #0]
    58f0:	f5b3 3f16 	cmp.w	r3, #153600	; 0x25800
    58f4:	d3e0      	bcc.n	58b8 <main+0x88>
		}
		
		while (1);
    58f6:	e7fe      	b.n	58f6 <main+0xc6>
    58f8:	000002d1 	.word	0x000002d1
    58fc:	00005539 	.word	0x00005539
    5900:	200262e0 	.word	0x200262e0
    5904:	000015c9 	.word	0x000015c9
    5908:	200262c4 	.word	0x200262c4
    590c:	00001479 	.word	0x00001479
    5910:	00001425 	.word	0x00001425
    5914:	00005691 	.word	0x00005691
    5918:	00005681 	.word	0x00005681
    591c:	00000fa9 	.word	0x00000fa9
    5920:	00005571 	.word	0x00005571
    5924:	20026330 	.word	0x20026330
    5928:	000055ad 	.word	0x000055ad
    592c:	20000ac0 	.word	0x20000ac0
    5930:	00005625 	.word	0x00005625
    5934:	200262c0 	.word	0x200262c0
    5938:	000055e9 	.word	0x000055e9
    593c:	00001101 	.word	0x00001101
    5940:	20026378 	.word	0x20026378
    5944:	200262e8 	.word	0x200262e8
    5948:	00003f15 	.word	0x00003f15
    594c:	00003eed 	.word	0x00003eed
    5950:	00000ee1 	.word	0x00000ee1

00005954 <ffs>:
    5954:	b140      	cbz	r0, 5968 <ffs+0x14>
    5956:	2300      	movs	r3, #0
    5958:	fa40 f103 	asr.w	r1, r0, r3
    595c:	1c5a      	adds	r2, r3, #1
    595e:	07c9      	lsls	r1, r1, #31
    5960:	4613      	mov	r3, r2
    5962:	d5f9      	bpl.n	5958 <ffs+0x4>
    5964:	4610      	mov	r0, r2
    5966:	4770      	bx	lr
    5968:	4602      	mov	r2, r0
    596a:	4610      	mov	r0, r2
    596c:	4770      	bx	lr
    596e:	bf00      	nop

00005970 <__libc_init_array>:
    5970:	b570      	push	{r4, r5, r6, lr}
    5972:	4e0f      	ldr	r6, [pc, #60]	; (59b0 <__libc_init_array+0x40>)
    5974:	4d0f      	ldr	r5, [pc, #60]	; (59b4 <__libc_init_array+0x44>)
    5976:	1b76      	subs	r6, r6, r5
    5978:	10b6      	asrs	r6, r6, #2
    597a:	bf18      	it	ne
    597c:	2400      	movne	r4, #0
    597e:	d005      	beq.n	598c <__libc_init_array+0x1c>
    5980:	3401      	adds	r4, #1
    5982:	f855 3b04 	ldr.w	r3, [r5], #4
    5986:	4798      	blx	r3
    5988:	42a6      	cmp	r6, r4
    598a:	d1f9      	bne.n	5980 <__libc_init_array+0x10>
    598c:	4e0a      	ldr	r6, [pc, #40]	; (59b8 <__libc_init_array+0x48>)
    598e:	4d0b      	ldr	r5, [pc, #44]	; (59bc <__libc_init_array+0x4c>)
    5990:	1b76      	subs	r6, r6, r5
    5992:	f000 fa5b 	bl	5e4c <_init>
    5996:	10b6      	asrs	r6, r6, #2
    5998:	bf18      	it	ne
    599a:	2400      	movne	r4, #0
    599c:	d006      	beq.n	59ac <__libc_init_array+0x3c>
    599e:	3401      	adds	r4, #1
    59a0:	f855 3b04 	ldr.w	r3, [r5], #4
    59a4:	4798      	blx	r3
    59a6:	42a6      	cmp	r6, r4
    59a8:	d1f9      	bne.n	599e <__libc_init_array+0x2e>
    59aa:	bd70      	pop	{r4, r5, r6, pc}
    59ac:	bd70      	pop	{r4, r5, r6, pc}
    59ae:	bf00      	nop
    59b0:	00005e58 	.word	0x00005e58
    59b4:	00005e58 	.word	0x00005e58
    59b8:	00005e60 	.word	0x00005e60
    59bc:	00005e58 	.word	0x00005e58

000059c0 <register_fini>:
    59c0:	4b02      	ldr	r3, [pc, #8]	; (59cc <register_fini+0xc>)
    59c2:	b113      	cbz	r3, 59ca <register_fini+0xa>
    59c4:	4802      	ldr	r0, [pc, #8]	; (59d0 <register_fini+0x10>)
    59c6:	f000 b805 	b.w	59d4 <atexit>
    59ca:	4770      	bx	lr
    59cc:	00000000 	.word	0x00000000
    59d0:	000059e1 	.word	0x000059e1

000059d4 <atexit>:
    59d4:	2300      	movs	r3, #0
    59d6:	4601      	mov	r1, r0
    59d8:	461a      	mov	r2, r3
    59da:	4618      	mov	r0, r3
    59dc:	f000 b81e 	b.w	5a1c <__register_exitproc>

000059e0 <__libc_fini_array>:
    59e0:	b538      	push	{r3, r4, r5, lr}
    59e2:	4c0a      	ldr	r4, [pc, #40]	; (5a0c <__libc_fini_array+0x2c>)
    59e4:	4d0a      	ldr	r5, [pc, #40]	; (5a10 <__libc_fini_array+0x30>)
    59e6:	1b64      	subs	r4, r4, r5
    59e8:	10a4      	asrs	r4, r4, #2
    59ea:	d00a      	beq.n	5a02 <__libc_fini_array+0x22>
    59ec:	f104 4380 	add.w	r3, r4, #1073741824	; 0x40000000
    59f0:	3b01      	subs	r3, #1
    59f2:	eb05 0583 	add.w	r5, r5, r3, lsl #2
    59f6:	3c01      	subs	r4, #1
    59f8:	f855 3904 	ldr.w	r3, [r5], #-4
    59fc:	4798      	blx	r3
    59fe:	2c00      	cmp	r4, #0
    5a00:	d1f9      	bne.n	59f6 <__libc_fini_array+0x16>
    5a02:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    5a06:	f000 ba2b 	b.w	5e60 <_fini>
    5a0a:	bf00      	nop
    5a0c:	00005e70 	.word	0x00005e70
    5a10:	00005e6c 	.word	0x00005e6c

00005a14 <__retarget_lock_acquire_recursive>:
    5a14:	4770      	bx	lr
    5a16:	bf00      	nop

00005a18 <__retarget_lock_release_recursive>:
    5a18:	4770      	bx	lr
    5a1a:	bf00      	nop

00005a1c <__register_exitproc>:
    5a1c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    5a20:	4d2c      	ldr	r5, [pc, #176]	; (5ad4 <__register_exitproc+0xb8>)
    5a22:	4606      	mov	r6, r0
    5a24:	6828      	ldr	r0, [r5, #0]
    5a26:	4698      	mov	r8, r3
    5a28:	460f      	mov	r7, r1
    5a2a:	4691      	mov	r9, r2
    5a2c:	f7ff fff2 	bl	5a14 <__retarget_lock_acquire_recursive>
    5a30:	4b29      	ldr	r3, [pc, #164]	; (5ad8 <__register_exitproc+0xbc>)
    5a32:	681c      	ldr	r4, [r3, #0]
    5a34:	f8d4 3148 	ldr.w	r3, [r4, #328]	; 0x148
    5a38:	2b00      	cmp	r3, #0
    5a3a:	d03e      	beq.n	5aba <__register_exitproc+0x9e>
    5a3c:	685a      	ldr	r2, [r3, #4]
    5a3e:	2a1f      	cmp	r2, #31
    5a40:	dc1c      	bgt.n	5a7c <__register_exitproc+0x60>
    5a42:	f102 0e01 	add.w	lr, r2, #1
    5a46:	b176      	cbz	r6, 5a66 <__register_exitproc+0x4a>
    5a48:	eb03 0182 	add.w	r1, r3, r2, lsl #2
    5a4c:	2401      	movs	r4, #1
    5a4e:	f8c1 9088 	str.w	r9, [r1, #136]	; 0x88
    5a52:	f8d3 0188 	ldr.w	r0, [r3, #392]	; 0x188
    5a56:	4094      	lsls	r4, r2
    5a58:	4320      	orrs	r0, r4
    5a5a:	2e02      	cmp	r6, #2
    5a5c:	f8c3 0188 	str.w	r0, [r3, #392]	; 0x188
    5a60:	f8c1 8108 	str.w	r8, [r1, #264]	; 0x108
    5a64:	d023      	beq.n	5aae <__register_exitproc+0x92>
    5a66:	3202      	adds	r2, #2
    5a68:	f8c3 e004 	str.w	lr, [r3, #4]
    5a6c:	6828      	ldr	r0, [r5, #0]
    5a6e:	f843 7022 	str.w	r7, [r3, r2, lsl #2]
    5a72:	f7ff ffd1 	bl	5a18 <__retarget_lock_release_recursive>
    5a76:	2000      	movs	r0, #0
    5a78:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    5a7c:	4b17      	ldr	r3, [pc, #92]	; (5adc <__register_exitproc+0xc0>)
    5a7e:	b30b      	cbz	r3, 5ac4 <__register_exitproc+0xa8>
    5a80:	f44f 70c8 	mov.w	r0, #400	; 0x190
    5a84:	f3af 8000 	nop.w
    5a88:	4603      	mov	r3, r0
    5a8a:	b1d8      	cbz	r0, 5ac4 <__register_exitproc+0xa8>
    5a8c:	f8d4 2148 	ldr.w	r2, [r4, #328]	; 0x148
    5a90:	6002      	str	r2, [r0, #0]
    5a92:	2100      	movs	r1, #0
    5a94:	6041      	str	r1, [r0, #4]
    5a96:	460a      	mov	r2, r1
    5a98:	f8c4 0148 	str.w	r0, [r4, #328]	; 0x148
    5a9c:	f04f 0e01 	mov.w	lr, #1
    5aa0:	f8c0 1188 	str.w	r1, [r0, #392]	; 0x188
    5aa4:	f8c0 118c 	str.w	r1, [r0, #396]	; 0x18c
    5aa8:	2e00      	cmp	r6, #0
    5aaa:	d0dc      	beq.n	5a66 <__register_exitproc+0x4a>
    5aac:	e7cc      	b.n	5a48 <__register_exitproc+0x2c>
    5aae:	f8d3 118c 	ldr.w	r1, [r3, #396]	; 0x18c
    5ab2:	430c      	orrs	r4, r1
    5ab4:	f8c3 418c 	str.w	r4, [r3, #396]	; 0x18c
    5ab8:	e7d5      	b.n	5a66 <__register_exitproc+0x4a>
    5aba:	f504 73a6 	add.w	r3, r4, #332	; 0x14c
    5abe:	f8c4 3148 	str.w	r3, [r4, #328]	; 0x148
    5ac2:	e7bb      	b.n	5a3c <__register_exitproc+0x20>
    5ac4:	6828      	ldr	r0, [r5, #0]
    5ac6:	f7ff ffa7 	bl	5a18 <__retarget_lock_release_recursive>
    5aca:	f04f 30ff 	mov.w	r0, #4294967295
    5ace:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    5ad2:	bf00      	nop
    5ad4:	200004d8 	.word	0x200004d8
    5ad8:	00005e48 	.word	0x00005e48
    5adc:	00000000 	.word	0x00000000
    5ae0:	682f2e2e 	.word	0x682f2e2e
    5ae4:	702f6c70 	.word	0x702f6c70
    5ae8:	2f74726f 	.word	0x2f74726f
    5aec:	5f6c7068 	.word	0x5f6c7068
    5af0:	6f697067 	.word	0x6f697067
    5af4:	7361625f 	.word	0x7361625f
    5af8:	00682e65 	.word	0x00682e65
    5afc:	682f2e2e 	.word	0x682f2e2e
    5b00:	732f6c61 	.word	0x732f6c61
    5b04:	682f6372 	.word	0x682f6372
    5b08:	635f6c61 	.word	0x635f6c61
    5b0c:	72656d61 	.word	0x72656d61
    5b10:	73615f61 	.word	0x73615f61
    5b14:	2e636e79 	.word	0x2e636e79
    5b18:	00000063 	.word	0x00000063
    5b1c:	682f2e2e 	.word	0x682f2e2e
    5b20:	732f6c61 	.word	0x732f6c61
    5b24:	682f6372 	.word	0x682f6372
    5b28:	695f6c61 	.word	0x695f6c61
    5b2c:	6d5f6332 	.word	0x6d5f6332
    5b30:	6e79735f 	.word	0x6e79735f
    5b34:	00632e63 	.word	0x00632e63
    5b38:	682f2e2e 	.word	0x682f2e2e
    5b3c:	732f6c61 	.word	0x732f6c61
    5b40:	682f6372 	.word	0x682f6372
    5b44:	695f6c61 	.word	0x695f6c61
    5b48:	00632e6f 	.word	0x00632e6f
    5b4c:	682f2e2e 	.word	0x682f2e2e
    5b50:	732f6c61 	.word	0x732f6c61
    5b54:	682f6372 	.word	0x682f6372
    5b58:	705f6c61 	.word	0x705f6c61
    5b5c:	632e6d77 	.word	0x632e6d77
    5b60:	00000000 	.word	0x00000000
    5b64:	682f2e2e 	.word	0x682f2e2e
    5b68:	732f6c61 	.word	0x732f6c61
    5b6c:	682f6372 	.word	0x682f6372
    5b70:	755f6c61 	.word	0x755f6c61
    5b74:	74726173 	.word	0x74726173
    5b78:	7973615f 	.word	0x7973615f
    5b7c:	632e636e 	.word	0x632e636e
    5b80:	00000000 	.word	0x00000000
    5b84:	682f2e2e 	.word	0x682f2e2e
    5b88:	752f6c61 	.word	0x752f6c61
    5b8c:	736c6974 	.word	0x736c6974
    5b90:	6372732f 	.word	0x6372732f
    5b94:	6974752f 	.word	0x6974752f
    5b98:	725f736c 	.word	0x725f736c
    5b9c:	62676e69 	.word	0x62676e69
    5ba0:	65666675 	.word	0x65666675
    5ba4:	00632e72 	.word	0x00632e72

00005ba8 <_cfgs>:
    5ba8:	00205000 0a1ec500 00000000 00000000     .P .............
	...

00005ca8 <_map>:
    5ca8:	0000000c 0000000c 0000000d 0000000d     ................
    5cb8:	682f2e2e 652f6c70 682f6369 655f6c70     ../hpl/eic/hpl_e
    5cc8:	632e6369 00000000                       ic.c....

00005cd0 <user_mux_confs>:
    5cd0:	00000200 00000200 00000000 00000000     ................
	...

00005d14 <channel_confs>:
    5d14:	051e0000 00000000 00000000 00000000     ................
	...

00005d54 <interrupt_cfg>:
	...
    5dd4:	682f2e2e 732f6c70 6f637265 70682f6d     ../hpl/sercom/hp
    5de4:	65735f6c 6d6f6372 0000632e 40003000     l_sercom.c...0.@
    5df4:	40003400 41012000 41014000 43000000     .4.@. .A.@.A...C
    5e04:	43000400 43000800 43000c00              ...C...C...C

00005e10 <sercomspi_regs>:
	...
    5e24:	682f2e2e 692f6c61 756c636e 682f6564     ../hal/include/h
    5e34:	635f6c61 72656d61 73615f61 2e636e79     al_camera_async.
    5e44:	00000068                                h...

00005e48 <_global_impure_ptr>:
    5e48:	200000b0                                ... 

00005e4c <_init>:
    5e4c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    5e4e:	bf00      	nop
    5e50:	bcf8      	pop	{r3, r4, r5, r6, r7}
    5e52:	bc08      	pop	{r3}
    5e54:	469e      	mov	lr, r3
    5e56:	4770      	bx	lr

00005e58 <__init_array_start>:
    5e58:	000059c1 	.word	0x000059c1

00005e5c <__frame_dummy_init_array_entry>:
    5e5c:	00000289                                ....

00005e60 <_fini>:
    5e60:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    5e62:	bf00      	nop
    5e64:	bcf8      	pop	{r3, r4, r5, r6, r7}
    5e66:	bc08      	pop	{r3}
    5e68:	469e      	mov	lr, r3
    5e6a:	4770      	bx	lr

00005e6c <__fini_array_start>:
    5e6c:	00000265 	.word	0x00000265
